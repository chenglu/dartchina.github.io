<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="en_US" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Guidelines for using language features to write maintainable code.">
  <title>Effective Dart: 使用 | Dart</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/touch-icon-iphone.png" rel="apple-touch-icon">
  <link href="/assets/touch-icon-ipad.png" rel="apple-touch-icon" sizes="76x76">
  <link href="/assets/touch-icon-iphone-retina.png" rel="apple-touch-icon" sizes="120x120">
  <link href="/assets/touch-icon-ipad-retina.png" rel="apple-touch-icon" sizes="152x152">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Effective Dart: 使用" />
  <meta name="twitter:description" content="Guidelines for using language features to write maintainable code." />

  <!-- Open Graph -->
  <meta property="og:title" content="Effective Dart: 使用" />
  <meta property="og:description" content="Guidelines for using language features to write maintainable code." />
  <meta property="og:url" content="https://www.dartlang.org/guides/language/effective-dart/usage" />
  <meta property="og:image" content="https://www.dartlang.org/assets/shared/dart-logo-for-shares.png?2" />

  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,700' rel='stylesheet' type='text/css'>
  <link type="text/css" rel="stylesheet" href="/assets/style.css">
  
  <!--
    Why don't we use Dart here?

    The only scripting we use here is stuff like the on-click footnotes on the
    front page or resizing of the left nav. These happen to be use cases where
    JavaScript and jQuery are doing just fine. Dart is here for application
    programming, not page scripting.
   -->
  <script type="text/javascript" src="/assets/main.js"></script>
  
  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


</head>

  <body class="default">
    <header id="page-header">
  <nav id="mainnav">
  <div id="menu-toggle"><i class="icon icon-menu"></i></div>
  <a href="/" class="brand" title="Dart">
    <img src="/assets/shared/dart/logo+text/horizontal/default.svg" alt="Dart">
  </a>
  <ul>
    <li class="mainnav__get-started"><a href="/guides/get-started"><span>入门</span></a></li>
    <li><a href="/guides/language">语言</a></li>
    <li><a href="/guides/libraries">库</a></li>
    <li><a href="/tools">工具</a></li>
    
    
    <li class="dropdown">
      <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dart 2 <span class="caret"></span></a>
      <ul class="dropdown-menu">
        

<li><a href="https://v1-dartlang-org.firebaseapp.com/guides/language/effective-dart/usage" class="no-automatic-external">1.24.3&nbsp;&nbsp;(archive)</a></li><li><a class="active">2.0.0-dev.69.4&nbsp;&nbsp;(beta)</a></li>

        <li role="separator" class="divider"></li>
        <li><a href="/dart-2#migration">迁移指南</a></li>
      </ul>
    </li>
    
    <li class="searchfield">
      <form class="navbar-search" action="/search" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input type="search" name="q" id="q" autocomplete="off" placeholder="Search">
        <button type="submit"><i class="icon icon-search"></i></button>
      </form>
    </li>
  </ul>
</nav>

  
</header>

    <main id="page-content">
      <div id="sidenav" class="">
  <div class="content">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/shared/dart/logo+text/horizontal/default.svg" alt="Dart">
    </a>

    <div class="sidenav__search">
      <p>
        <a href="/search">Search <i class="icon icon-search"></i></a>
      </p>
    </div>

    <ul>
      <li>
        <a class="btn btn-default" href="/guides/get-started">入门</a>
      </li>
    </ul>
    <h4 ><a href="/guides/language" title="语言">语言</a></h4>
  <ul><li >
          <a href="/guides/language/language-tour" title="概览">概览</a>
        </li>
        
        <li class="active">
          <a href="/guides/language/effective-dart" title="Effective Dart">Effective Dart</a>
          <i class="icon icon-arrow"></i>
          <ul><li >
                <a href="/guides/language/effective-dart/style" title="风格">风格</a>
              </li><li >
                <a href="/guides/language/effective-dart/documentation" title="文档">文档</a>
              </li><li class="active">
                <a href="/guides/language/effective-dart/usage" title="使用">使用</a>
              </li><li >
                <a href="/guides/language/effective-dart/design" title="设计">设计</a>
              </li>
          </ul><li >
          <a href="/samples" title="示例代码">示例代码</a>
        </li>
  </ul><h4 ><a href="/guides/libraries" title="库">库</a></h4>
  <ul><li >
          <a href="/guides/libraries/library-tour" title="概览">概览</a>
        </li>
  </ul><h4 ><a href="/guides/platforms" title="平台">平台</a></h4>
  <ul><li >
          <a href="https://flutter.io" title="移动端 (Flutter)">移动端 (Flutter)</a>
        </li><li >
          <a href="https://webdev.dartlang.org" title="web">web</a>
        </li><li >
          <a href="/dart-vm" title="服务器">服务器</a>
        </li>
  </ul><h4 ><a href="/guides/testing" title="测试">测试</a></h4>
  <ul>
  </ul><h4 >资源</h4>
  <ul><li >
          <a href="/install" title="安装">安装</a>
        </li><li >
          <a href="/codelabs" title="Codelabs">Codelabs</a>
        </li><li >
          <a href="/tutorials" title="学习指南">学习指南</a>
        </li><li >
          <a href="/articles" title="文章">文章</a>
        </li><li >
          <a href="/tools" title="工具">工具</a>
        </li><li >
          <a href="/community" title="社区支持">社区支持</a>
        </li>
  </ul>
  </div>
</div>

      
<div id="toc">
  <div class="content">
    <h4>目录
      <a href="#page-content" title="Back to top" class="pull-right"><i class="icon icon-caret-up"></i></a>
    </h4>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#库">库</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-在-part-of-中使用字符串">要 在 part of 中使用字符串。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-导入-package-中-src-目录下的库">不要 导入 package 中 src 目录下的库。</a></li>
<li class="toc-entry toc-h3"><a href="#建议-使用相对路径在导入你自己-package-中的-lib-目录">建议 使用相对路径在导入你自己 package 中的 lib 目录。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#字符串">字符串</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-使用临近字符字的方式连接字面量字符串">要 使用临近字符字的方式连接字面量字符串。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用插值的形式来组合字符串和值">推荐 使用插值的形式来组合字符串和值。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在字符串插值中使用不必要的大括号">避免 在字符串插值中使用不必要的大括号。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#集合">集合</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-尽可能的使用集合字面量">要 尽可能的使用集合字面量。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用-length-来判断一个集合是否为空">不要 使用 .length 来判断一个集合是否为空。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-使用高阶higher-order函数来转换集合数据">考虑 使用高阶（higher-order）函数来转换集合数据。</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-using-iterableforeach-with-a-function-literal">AVOID using Iterable.forEach() with a function literal.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-listfrom-unless-you-intend-to-change-the-type-of-the-result">DON’T use List.from() unless you intend to change the type of the result.</a></li>
<li class="toc-entry toc-h3"><a href="#do-use-wheretype-to-filter-a-collection-by-type">DO use whereType() to filter a collection by type.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-cast-when-a-nearby-operation-will-do">DON’T use cast() when a nearby operation will do.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-using-cast">AVOID using cast().</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#functions">Functions</a>
<ul>
<li class="toc-entry toc-h3"><a href="#do-use-a-function-declaration-to-bind-a-function-to-a-name">DO use a function declaration to bind a function to a name.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-create-a-lambda-when-a-tear-off-will-do">DON’T create a lambda when a tear-off will do.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#parameters">Parameters</a>
<ul>
<li class="toc-entry toc-h3"><a href="#do-use--to-separate-a-named-parameter-from-its-default-value">DO use = to separate a named parameter from its default value.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-an-explicit-default-value-of-null">DON’T use an explicit default value of null.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#variables">Variables</a>
<ul>
<li class="toc-entry toc-h3"><a href="#dont-explicitly-initialize-variables-to-null">DON’T explicitly initialize variables to null.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-storing-what-you-can-calculate">AVOID storing what you can calculate.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#members">Members</a>
<ul>
<li class="toc-entry toc-h3"><a href="#dont-wrap-a-field-in-a-getter-and-setter-unnecessarily">DON’T wrap a field in a getter and setter unnecessarily.</a></li>
<li class="toc-entry toc-h3"><a href="#prefer-using-a-final-field-to-make-a-read-only-property">PREFER using a final field to make a read-only property.</a></li>
<li class="toc-entry toc-h3"><a href="#consider-using--for-simple-members">CONSIDER using => for simple members.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-this-when-not-needed-to-avoid-shadowing">DON’T use this. when not needed to avoid shadowing.</a></li>
<li class="toc-entry toc-h3"><a href="#do-initialize-fields-at-their-declaration-when-possible">DO initialize fields at their declaration when possible.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#constructors">Constructors</a>
<ul>
<li class="toc-entry toc-h3"><a href="#do-use-initializing-formals-when-possible">DO use initializing formals when possible.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-type-annotate-initializing-formals">DON’T type annotate initializing formals.</a></li>
<li class="toc-entry toc-h3"><a href="#do-use--instead-of--for-empty-constructor-bodies">DO use ; instead of {} for empty constructor bodies.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-new">DON’T use new.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-const-redundantly">DON’T use const redundantly.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#error-handling">Error handling</a>
<ul>
<li class="toc-entry toc-h3"><a href="#avoid-catches-without-on-clauses">AVOID catches without on clauses.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-discard-errors-from-catches-without-on-clauses">DON’T discard errors from catches without on clauses.</a></li>
<li class="toc-entry toc-h3"><a href="#do-throw-objects-that-implement-error-only-for-programmatic-errors">DO throw objects that implement Error only for programmatic errors.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-explicitly-catch-error-or-types-that-implement-it">DON’T explicitly catch Error or types that implement it.</a></li>
<li class="toc-entry toc-h3"><a href="#do-use-rethrow-to-rethrow-a-caught-exception">DO use rethrow to rethrow a caught exception.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#asynchrony">Asynchrony</a>
<ul>
<li class="toc-entry toc-h3"><a href="#prefer-asyncawait-over-using-raw-futures">PREFER async/await over using raw futures.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-async-when-it-has-no-useful-effect">DON’T use async when it has no useful effect.</a></li>
<li class="toc-entry toc-h3"><a href="#consider-using-higher-order-methods-to-transform-a-stream">CONSIDER using higher-order methods to transform a stream.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-using-completer-directly">AVOID using Completer directly.</a></li>
<li class="toc-entry toc-h3"><a href="#do-test-for-futuret-when-disambiguating-a-futureort-whose-type-argument-could-be-object">DO test for Future<T> when disambiguating a FutureOr<T> whose type argument could be Object.</a></li>
</ul>
</li>
</ul>
  </div>
</div>


      <article>
        <div class="content">
          
<div class="banner alert alert-info">
  <p class="banner__text">
    欢迎来到 <a href="/dart-2"><b>Dart 2</b></a>!
    如果您仍在使用 Dart 1.x? 可访问查阅
    <a href="https://v1-dartlang-org.firebaseapp.com" class="no-automatic-external" target="_blank" rel="noopener">存档站点</a>
    或 <a href="/dart-2#migration">迁移指南</a>.
  </p>
</div>


          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/documentation">&lang;&nbsp;&nbsp;文档注释</a>
      
    </li>
    <li class="next">
      
        <a href="/guides/language/effective-dart/design">设计&nbsp;&nbsp;&rang;</a>
      
    </li>
  </ul>
</nav>


          
          <div>
            <ul class="page-github-links-menu" role="group">
  <li>
    <a href="https://github.com/dart-lang/site-www/tree/master/src_zh_CN/_guides/language/effective-dart/usage.md"
      class="no-automatic-external"
      title="View page source"
      target="_blank" rel="noopener">
      <i class="fab fa-github fa-sm"></i>
    </a>
  </li>
  <li>
    <a href="https://github.com/dart-lang/site-www/issues/new?title='Effective Dart: 使用' page issue&body=From URL: https://www.dartlang.org/guides/language/effective-dart/usage"
      class="no-automatic-external"
      title="Report a bug on this page" target="_blank" rel="noopener">
      <i class="fas fa-bug fa-sm"></i>
    </a>
  </li>
</ul>

            <h1>Effective Dart: 使用</h1>
          </div>
          <?code-excerpt replace="/([A-Z]\w*)\d\b/$1/g"?>

<div class="banner">
  <p class="banner__text">
    <em>Effective Dart</em> 正在更新，
    以提供关于 Dart 2 的最新实践。
    如果你发现了一个 <a target="_blank" href="https://github.com/dart-lang/site-www/labels/EffectiveDart">known issue</a>
    中没有提及的问题，
    请报告这个 bug 。
  </p>
</div>

<p>该指南在 Effective Dart 中是最为基础的部分。
每天在你写的 Dart 代码中都会应用到这些准则。
库的<em>使用者</em>可能不需要知道你在其中的一些想法，
但是<em>维护者</em>肯定是需要的。</p>

<ul id="markdown-toc">
  <li>
<a href="#%E5%BA%93" id="markdown-toc-库">库</a>    <ul>
      <li><a href="#%E8%A6%81-%E5%9C%A8-part-of-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2" id="markdown-toc-要-在-part-of-中使用字符串"><strong>要</strong> 在 <code class="highlighter-rouge">part of</code> 中使用字符串。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E5%AF%BC%E5%85%A5-package-%E4%B8%AD-src-%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%BA%93" id="markdown-toc-不要-导入-package-中-src-目录下的库"><strong>不要</strong> 导入 package 中 <code class="highlighter-rouge">src</code> 目录下的库。</a></li>
      <li><a href="#%E5%BB%BA%E8%AE%AE-%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%9C%A8%E5%AF%BC%E5%85%A5%E4%BD%A0%E8%87%AA%E5%B7%B1-package-%E4%B8%AD%E7%9A%84-lib-%E7%9B%AE%E5%BD%95" id="markdown-toc-建议-使用相对路径在导入你自己-package-中的-lib-目录"><strong>建议</strong> 使用相对路径在导入你自己 package 中的 <code class="highlighter-rouge">lib</code> 目录。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2" id="markdown-toc-字符串">字符串</a>    <ul>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%B4%E8%BF%91%E5%AD%97%E7%AC%A6%E5%AD%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2" id="markdown-toc-要-使用临近字符字的方式连接字面量字符串"><strong>要</strong> 使用临近字符字的方式连接字面量字符串。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E7%BB%84%E5%90%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%80%BC" id="markdown-toc-推荐-使用插值的形式来组合字符串和值"><strong>推荐</strong> 使用插值的形式来组合字符串和值。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7" id="markdown-toc-避免-在字符串插值中使用不必要的大括号"><strong>避免</strong> 在字符串插值中使用不必要的大括号。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E9%9B%86%E5%90%88" id="markdown-toc-集合">集合</a>    <ul>
      <li><a href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F" id="markdown-toc-要-尽可能的使用集合字面量"><strong>要</strong> 尽可能的使用集合字面量。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-length-%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" id="markdown-toc-不要-使用-length-来判断一个集合是否为空"><strong>不要</strong> 使用 <code class="highlighter-rouge">.length</code> 来判断一个集合是否为空。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6higher-order%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BD%AC%E6%8D%A2%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE" id="markdown-toc-考虑-使用高阶higher-order函数来转换集合数据"><strong>考虑</strong> 使用高阶（higher-order）函数来转换集合数据。</a></li>
      <li><a href="#avoid-using-iterableforeach-with-a-function-literal" id="markdown-toc-avoid-using-iterableforeach-with-a-function-literal">AVOID using <code class="highlighter-rouge">Iterable.forEach()</code> with a function literal.</a></li>
      <li><a href="#dont-use-listfrom-unless-you-intend-to-change-the-type-of-the-result" id="markdown-toc-dont-use-listfrom-unless-you-intend-to-change-the-type-of-the-result">DON’T use <code class="highlighter-rouge">List.from()</code> unless you intend to change the type of the result.</a></li>
      <li><a href="#do-use-wheretype-to-filter-a-collection-by-type" id="markdown-toc-do-use-wheretype-to-filter-a-collection-by-type">DO use <code class="highlighter-rouge">whereType()</code> to filter a collection by type.</a></li>
      <li><a href="#dont-use-cast-when-a-nearby-operation-will-do" id="markdown-toc-dont-use-cast-when-a-nearby-operation-will-do">DON’T use <code class="highlighter-rouge">cast()</code> when a nearby operation will do.</a></li>
      <li><a href="#avoid-using-cast" id="markdown-toc-avoid-using-cast">AVOID using <code class="highlighter-rouge">cast()</code>.</a></li>
    </ul>
  </li>
  <li>
<a href="#functions" id="markdown-toc-functions">Functions</a>    <ul>
      <li><a href="#do-use-a-function-declaration-to-bind-a-function-to-a-name" id="markdown-toc-do-use-a-function-declaration-to-bind-a-function-to-a-name">DO use a function declaration to bind a function to a name.</a></li>
      <li><a href="#dont-create-a-lambda-when-a-tear-off-will-do" id="markdown-toc-dont-create-a-lambda-when-a-tear-off-will-do">DON’T create a lambda when a tear-off will do.</a></li>
    </ul>
  </li>
  <li>
<a href="#parameters" id="markdown-toc-parameters">Parameters</a>    <ul>
      <li><a href="#do-use--to-separate-a-named-parameter-from-its-default-value" id="markdown-toc-do-use--to-separate-a-named-parameter-from-its-default-value">DO use <code class="highlighter-rouge">=</code> to separate a named parameter from its default value.</a></li>
      <li><a href="#dont-use-an-explicit-default-value-of-null" id="markdown-toc-dont-use-an-explicit-default-value-of-null">DON’T use an explicit default value of <code class="highlighter-rouge">null</code>.</a></li>
    </ul>
  </li>
  <li>
<a href="#variables" id="markdown-toc-variables">Variables</a>    <ul>
      <li><a href="#dont-explicitly-initialize-variables-to-null" id="markdown-toc-dont-explicitly-initialize-variables-to-null">DON’T explicitly initialize variables to <code class="highlighter-rouge">null</code>.</a></li>
      <li><a href="#avoid-storing-what-you-can-calculate" id="markdown-toc-avoid-storing-what-you-can-calculate">AVOID storing what you can calculate.</a></li>
    </ul>
  </li>
  <li>
<a href="#members" id="markdown-toc-members">Members</a>    <ul>
      <li><a href="#dont-wrap-a-field-in-a-getter-and-setter-unnecessarily" id="markdown-toc-dont-wrap-a-field-in-a-getter-and-setter-unnecessarily">DON’T wrap a field in a getter and setter unnecessarily.</a></li>
      <li><a href="#prefer-using-a-final-field-to-make-a-read-only-property" id="markdown-toc-prefer-using-a-final-field-to-make-a-read-only-property">PREFER using a <code class="highlighter-rouge">final</code> field to make a read-only property.</a></li>
      <li><a href="#consider-using--for-simple-members" id="markdown-toc-consider-using--for-simple-members">CONSIDER using <code class="highlighter-rouge">=&gt;</code> for simple members.</a></li>
      <li><a href="#dont-use-this-when-not-needed-to-avoid-shadowing" id="markdown-toc-dont-use-this-when-not-needed-to-avoid-shadowing">DON’T use <code class="highlighter-rouge">this.</code> when not needed to avoid shadowing.</a></li>
      <li><a href="#do-initialize-fields-at-their-declaration-when-possible" id="markdown-toc-do-initialize-fields-at-their-declaration-when-possible">DO initialize fields at their declaration when possible.</a></li>
    </ul>
  </li>
  <li>
<a href="#constructors" id="markdown-toc-constructors">Constructors</a>    <ul>
      <li><a href="#do-use-initializing-formals-when-possible" id="markdown-toc-do-use-initializing-formals-when-possible">DO use initializing formals when possible.</a></li>
      <li><a href="#dont-type-annotate-initializing-formals" id="markdown-toc-dont-type-annotate-initializing-formals">DON’T type annotate initializing formals.</a></li>
      <li><a href="#do-use--instead-of--for-empty-constructor-bodies" id="markdown-toc-do-use--instead-of--for-empty-constructor-bodies">DO use <code class="highlighter-rouge">;</code> instead of <code class="highlighter-rouge">{}</code> for empty constructor bodies.</a></li>
      <li><a href="#dont-use-new" id="markdown-toc-dont-use-new">DON’T use <code class="highlighter-rouge">new</code>.</a></li>
      <li><a href="#dont-use-const-redundantly" id="markdown-toc-dont-use-const-redundantly">DON’T use <code class="highlighter-rouge">const</code> redundantly.</a></li>
    </ul>
  </li>
  <li>
<a href="#error-handling" id="markdown-toc-error-handling">Error handling</a>    <ul>
      <li><a href="#avoid-catches-without-on-clauses" id="markdown-toc-avoid-catches-without-on-clauses">AVOID catches without <code class="highlighter-rouge">on</code> clauses.</a></li>
      <li><a href="#dont-discard-errors-from-catches-without-on-clauses" id="markdown-toc-dont-discard-errors-from-catches-without-on-clauses">DON’T discard errors from catches without <code class="highlighter-rouge">on</code> clauses.</a></li>
      <li><a href="#do-throw-objects-that-implement-error-only-for-programmatic-errors" id="markdown-toc-do-throw-objects-that-implement-error-only-for-programmatic-errors">DO throw objects that implement <code class="highlighter-rouge">Error</code> only for programmatic errors.</a></li>
      <li><a href="#dont-explicitly-catch-error-or-types-that-implement-it" id="markdown-toc-dont-explicitly-catch-error-or-types-that-implement-it">DON’T explicitly catch <code class="highlighter-rouge">Error</code> or types that implement it.</a></li>
      <li><a href="#do-use-rethrow-to-rethrow-a-caught-exception" id="markdown-toc-do-use-rethrow-to-rethrow-a-caught-exception">DO use <code class="highlighter-rouge">rethrow</code> to rethrow a caught exception.</a></li>
    </ul>
  </li>
  <li>
<a href="#asynchrony" id="markdown-toc-asynchrony">Asynchrony</a>    <ul>
      <li><a href="#prefer-asyncawait-over-using-raw-futures" id="markdown-toc-prefer-asyncawait-over-using-raw-futures">PREFER async/await over using raw futures.</a></li>
      <li><a href="#dont-use-async-when-it-has-no-useful-effect" id="markdown-toc-dont-use-async-when-it-has-no-useful-effect">DON’T use <code class="highlighter-rouge">async</code> when it has no useful effect.</a></li>
      <li><a href="#consider-using-higher-order-methods-to-transform-a-stream" id="markdown-toc-consider-using-higher-order-methods-to-transform-a-stream">CONSIDER using higher-order methods to transform a stream.</a></li>
      <li><a href="#avoid-using-completer-directly" id="markdown-toc-avoid-using-completer-directly">AVOID using Completer directly.</a></li>
      <li><a href="#do-test-for-futuret-when-disambiguating-a-futureort-whose-type-argument-could-be-object" id="markdown-toc-do-test-for-futuret-when-disambiguating-a-futureort-whose-type-argument-could-be-object">DO test for <code class="highlighter-rouge">Future&lt;T&gt;</code> when disambiguating a <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> whose type argument could be <code class="highlighter-rouge">Object</code>.</a></li>
    </ul>
  </li>
</ul>

<h2 id="库">
<a id="库" class="anchor" href="#%E5%BA%93" aria-hidden="true"><span class="octicon octicon-link"></span></a>库</h2>

<p>这些准则可以帮助你在多个文件编写程序的情况下保证一致性和可维护性。
为了让准则简洁，这里使用“import”来同事代表 <code class="highlighter-rouge">import</code> 和 <code class="highlighter-rouge">export</code> 。
准则同时适用于这两者。</p>

<h3 id="要-在-part-of-中使用字符串">
<a id="要-在-part-of-中使用字符串" class="anchor" href="#%E8%A6%81-%E5%9C%A8-part-of-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 在 <code class="highlighter-rouge">part of</code> 中使用字符串。</h3>

<p>很多 Dart 开发者会避免直接使用 <code class="highlighter-rouge">part</code> 。他们发现当库仅有一个文件的时候很容易读懂代码。
如果你确实要使用 <code class="highlighter-rouge">part</code> 将库的一部分拆分为另一个文件，则 Dart 要求另一个文件指示它所属库的路径。 
由于遗留原因， Dart 允许 <code class="highlighter-rouge">part of</code> 指令使用它所属的库的<em>名称</em>。
这使得工具很难直接查找到这个文件对应主库文件，使得库和文件之间的关系模糊不清。</p>

<p>推荐的现代语法是使用 URI 字符串直接指向库文件。
首选的现代语法是使用直接指向库文件的URI字符串，URI 的使用和其他指令中一样。
如果你有一些库，<code class="highlighter-rouge">my_library.dart</code>，其中包含：</p>

<?code-excerpt "misc/lib/effective_dart/my_library.dart"?>
<pre class="prettyprint lang-dart">library my_library;

part "some/other/file.dart";</pre>

<p>从库中拆分的文件应该如下所示：</p>

<?code-excerpt "misc/lib/effective_dart/some/other/file.dart"?>
<pre class="prettyprint lang-dart good-style">part of "../../my_library.dart";</pre>

<p>而不是：</p>

<?code-excerpt "misc/lib/effective_dart/some/other/file_2.dart"?>
<pre class="prettyprint lang-dart bad-style">part of my_library;</pre>

<h3 id="不要-导入-package-中-src-目录下的库">
<a id="不要-导入-package-中-src-目录下的库" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E5%AF%BC%E5%85%A5-package-%E4%B8%AD-src-%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%BA%93" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 导入 package 中 <code class="highlighter-rouge">src</code> 目录下的库。</h3>

<p><code class="highlighter-rouge">lib</code> 下的 <code class="highlighter-rouge">src</code> 目录<a href="https://www.dartlang.org/tools/pub/package-layout">被指定</a>为 package 自己实现的私有库。
基于包维护者对版本的考虑，package 使用了这种约定。
在不破坏 package 的情况下，维护者可以自由地对 <code class="highlighter-rouge">src</code> 目录下的代码进行修改。</p>

<p>这意味着，你如果导入了其中的私有库，
按理论来讲，一个不破坏 package 的次版本就会影响到你的代码。</p>

<h3 id="建议-使用相对路径在导入你自己-package-中的-lib-目录">
<a id="建议-使用相对路径在导入你自己-package-中的-lib-目录" class="anchor" href="#%E5%BB%BA%E8%AE%AE-%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%9C%A8%E5%AF%BC%E5%85%A5%E4%BD%A0%E8%87%AA%E5%B7%B1-package-%E4%B8%AD%E7%9A%84-lib-%E7%9B%AE%E5%BD%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>建议</strong> 使用相对路径在导入你自己 package 中的 <code class="highlighter-rouge">lib</code> 目录。</h3>

<p>在同一个 package 下其中一个库引用另一个 <code class="highlighter-rouge">lib</code> 目录下的库时，
应该使用相对的 URI 或者直接使用 <code class="highlighter-rouge">package:</code>。</p>

<p>比如，下面是你的 package 目录结构：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_package
└─ lib
   ├─ src
   │  └─ utils.dart
   └─ api.dart
</code></pre></div></div>

<p>如果 <code class="highlighter-rouge">api.dart</code> 想导入 <code class="highlighter-rouge">utils.dart</code> ，应该这样使用：</p>

<pre class="prettyprint lang-dart good-style">import 'src/utils.dart';</pre>

<p>而不是:</p>

<pre class="prettyprint lang-dart bad-style">import 'package:my_package/src/utils.dart';</pre>

<p>喜欢一种方式没有什么深奥的原因——这里仅仅是因为更精简，或者是能够保持一致。</p>

<p>“让 package 的 <code class="highlighter-rouge">lib</code> 目录”独立分离非常重要。
<code class="highlighter-rouge">lib</code> 中的库可以导入 <code class="highlighter-rouge">lib</code>（或其子目录）中的其他库。
<code class="highlighter-rouge">lib</code> 之外的库可以使用相对导入的方式来访问<code class="highlighter-rouge">lib</code>之外的其他库。
例如，<code class="highlighter-rouge">test</code> 下可能有一个测试实用程序库被其它在 <code class="highlighter-rouge">test</code> 下的库导入。</p>

<p>但不能跨越导入。一个在 <code class="highlighter-rouge">lib</code> 外部的库应该永远不会引用一个在 <code class="highlighter-rouge">lib</code> 内部的库，反之亦然。
这样做，会破坏 Dart 正确判断两个库的 URL 是否引用了同一个库的能力。
遵循以下两条规则：</p>

<ul>
  <li>导入路径不应包含 <code class="highlighter-rouge">/lib/</code> 。</li>
  <li>
<code class="highlighter-rouge">lib</code> 下的库永远不应该使用 <code class="highlighter-rouge">../</code> 来跨越 <code class="highlighter-rouge">lib</code> 目录。</li>
</ul>

<h2 id="字符串">
<a id="字符串" class="anchor" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串</h2>

<p>下面是一些需要记住的，关于在 Dart 中使用字符串的最佳实践。</p>

<h3 id="要-使用临近字符字的方式连接字面量字符串">
<a id="要-使用临近字符字的方式连接字面量字符串" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%B4%E8%BF%91%E5%AD%97%E7%AC%A6%E5%AD%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用临近字符字的方式连接字面量字符串。</h3>

<p>如果你有两个字面量字符串（不是变量，是放在引号中的字符串），你不需要使用 <code class="highlighter-rouge">+</code> 来连接它们。
应该想 C 和 C++ 一样，只需要将它们挨着在一起就可以了。
这种方式非常适合不能放到一行的长字符串的创建。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (adjacent-strings-literals)"?>
<pre class="prettyprint lang-dart good-style">raiseAlarm(
    'ERROR: Parts of the spaceship are on fire. Other '
    'parts are overrun by martians. Unclear which are which.');</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (adjacent-strings-literals)"?>
<pre class="prettyprint lang-dart bad-style">raiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' +
    'parts are overrun by martians. Unclear which are which.');</pre>

<h3 id="推荐-使用插值的形式来组合字符串和值">
<a id="推荐-使用插值的形式来组合字符串和值" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E7%BB%84%E5%90%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用插值的形式来组合字符串和值。</h3>

<p>如果你之前使用过其他语言，你一定习惯使用大量 <code class="highlighter-rouge">+</code> 将字面量字符串以及字符串变量链接构建字符串。
这种方式在 Dart 中同样有效，但是通常情况下使用插值会更清晰简短。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (string-interpolation)"?>
<pre class="prettyprint lang-dart good-style">'Hello, $name! You are ${year - birth} years old.';</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (string-interpolation)"?>
<pre class="prettyprint lang-dart bad-style">'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...';</pre>

<h3 id="避免-在字符串插值中使用不必要的大括号">
<a id="避免-在字符串插值中使用不必要的大括号" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在字符串插值中使用不必要的大括号。</h3>

<p>如果要插入是一个简单的标识符，并且后面没有紧跟随在其他字母文本，则应省略 <code class="highlighter-rouge">{}</code> 。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (string-interpolation-avoid-curly)"?>
<pre class="prettyprint lang-dart good-style">'Hi, $name!'
"Wear your wildest $decade's outfit."
'Wear your wildest ${decade}s outfit.'</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (string-interpolation-avoid-curly)"?>
<pre class="prettyprint lang-dart bad-style">'Hi, ${name}!'
"Wear your wildest ${decade}'s outfit."</pre>

<h2 id="集合">
<a id="集合" class="anchor" href="#%E9%9B%86%E5%90%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>集合</h2>

<p>Dart 集合中原生支持了四种类型：list， map， queue， 和 set。
下面是应用于集合的最佳实践。</p>

<h3 id="要-尽可能的使用集合字面量">
<a id="要-尽可能的使用集合字面量" class="anchor" href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 尽可能的使用集合字面量。</h3>

<p>有两种方式来构造一个空的可变 list ： <code class="highlighter-rouge">[]</code> 和 <code class="highlighter-rouge">List()</code> 。
同样，有三总方式来构造一个空的链表哈希 map：<code class="highlighter-rouge">{}</code>，
<code class="highlighter-rouge">Map()</code>， 和 <code class="highlighter-rouge">LinkedHashMap()</code> 。</p>

<p>如果想创建一个固定不变的 list 或者其他自定义集合类型，这种情况下你需要使用构造函数。
否则，使用字面量语法更加优雅。
核心库中暴露这些构造函数易于扩展，但是通常在 Dart 代码中并不使用构造函数。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (collection-literals)"?>
<pre class="prettyprint lang-dart good-style">var points = [];
var addresses = {};</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (collection-literals)"?>
<pre class="prettyprint lang-dart bad-style">var points = List();
var addresses = Map();</pre>

<p>如果需要的话，你甚至可以为它们提供一个类型参数。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (generic-collection-literals)"?>
<pre class="prettyprint lang-dart good-style">var points = &lt;Point&gt;[];
var addresses = &lt;String, Address&gt;{};</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (generic-collection-literals)"?>
<pre class="prettyprint lang-dart bad-style">var points = List&lt;Point&gt;();
var addresses = Map&lt;String, Address&gt;();</pre>

<p>注意，对于集合类的 <em>命名</em> 构造函数则不适用上面的规则。
<code class="highlighter-rouge">List.from()</code>、 <code class="highlighter-rouge">Map.fromIterable()</code> 都有其使用场景。 
如果需要一个固定长度的结合，使用 <code class="highlighter-rouge">List()</code> 来创建一个固定长度的 list 也是合理的。</p>

<h3 id="不要-使用-length-来判断一个集合是否为空">
<a id="不要-使用-length-来判断一个集合是否为空" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-length-%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用 <code class="highlighter-rouge">.length</code> 来判断一个集合是否为空。</h3>

<p><a href="https://api.dartlang.org/dev/dart-core/Iterable-class.html">Iterable</a> 合约并不要求集合知道其长度，也没要求在遍历的时候其长度不能改变。
通过调用 <code class="highlighter-rouge">.length</code>  来判断集合是否包含内容是非常低效的。</p>

<p>相反，Dart 提供了更加高效率和易用的 getter 函数：<code class="highlighter-rouge">.isEmpty</code> 和<code class="highlighter-rouge">.isNotEmpty</code>。
使用这些函数并不需要对结果再次取非。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (dont-use-length)"?>
<pre class="prettyprint lang-dart good-style">if (lunchBox.isEmpty) return 'so hungry...';
if (words.isNotEmpty) return words.join(' ');</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (dont-use-length)"?>
<pre class="prettyprint lang-dart bad-style">if (lunchBox.length == 0) return 'so hungry...';
if (!words.isEmpty) return words.join(' ');</pre>

<h3 id="考虑-使用高阶higher-order函数来转换集合数据">
<a id="考虑-使用高阶higher-order函数来转换集合数据" class="anchor" href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6higher-order%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BD%AC%E6%8D%A2%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 使用高阶（higher-order）函数来转换集合数据。</h3>

<p>如果你有一个集合并且想要修改里面的内容转换为另外一个集合，
使用 <code class="highlighter-rouge">.map()</code>、 <code class="highlighter-rouge">.where()</code> 以及 <code class="highlighter-rouge">Iterable</code> 提供的其他函数会让代码更加简洁。</p>

<p>使用这些函数替代 <code class="highlighter-rouge">for</code> 循环会让代码更加可以表述你的意图，
生成一个新的集合系列并不具有副作用。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (use-higher-order-func)"?>
<pre class="prettyprint lang-dart good-style">var aquaticNames = animals
    .where((animal) =&gt; animal.isAquatic)
    .map((animal) =&gt; animal.name);</pre>

<p>与此同时，这可以非常长，
如果你串联或者嵌套调用很多高阶函数，
则使用一些命令式代码可能会更加清晰。</p>

<h3 id="avoid-using-iterableforeach-with-a-function-literal">
<a id="avoid-using-iterableforeach-with-a-function-literal" class="anchor" href="#avoid-using-iterableforeach-with-a-function-literal" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID using <code class="highlighter-rouge">Iterable.forEach()</code> with a function literal.</h3>

<p><code class="highlighter-rouge">forEach()</code> functions are widely used in JavaScript because the built in
<code class="highlighter-rouge">for-in</code> loop doesn’t do what you usually want. In Dart, if you want to iterate
over a sequence, the idiomatic way to do that is using a loop.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (avoid-forEach)"?>
<pre class="prettyprint lang-dart good-style">for (var person in people) {
  ...
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (avoid-forEach)"?>
<pre class="prettyprint lang-dart bad-style">people.forEach((person) {
  ...
});</pre>

<p>The exception is if all you want to do is invoke some already existing function
with each element as the argument. In that case, <code class="highlighter-rouge">forEach()</code> is handy.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (forEach-over-func)"?>
<pre class="prettyprint lang-dart good-style">people.forEach(print);</pre>

<h3 id="dont-use-listfrom-unless-you-intend-to-change-the-type-of-the-result">
<a id="dont-use-listfrom-unless-you-intend-to-change-the-type-of-the-result" class="anchor" href="#dont-use-listfrom-unless-you-intend-to-change-the-type-of-the-result" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use <code class="highlighter-rouge">List.from()</code> unless you intend to change the type of the result.</h3>

<p>Given an Iterable, there are two obvious ways to produce a new List that
contains the same elements:</p>

<?code-excerpt "misc/test/effective_dart_test.dart (list-from-1)"?>
<pre class="prettyprint lang-dart">var copy1 = iterable.toList();
var copy2 = List.from(iterable);</pre>

<p>The obvious difference is that the first one is shorter. The <em>important</em>
difference is that the first one preserves the type argument of the original
object:</p>

<?code-excerpt "misc/test/effective_dart_test.dart (list-from-2)"?>
<pre class="prettyprint lang-dart">// Creates a List&lt;int&gt;:
var iterable = [1, 2, 3];

// Prints "List&lt;int&gt;":
print(iterable.toList().runtimeType);

// Prints "List&lt;dynamic&gt;":
print(List.from(iterable).runtimeType);</pre>

<p>If you <em>want</em> to change the type, then calling <code class="highlighter-rouge">List.from()</code> is useful:</p>

<?code-excerpt "misc/test/effective_dart_test.dart (list-from-3)"?>
<pre class="prettyprint lang-dart">var numbers = [1, 2.3, 4]; // List&lt;num&gt;.
numbers.removeAt(1); // Now it only contains integers.
var ints = List&lt;int&gt;.from(numbers);</pre>

<p>But if your goal is just to copy the iterable and preserve its original type, or
you don’t care about the type, then use <code class="highlighter-rouge">toList()</code>.</p>

<h3 id="do-use-wheretype-to-filter-a-collection-by-type">
<a id="do-use-wheretype-to-filter-a-collection-by-type" class="anchor" href="#do-use-wheretype-to-filter-a-collection-by-type" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use <code class="highlighter-rouge">whereType()</code> to filter a collection by type.</h3>

<aside class="alert alert-warning">
  <p><strong>Before using <code class="highlighter-rouge">whereType()</code>, make sure it’s implemented.</strong>
  We expect <code class="highlighter-rouge">whereType()</code> to be added late in Dart 2 development.
  For details, see
  <a href="https://github.com/dart-lang/sdk/issues/32463#issuecomment-402975456">SDK issue #32463.</a></p>
</aside>

<p>Let’s say you have a list containing a mixture of objects, and you want to get
just the integers out of it. You could use <code class="highlighter-rouge">where()</code> like this:</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (where-type)"?>
<pre class="prettyprint lang-dart bad-style">var objects = [1, "a", 2, "b", 3];
var ints = objects.where((e) =&gt; e is int);</pre>

<p>This is verbose, but, worse, it returns an iterable whose type probably isn’t
what you want. In the example here, it returns an <code class="highlighter-rouge">Iterable&lt;Object&gt;</code> even though
you likely want an <code class="highlighter-rouge">Iterable&lt;int&gt;</code> since that’s the type you’re filtering it to.</p>

<p>Sometimes you see code that “corrects” the above error by adding <code class="highlighter-rouge">cast()</code>:</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (where-type-2)"?>
<pre class="prettyprint lang-dart bad-style">var objects = [1, "a", 2, "b", 3];
var ints = objects.where((e) =&gt; e is int).cast&lt;int&gt;();</pre>

<p>That’s verbose and causes two wrappers to be created, with two layers of
indirection and redundant runtime checking. Fortunately, the core library has
the <a href="https://api.dartlang.org/dev/dart-core/Iterable/whereType.html"><code class="highlighter-rouge">whereType()</code></a> method for this exact use case:</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (where-type)"?>
<pre class="prettyprint lang-dart good-style">var objects = [1, "a", 2, "b", 3];
var ints = objects.whereType&lt;int&gt;();</pre>

<p>Using <code class="highlighter-rouge">whereType()</code> is concise, produces an <a href="https://api.dartlang.org/dev/dart-core/Iterable-class.html">Iterable</a> of the desired type,
and has no unnecessary levels of wrapping.</p>

<h3 id="dont-use-cast-when-a-nearby-operation-will-do">
<a id="dont-use-cast-when-a-nearby-operation-will-do" class="anchor" href="#dont-use-cast-when-a-nearby-operation-will-do" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use <code class="highlighter-rouge">cast()</code> when a nearby operation will do.</h3>

<p>Often when you’re dealing with an iterable or stream, you perform several
transformations on it. At the end, you want to produce an object with a certain
type argument. Instead of tacking on a call to <code class="highlighter-rouge">cast()</code>, see if one of the
existing transformations can change the type.</p>

<p>If you’re already calling <code class="highlighter-rouge">toList()</code>, replace that with a call to
<a href="https://api.dartlang.org/dev/dart-core/List/List.from.html"><code class="highlighter-rouge">List&lt;T&gt;.from()</code></a> where <code class="highlighter-rouge">T</code> is the type of resulting list you want.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-list)"?>
<pre class="prettyprint lang-dart good-style">var stuff = &lt;dynamic&gt;[1, 2];
var ints = List&lt;int&gt;.from(stuff);</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-list)"?>
<pre class="prettyprint lang-dart bad-style">var stuff = &lt;dynamic&gt;[1, 2];
var ints = stuff.toList().cast&lt;int&gt;();</pre>

<p>If you are calling <code class="highlighter-rouge">map()</code>, give it an explicit type argument so that it
produces an iterable of the desired type. Type inference often picks the correct
type for you based on the function you pass to <code class="highlighter-rouge">map()</code>, but sometimes you need
to be explicit.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-map)" replace="/\(n as int\)/n/g"?>
<pre class="prettyprint lang-dart good-style">var stuff = &lt;dynamic&gt;[1, 2];
var reciprocals = stuff.map&lt;double&gt;((n) =&gt; 1 / n);</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-map)" replace="/\(n as int\)/n/g"?>
<pre class="prettyprint lang-dart bad-style">var stuff = &lt;dynamic&gt;[1, 2];
var reciprocals = stuff.map((n) =&gt; 1 / n).cast&lt;double&gt;();</pre>

<h3 id="avoid-using-cast">
<a id="avoid-using-cast" class="anchor" href="#avoid-using-cast" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID using <code class="highlighter-rouge">cast()</code>.</h3>

<p>This is the softer generalization of the previous rule. Sometimes there is no
nearby operation you can use to fix the type of some object. Even then, when
possible avoid using <code class="highlighter-rouge">cast()</code> to “change” a collection’s type.</p>

<p>Prefer any of these options instead:</p>

<ul>
  <li>
    <p><strong>Create it with the right type.</strong> Change the code where the collection is
first created so that it has the right type.</p>
  </li>
  <li>
    <p><strong>Cast the elements on access.</strong> If you immediately iterate over the
collection, cast each element inside the iteration.</p>
  </li>
  <li>
    <p><strong>Eagerly cast using <code class="highlighter-rouge">List.from()</code>.</strong> If you’ll eventually access most of
the elements in the collection, and you don’t need the object to be backed
by the original live object, convert it using <code class="highlighter-rouge">List.from()</code>.</p>

    <p>The <code class="highlighter-rouge">cast()</code> method returns a lazy collection that checks the element type
on <em>every operation</em>. If you perform only a few operations on only a few
elements, that laziness can be good. But in many cases, the overhead of lazy
validation and of wrapping outweighs the benefits.</p>
  </li>
</ul>

<p>Here is an example of <strong>creating it with the right type:</strong></p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-at-create)"?>
<pre class="prettyprint lang-dart good-style">List&lt;int&gt; singletonList(int value) {
  var list = &lt;int&gt;[];
  list.add(value);
  return list;
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-at-create)"?>
<pre class="prettyprint lang-dart bad-style">List&lt;int&gt; singletonList(int value) {
  var list = []; // List&lt;dynamic&gt;.
  list.add(value);
  return list.cast&lt;int&gt;();
}</pre>

<p>Here is <strong>casting each element on access:</strong></p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-iterate)" replace="/\(n as int\)/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">void printEvens(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  for (var n in objects) {
    if (<span class="highlight">(n as int)</span>.isEven) print(n);
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-iterate)"?>
<pre class="prettyprint lang-dart bad-style">void printEvens(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  for (var n in objects.cast&lt;int&gt;()) {
    if (n.isEven) print(n);
  }
}</pre>

<p>Here is <strong>casting eagerly using <code class="highlighter-rouge">List.from()</code>:</strong></p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-from)"?>
<pre class="prettyprint lang-dart good-style">int median(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  var ints = List&lt;int&gt;.from(objects);
  ints.sort();
  return ints[ints.length ~/ 2];
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-from)"?>
<pre class="prettyprint lang-dart bad-style">int median(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  var ints = objects.cast&lt;int&gt;();
  ints.sort();
  return ints[ints.length ~/ 2];
}</pre>

<p>These alternatives don’t always work, of course, and sometimes <code class="highlighter-rouge">cast()</code> is the
right answer. But consider that method a little risky and undesirable—it
can be slow and may fail at runtime if you aren’t careful.</p>

<h2 id="functions">
<a id="functions" class="anchor" href="#functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions</h2>

<p>In Dart, even functions are objects. Here are some best practices
involving functions.</p>

<h3 id="do-use-a-function-declaration-to-bind-a-function-to-a-name">
<a id="do-use-a-function-declaration-to-bind-a-function-to-a-name" class="anchor" href="#do-use-a-function-declaration-to-bind-a-function-to-a-name" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use a function declaration to bind a function to a name.</h3>

<p>Modern languages have realized how useful local nested functions and closures
are. It’s common to have a function defined inside another one. In many cases,
this function is used as a callback immediately and doesn’t need a name. A
function expression is great for that.</p>

<p>But, if you do need to give it a name, use a function declaration statement
instead of binding a lambda to a variable.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (func-decl)"?>
<pre class="prettyprint lang-dart good-style">void main() {
  localFunction() {
    ...
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (func-decl)"?>
<pre class="prettyprint lang-dart bad-style">void main() {
  var localFunction = () {
    ...
  };
}</pre>

<h3 id="dont-create-a-lambda-when-a-tear-off-will-do">
<a id="dont-create-a-lambda-when-a-tear-off-will-do" class="anchor" href="#dont-create-a-lambda-when-a-tear-off-will-do" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T create a lambda when a tear-off will do.</h3>

<p>If you refer to a method on an object but omit the parentheses, Dart gives you
a “tear-off”—a closure that takes the same parameters as the method and
invokes it when you call it.</p>

<p>If you have a function that invokes a method with the same arguments as are
passed to it, you don’t need to manually wrap the call in a lambda.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (use-tear-off)"?>
<pre class="prettyprint lang-dart good-style">names.forEach(print);</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (use-tear-off)"?>
<pre class="prettyprint lang-dart bad-style">names.forEach((name) {
  print(name);
});</pre>

<h2 id="parameters">
<a id="parameters" class="anchor" href="#parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h2>

<h3 id="do-use--to-separate-a-named-parameter-from-its-default-value">
<a id="do-use--to-separate-a-named-parameter-from-its-default-value" class="anchor" href="#do-use--to-separate-a-named-parameter-from-its-default-value" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use <code class="highlighter-rouge">=</code> to separate a named parameter from its default value.</h3>

<p>For legacy reasons, Dart allows both <code class="highlighter-rouge">:</code> and <code class="highlighter-rouge">=</code> as the default value separator
for named parameters. For consistency with optional positional parameters, use
<code class="highlighter-rouge">=</code>.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (default-separator)"?>
<pre class="prettyprint lang-dart good-style">void insert(Object item, {int at = 0}) { ... }</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (default-separator)"?>
<pre class="prettyprint lang-dart bad-style">void insert(Object item, {int at: 0}) { ... }</pre>

<h3 id="dont-use-an-explicit-default-value-of-null">
<a id="dont-use-an-explicit-default-value-of-null" class="anchor" href="#dont-use-an-explicit-default-value-of-null" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use an explicit default value of <code class="highlighter-rouge">null</code>.</h3>

<p>If you make a parameter optional but don’t give it a default value, the language
implicitly uses <code class="highlighter-rouge">null</code> as the default, so there’s no need to write it.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (default-value-null)"?>
<pre class="prettyprint lang-dart good-style">void error([String message]) {
  stderr.write(message ?? '\n');
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (default-value-null)"?>
<pre class="prettyprint lang-dart bad-style">void error([String message = null]) {
  stderr.write(message ?? '\n');
}</pre>

<h2 id="variables">
<a id="variables" class="anchor" href="#variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Variables</h2>

<p>The following best practices describe how to best use variables in Dart.</p>

<h3 id="dont-explicitly-initialize-variables-to-null">
<a id="dont-explicitly-initialize-variables-to-null" class="anchor" href="#dont-explicitly-initialize-variables-to-null" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T explicitly initialize variables to <code class="highlighter-rouge">null</code>.</h3>

<p>In Dart, a variable or field that is not explicitly initialized automatically
gets initialized to <code class="highlighter-rouge">null</code>. This is reliably specified by the language. There’s
no concept of “uninitialized memory” in Dart. Adding <code class="highlighter-rouge">= null</code> is redundant and
unneeded.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (no-null-init)"?>
<pre class="prettyprint lang-dart good-style">int _nextId;

class LazyId {
  int _id;

  int get id {
    if (_nextId == null) _nextId = 0;
    if (_id == null) _id = _nextId++;

    return _id;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (no-null-init)"?>
<pre class="prettyprint lang-dart bad-style">int _nextId = null;

class LazyId {
  int _id = null;

  int get id {
    if (_nextId == null) _nextId = 0;
    if (_id == null) _id = _nextId++;

    return _id;
  }
}</pre>

<h3 id="avoid-storing-what-you-can-calculate">
<a id="avoid-storing-what-you-can-calculate" class="anchor" href="#avoid-storing-what-you-can-calculate" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID storing what you can calculate.</h3>

<p>When designing a class, you often want to expose multiple views into the same
underlying state. Often you see code that calculates all of those views in the
constructor and then stores them:</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cacl-vs-store1)"?>
<pre class="prettyprint lang-dart bad-style">class Circle {
  num radius;
  num area;
  num circumference;

  Circle(num radius)
      : radius = radius,
        area = pi * radius * radius,
        circumference = pi * 2.0 * radius;
}</pre>

<p>This code has two things wrong with it. First, it’s likely wasting memory. The
area and circumference, strictly speaking, are <em>caches</em>. They are stored
calculations that we could recalculate from other data we already have. They are
trading increased memory for reduced CPU usage. Do we know we have a performance
problem that merits that trade-off?</p>

<p>Worse, the code is <em>wrong</em>. The problem with caches is <em>invalidation</em>—how
do you know when the cache is out of date and needs to be recalculated? Here, we
never do, even though <code class="highlighter-rouge">radius</code> is mutable. You can assign a different value and
the <code class="highlighter-rouge">area</code> and <code class="highlighter-rouge">circumference</code> will retain their previous, now incorrect values.</p>

<p>To correctly handle cache invalidation, we need to do this:</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cacl-vs-store2)"?>
<pre class="prettyprint lang-dart bad-style">class Circle {
  num _radius;
  num get radius =&gt; _radius;
  set radius(num value) {
    _radius = value;
    _recalculate();
  }

  num _area;
  num get area =&gt; _area;

  num _circumference;
  num get circumference =&gt; _circumference;

  Circle(this._radius) {
    _recalculate();
  }

  void _recalculate() {
    _area = pi * _radius * _radius;
    _circumference = pi * 2.0 * _radius;
  }
}</pre>

<p>That’s an awful lot of code to write, maintain, debug, and read. Instead, your
first implementation should be:</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cacl-vs-store)"?>
<pre class="prettyprint lang-dart good-style">class Circle {
  num radius;

  Circle(this.radius);

  num get area =&gt; pi * radius * radius;
  num get circumference =&gt; pi * 2.0 * radius;
}</pre>

<p>This code is shorter, uses less memory, and is less error-prone. It stores the
minimal amount of data needed to represent the circle. There are no fields to
get out of sync because there is only a single source of truth.</p>

<p>In some cases, you may need to cache the result of a slow calculation, but only
do that after you know you have a performance problem, do it carefully, and
leave a comment explaining the optimization.</p>

<h2 id="members">
<a id="members" class="anchor" href="#members" aria-hidden="true"><span class="octicon octicon-link"></span></a>Members</h2>

<p>In Dart, objects have members which can be functions (methods) or data (instance
variables). The following best practices apply to an object’s members.</p>

<h3 id="dont-wrap-a-field-in-a-getter-and-setter-unnecessarily">
<a id="dont-wrap-a-field-in-a-getter-and-setter-unnecessarily" class="anchor" href="#dont-wrap-a-field-in-a-getter-and-setter-unnecessarily" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T wrap a field in a getter and setter unnecessarily.</h3>

<p>In Java and C#, it’s common to hide all fields behind getters and setters (or
properties in C#), even if the implementation just forwards to the field. That
way, if you ever need to do more work in those members, you can without needing
to touch the callsites. This is because calling a getter method is different
than accessing a field in Java, and accessing a property isn’t binary-compatible
with accessing a raw field in C#.</p>

<p>Dart doesn’t have this limitation. Fields and getters/setters are completely
indistinguishable. You can expose a field in a class and later wrap it in a
getter and setter without having to touch any code that uses that field.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (dont-wrap-field)"?>
<pre class="prettyprint lang-dart good-style">class Box {
  var contents;
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (dont-wrap-field)"?>
<pre class="prettyprint lang-dart bad-style">class Box {
  var _contents;
  get contents =&gt; _contents;
  set contents(value) {
    _contents = value;
  }
}</pre>

<h3 id="prefer-using-a-final-field-to-make-a-read-only-property">
<a id="prefer-using-a-final-field-to-make-a-read-only-property" class="anchor" href="#prefer-using-a-final-field-to-make-a-read-only-property" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER using a <code class="highlighter-rouge">final</code> field to make a read-only property.</h3>

<p>If you have a field that outside code should be able to see but not assign to, a
simple solution that works in many cases is to simply mark it <code class="highlighter-rouge">final</code>.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (final)"?>
<pre class="prettyprint lang-dart good-style">class Box {
  final contents = [];
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (final)"?>
<pre class="prettyprint lang-dart bad-style">class Box {
  var _contents;
  get contents =&gt; _contents;
}</pre>

<p>Of course, if you need to internally assign to the field outside of the
constructor, you may need to do the “private field, public getter” pattern, but
don’t reach for that until you need to.</p>

<h3 id="consider-using--for-simple-members">
<a id="consider-using--for-simple-members" class="anchor" href="#consider-using--for-simple-members" aria-hidden="true"><span class="octicon octicon-link"></span></a>CONSIDER using <code class="highlighter-rouge">=&gt;</code> for simple members.</h3>

<p>In addition to using <code class="highlighter-rouge">=&gt;</code> for function expressions, Dart also lets you define
members with it. That style is a good fit for simple members that just calculate
and return a value.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (use-arrow)"?>
<pre class="prettyprint lang-dart good-style">double get area =&gt; (right - left) * (bottom - top);

bool isReady(num time) =&gt; minTime == null || minTime &lt;= time;

String capitalize(String name) =&gt;
    '${name[0].toUpperCase()}${name.substring(1)}';</pre>

<p>People <em>writing</em> code seem to love <code class="highlighter-rouge">=&gt;</code>, but it’s very easy to abuse it and end
up with code that’s hard to <em>read</em>. If your declaration is more than a couple of
lines or contains deeply nested expressions—cascades and conditional
operators are common offenders—do yourself and everyone who has to read
your code a favor and use a block body and some statements.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (arrow-long)"?>
<pre class="prettyprint lang-dart good-style">Treasure openChest(Chest chest, Point where) {
  if (_opened.containsKey(chest)) return null;

  var treasure = Treasure(where);
  treasure.addAll(chest.contents);
  _opened[chest] = treasure;
  return treasure;
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (arrow-long)"?>
<pre class="prettyprint lang-dart bad-style">Treasure openChest(Chest chest, Point where) =&gt;
    _opened.containsKey(chest) ? null : _opened[chest] = Treasure(where)
      ..addAll(chest.contents);</pre>

<p>You can also use <code class="highlighter-rouge">=&gt;</code> on members that don’t return a value. This is idiomatic
when a setter is small and has a corresponding getter that uses <code class="highlighter-rouge">=&gt;</code>.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (arrow-setter)"?>
<pre class="prettyprint lang-dart good-style">num get x =&gt; center.x;
set x(num value) =&gt; center = Point(value, center.y);</pre>

<p>It’s rarely a good idea to use <code class="highlighter-rouge">=&gt;</code> for non-setter void members. The <code class="highlighter-rouge">=&gt;</code>
implies “returns a value”, so readers may misinterpret what the void member does
if you use it.</p>

<h3 id="dont-use-this-when-not-needed-to-avoid-shadowing">
<a id="dont-use-this-when-not-needed-to-avoid-shadowing" class="anchor" href="#dont-use-this-when-not-needed-to-avoid-shadowing" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use <code class="highlighter-rouge">this.</code> when not needed to avoid shadowing.</h3>

<p>JavaScript requires an explicit <code class="highlighter-rouge">this.</code> to refer to members on the object whose
method is currently being executed, but Dart—like C++, Java, and
C#—doesn’t have that limitation.</p>

<p>The only time you need to use <code class="highlighter-rouge">this.</code> is when a local variable with the same
name shadows the member you want to access.</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (this-dot)"?>
<pre class="prettyprint lang-dart bad-style">class Box {
  var value;

  void clear() {
    this.update(null);
  }

  void update(value) {
    this.value = value;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (this-dot)"?>
<pre class="prettyprint lang-dart good-style">class Box {
  var value;

  void clear() {
    update(null);
  }

  void update(value) {
    this.value = value;
  }
}</pre>

<p>Note that constructor parameters never shadow fields in constructor
initialization lists:</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (param-dont-shadow-field-ctr-init)"?>
<pre class="prettyprint lang-dart good-style">class Box extends BaseBox {
  var value;

  Box(value)
      : value = value,
        super(value);
}</pre>

<p>This looks surprising, but works like you want. Fortunately, code like this is
relatively rare thanks to initializing formals.</p>

<h3 id="do-initialize-fields-at-their-declaration-when-possible">
<a id="do-initialize-fields-at-their-declaration-when-possible" class="anchor" href="#do-initialize-fields-at-their-declaration-when-possible" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO initialize fields at their declaration when possible.</h3>

<p>If a field doesn’t depend on any constructor parameters, it can and should be
initialized at its declaration. It takes less code and makes sure you won’t
forget to initialize it if the class has multiple constructors.</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (field-init-at-decl)"?>
<pre class="prettyprint lang-dart bad-style">class Folder {
  final String name;
  final List&lt;Document&gt; contents;

  Folder(this.name) : contents = [];
  Folder.temp() : name = 'temporary'; // Oops! Forgot contents.
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (field-init-at-decl)"?>
<pre class="prettyprint lang-dart good-style">class Folder {
  final String name;
  final List&lt;Document&gt; contents = [];

  Folder(this.name);
  Folder.temp() : name = 'temporary';
}</pre>

<p>Of course, if a field depends on constructor parameters, or is initialized
differently by different constructors, then this guideline does not apply.</p>

<h2 id="constructors">
<a id="constructors" class="anchor" href="#constructors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructors</h2>

<p>The following best practices apply to declaring constructors for a class.</p>

<h3 id="do-use-initializing-formals-when-possible">
<a id="do-use-initializing-formals-when-possible" class="anchor" href="#do-use-initializing-formals-when-possible" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use initializing formals when possible.</h3>

<p>Many fields are initialized directly from a constructor parameter, like:</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (field-init-as-param)"?>
<pre class="prettyprint lang-dart bad-style">class Point {
  num x, y;
  Point(num x, num y) {
    this.x = x;
    this.y = y;
  }
}</pre>

<p>We’ve got to type <code class="highlighter-rouge">x</code> <em>four</em> times here define a field. Lame. We can do better:</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (field-init-as-param)"?>
<pre class="prettyprint lang-dart good-style">class Point {
  num x, y;
  Point(this.x, this.y);
}</pre>

<p>This <code class="highlighter-rouge">this.</code> syntax before a constructor parameter is called an “initializing
formal”. You can’t always take advantage of it. In particular, using it means
the parameter is not visible in the initialization list. But, when you can, you
should.</p>

<h3 id="dont-type-annotate-initializing-formals">
<a id="dont-type-annotate-initializing-formals" class="anchor" href="#dont-type-annotate-initializing-formals" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T type annotate initializing formals.</h3>

<p>If a constructor parameter is using <code class="highlighter-rouge">this.</code> to initialize a field, then the type
of the parameter is understood to be the same type as the field.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (dont-type-init-formals)"?>
<pre class="prettyprint lang-dart good-style">class Point {
  int x, y;
  Point(this.x, this.y);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (dont-type-init-formals)"?>
<pre class="prettyprint lang-dart bad-style">class Point {
  int x, y;
  Point(int this.x, int this.y);
}</pre>

<h3 id="do-use--instead-of--for-empty-constructor-bodies">
<a id="do-use--instead-of--for-empty-constructor-bodies" class="anchor" href="#do-use--instead-of--for-empty-constructor-bodies" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use <code class="highlighter-rouge">;</code> instead of <code class="highlighter-rouge">{}</code> for empty constructor bodies.</h3>

<p>In Dart, a constructor with an empty body can be terminated with just a
semicolon. (In fact, it’s required for const constructors.)</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (semicolon-for-empty-body)"?>
<pre class="prettyprint lang-dart good-style">class Point {
  int x, y;
  Point(this.x, this.y);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (semicolon-for-empty-body)"?>
<pre class="prettyprint lang-dart bad-style">class Point {
  int x, y;
  Point(this.x, this.y) {}
}</pre>

<h3 id="dont-use-new">
<a id="dont-use-new" class="anchor" href="#dont-use-new" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use <code class="highlighter-rouge">new</code>.</h3>

<p>Dart 2 makes the <code class="highlighter-rouge">new</code> keyword optional. Even in Dart 1, its meaning was never
clear because factory constructors mean a <code class="highlighter-rouge">new</code> invocation may still not
actually return a new object.</p>

<p>The language still permits <code class="highlighter-rouge">new</code> in order to make migration less painful, but
consider it deprecated and remove it from your code.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (no-new)"?>
<pre class="prettyprint lang-dart good-style">Widget build(BuildContext context) {
  return Row(
    children: [
      RaisedButton(
        child: Text('Increment'),
      ),
      Text('Click!'),
    ],
  );
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (no-new)" replace="/new/[!$&!]/g"?>
<pre class="prettyprint lang-dart bad-style">Widget build(BuildContext context) {
  return <span class="highlight">new</span> Row(
    children: [
      <span class="highlight">new</span> RaisedButton(
        child: <span class="highlight">new</span> Text('Increment'),
      ),
      <span class="highlight">new</span> Text('Click!'),
    ],
  );
}</pre>

<h3 id="dont-use-const-redundantly">
<a id="dont-use-const-redundantly" class="anchor" href="#dont-use-const-redundantly" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use <code class="highlighter-rouge">const</code> redundantly.</h3>

<p>In contexts where an expression <em>must</em> be constant, the <code class="highlighter-rouge">const</code> keyword is
implicit, doesn’t need to be written, and shouldn’t. Those contexts are any
expression inside:</p>

<ul>
  <li>A const collection literal.</li>
  <li>A const constructor call</li>
  <li>A metadata annotation.</li>
  <li>The initializer for a const variable declaration.</li>
  <li>A switch case expression—the part right after <code class="highlighter-rouge">case</code> before the <code class="highlighter-rouge">:</code>, not
the body of the case.</li>
</ul>

<p>(Default values are not included in this list because future versions of Dart
may support non-const default values.)</p>

<p>Basically, any place where it would be an error to write <code class="highlighter-rouge">new</code> instead of
<code class="highlighter-rouge">const</code>, Dart 2 allows you to omit the <code class="highlighter-rouge">const</code>.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (no-const)"?>
<pre class="prettyprint lang-dart good-style">const primaryColors = [
  Color("red", [255, 0, 0]),
  Color("green", [0, 255, 0]),
  Color("blue", [0, 0, 255]),
];</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (no-const)" replace="/ (const)/ [!$1!]/g"?>
<pre class="prettyprint lang-dart bad-style">const primaryColors = <span class="highlight">const</span> [
  <span class="highlight">const</span> Color("red", <span class="highlight">const</span> [255, 0, 0]),
  <span class="highlight">const</span> Color("green", <span class="highlight">const</span> [0, 255, 0]),
  <span class="highlight">const</span> Color("blue", <span class="highlight">const</span> [0, 0, 255]),
];</pre>

<h2 id="error-handling">
<a id="error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error handling</h2>

<p>Dart uses exceptions when an error occurs in your program. The following
best practices apply to catching and throwing exceptions.</p>

<h3 id="avoid-catches-without-on-clauses">
<a id="avoid-catches-without-on-clauses" class="anchor" href="#avoid-catches-without-on-clauses" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID catches without <code class="highlighter-rouge">on</code> clauses.</h3>

<p>A catch clause with no <code class="highlighter-rouge">on</code> qualifier catches <em>anything</em> thrown by the code in
the try block. <a href="https://blog.codinghorror.com/new-programming-jargon/">Pokémon exception handling</a> is very likely not what you
want. Does your code correctly handle <a href="https://api.dartlang.org/dev/dart-core/StackOverflowError-class.html">StackOverflowError</a> or
<a href="https://api.dartlang.org/dev/dart-core/OutOfMemoryError-class.html">OutOfMemoryError</a>? If you incorrectly pass the wrong argument to a method in
that try block do you want to have your debugger point you to the mistake or
would you rather that helpful <a href="https://api.dartlang.org/dev/dart-core/ArgumentError-class.html">ArgumentError</a> get swallowed? Do you want any
<code class="highlighter-rouge">assert()</code> statements inside that code to effectively vanish since you’re
catching the thrown <a href="https://api.dartlang.org/dev/dart-core/AssertionError-class.html">AssertionError</a>s?</p>

<p>The answer is probably “no”, in which case you should filter the types you
catch. In most cases, you should have an <code class="highlighter-rouge">on</code> clause that limits you to the
kinds of runtime failures you are aware of and are correctly handling.</p>

<p>In rare cases, you may wish to catch any runtime error. This is usually in
framework or low-level code that tries to insulate arbitrary application code
from causing problems. Even here, it is usually better to catch <a href="https://api.dartlang.org/dev/dart-core/Exception-class.html">Exception</a>
than to catch all types. Exception is the base class for all <em>runtime</em> errors
and excludes errors that indicate <em>programmatic</em> bugs in the code.</p>

<h3 id="dont-discard-errors-from-catches-without-on-clauses">
<a id="dont-discard-errors-from-catches-without-on-clauses" class="anchor" href="#dont-discard-errors-from-catches-without-on-clauses" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T discard errors from catches without <code class="highlighter-rouge">on</code> clauses.</h3>

<p>If you really do feel you need to catch <em>everything</em> that can be thrown from a
region of code, <em>do something</em> with what you catch. Log it, display it to the
user or rethrow it, but do not silently discard it.</p>

<h3 id="do-throw-objects-that-implement-error-only-for-programmatic-errors">
<a id="do-throw-objects-that-implement-error-only-for-programmatic-errors" class="anchor" href="#do-throw-objects-that-implement-error-only-for-programmatic-errors" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO throw objects that implement <code class="highlighter-rouge">Error</code> only for programmatic errors.</h3>

<p>The <a href="https://api.dartlang.org/dev/Error-class.html">Error</a> class is the base class for <em>programmatic</em> errors. When an object
of that type or one of its subinterfaces like <a href="https://api.dartlang.org/dev/dart-core/ArgumentError-class.html">ArgumentError</a> is thrown, it
means there is a <em>bug</em> in your code. When your API wants to report to a caller
that it is being used incorrectly throwing an Error sends that signal clearly.</p>

<p>Conversely, if the exception is some kind of runtime failure that doesn’t
indicate a bug in the code, then throwing an Error is misleading. Instead, throw
one of the core Exception classes or some other type.</p>

<h3 id="dont-explicitly-catch-error-or-types-that-implement-it">
<a id="dont-explicitly-catch-error-or-types-that-implement-it" class="anchor" href="#dont-explicitly-catch-error-or-types-that-implement-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T explicitly catch <code class="highlighter-rouge">Error</code> or types that implement it.</h3>

<p>This follows from the above. Since an Error indicates a bug in your code, it
should unwind the entire callstack, halt the program, and print a stack trace so
you can locate and fix the bug.</p>

<p>Catching errors of these types breaks that process and masks the bug. Instead of
<em>adding</em> error-handling code to deal with this exception after the fact, go back
and fix the code that is causing it to be thrown in the first place.</p>

<h3 id="do-use-rethrow-to-rethrow-a-caught-exception">
<a id="do-use-rethrow-to-rethrow-a-caught-exception" class="anchor" href="#do-use-rethrow-to-rethrow-a-caught-exception" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use <code class="highlighter-rouge">rethrow</code> to rethrow a caught exception.</h3>

<p>If you decide to rethrow an exception, prefer using the <code class="highlighter-rouge">rethrow</code> statement
instead of throwing the same exception object using <code class="highlighter-rouge">throw</code>.
<code class="highlighter-rouge">rethrow</code> preserves the original stack trace of the exception. <code class="highlighter-rouge">throw</code> on the
other hand resets the stack trace to the last thrown position.</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (rethrow)"?>
<pre class="prettyprint lang-dart bad-style">try {
  somethingRisky();
} catch (e) {
  if (!canHandle(e)) throw e;
  handle(e);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (rethrow)" replace="/rethrow/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">try {
  somethingRisky();
} catch (e) {
  if (!canHandle(e)) <span class="highlight">rethrow</span>;
  handle(e);
}</pre>

<h2 id="asynchrony">
<a id="asynchrony" class="anchor" href="#asynchrony" aria-hidden="true"><span class="octicon octicon-link"></span></a>Asynchrony</h2>

<p>Dart has several language features to support asynchronous programming.
The following best practices apply to asynchronous coding.</p>

<h3 id="prefer-asyncawait-over-using-raw-futures">
<a id="prefer-asyncawait-over-using-raw-futures" class="anchor" href="#prefer-asyncawait-over-using-raw-futures" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER async/await over using raw futures.</h3>

<p>Asynchronous code is notoriously hard to read and debug, even when using a nice
abstraction like futures. The <code class="highlighter-rouge">async</code>/<code class="highlighter-rouge">await</code> syntax improves readability and
lets you use all of the Dart control flow structures within your async code.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (async-await)" replace="/async|await/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">Future&lt;int&gt; countActivePlayers(String teamName) <span class="highlight">async</span> {
  try {
    var team = <span class="highlight">await</span> downloadTeam(teamName);
    if (team == null) return 0;

    var players = <span class="highlight">await</span> team.roster;
    return players.where((player) =&gt; player.isActive).length;
  } catch (e) {
    log.error(e);
    return 0;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (async-await)"?>
<pre class="prettyprint lang-dart bad-style">Future&lt;int&gt; countActivePlayers(String teamName) {
  return downloadTeam(teamName).then((team) {
    if (team == null) return Future.value(0);

    return team.roster.then((players) {
      return players.where((player) =&gt; player.isActive).length;
    });
  }).catchError((e) {
    log.error(e);
    return 0;
  });
}</pre>

<h3 id="dont-use-async-when-it-has-no-useful-effect">
<a id="dont-use-async-when-it-has-no-useful-effect" class="anchor" href="#dont-use-async-when-it-has-no-useful-effect" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use <code class="highlighter-rouge">async</code> when it has no useful effect.</h3>

<p>It’s easy to get in the habit of using <code class="highlighter-rouge">async</code> on any function that does
anything related to asynchrony. But in some cases, it’s extraneous. If you can
omit the <code class="highlighter-rouge">async</code> without changing the behavior of the function, do so.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (unnecessary-async)"?>
<pre class="prettyprint lang-dart good-style">Future afterTwoThings(Future first, Future second) {
  return Future.wait([first, second]);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (unnecessary-async)"?>
<pre class="prettyprint lang-dart bad-style">Future afterTwoThings(Future first, Future second) async {
  return Future.wait([first, second]);
}</pre>

<p>Cases where <code class="highlighter-rouge">async</code> <em>is</em> useful include:</p>

<ul>
  <li>
    <p>You are using <code class="highlighter-rouge">await</code>. (This is the obvious one.)</p>
  </li>
  <li>
    <p>You are returning an error asynchronously. <code class="highlighter-rouge">async</code> and then <code class="highlighter-rouge">throw</code> is shorter
than <code class="highlighter-rouge">return Future.error(...)</code>.</p>
  </li>
  <li>
    <p>You are returning a value and you want it implicitly wrapped in a future.
<code class="highlighter-rouge">async</code> is shorter than <code class="highlighter-rouge">Future.value(...)</code>.</p>
  </li>
</ul>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (async)"?>
<pre class="prettyprint lang-dart good-style">Future usesAwait(Future later) async {
  print(await later);
}

Future asyncError() async {
  throw 'Error!';
}

Future asyncValue() async =&gt; 'value';</pre>

<h3 id="consider-using-higher-order-methods-to-transform-a-stream">
<a id="consider-using-higher-order-methods-to-transform-a-stream" class="anchor" href="#consider-using-higher-order-methods-to-transform-a-stream" aria-hidden="true"><span class="octicon octicon-link"></span></a>CONSIDER using higher-order methods to transform a stream.</h3>

<p>This parallels the above suggestion on iterables. Streams support many of the
same methods and also handle things like transmitting errors, closing, etc.
correctly.</p>

<h3 id="avoid-using-completer-directly">
<a id="avoid-using-completer-directly" class="anchor" href="#avoid-using-completer-directly" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID using Completer directly.</h3>

<p>Many people new to asynchronous programming want to write code that produces a
future. The constructors in Future don’t seem to fit their need so they
eventually find the Completer class and use that.</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (avoid-completer)"?>
<pre class="prettyprint lang-dart bad-style">Future&lt;bool&gt; fileContainsBear(String path) {
  var completer = Completer&lt;bool&gt;();

  File(path).readAsString().then((contents) {
    completer.complete(contents.contains('bear'));
  });

  return completer.future;
}</pre>

<p>Completer is needed for two kinds of low-level code: new asynchronous
primitives, and interfacing with asynchronous code that doesn’t use futures.
Most other code should use async/await or <a href="https://api.dartlang.org/dev/dart-async/Future/then.html"><code class="highlighter-rouge">Future.then()</code></a>, because
they’re clearer and make error handling easier.</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (avoid-completer)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;bool&gt; fileContainsBear(String path) {
  return File(path).readAsString().then((contents) {
    return contents.contains('bear');
  });
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (avoid-completer-alt)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;bool&gt; fileContainsBear(String path) async {
  var contents = await File(path).readAsString();
  return contents.contains('bear');
}</pre>

<h3 id="do-test-for-futuret-when-disambiguating-a-futureort-whose-type-argument-could-be-object">
<a id="do-test-for-futuret-when-disambiguating-a-futureort-whose-type-argument-could-be-object" class="anchor" href="#do-test-for-futuret-when-disambiguating-a-futureort-whose-type-argument-could-be-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO test for <code class="highlighter-rouge">Future&lt;T&gt;</code> when disambiguating a <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> whose type argument could be <code class="highlighter-rouge">Object</code>.</h3>

<p>Before you can do anything useful with a <code class="highlighter-rouge">FutureOr&lt;T&gt;</code>, you typically need to do
an <code class="highlighter-rouge">is</code> check to see if you have a <code class="highlighter-rouge">Future&lt;T&gt;</code> or a bare <code class="highlighter-rouge">T</code>. If the type
argument is some specific type as in <code class="highlighter-rouge">FutureOr&lt;int&gt;</code>, it doesn’t matter which
test you use, <code class="highlighter-rouge">is int</code> or <code class="highlighter-rouge">is Future&lt;int&gt;</code>. Either works because those two types
are disjoint.</p>

<p>However, if the value type is <code class="highlighter-rouge">Object</code> or a type parameter that could possibly
be instantiated with <code class="highlighter-rouge">Object</code>, then the two branches overlap. <code class="highlighter-rouge">Future&lt;Object&gt;</code>
itself implements <code class="highlighter-rouge">Object</code>, so <code class="highlighter-rouge">is Object</code> or <code class="highlighter-rouge">is T</code> where <code class="highlighter-rouge">T</code> is some type
parameter that could be instantiated with <code class="highlighter-rouge">Object</code> returns true even when the
object is a future. Instead, explicitly test for the <code class="highlighter-rouge">Future</code> case:</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (test-future-or)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;T&gt; logValue&lt;T&gt;(FutureOr&lt;T&gt; value) async {
  if (value is Future&lt;T&gt;) {
    var result = await value;
    print(result);
    return result;
  } else {
    print(value);
    return value as T;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (test-future-or)"?>
<pre class="prettyprint lang-dart bad-style">Future&lt;T&gt; logValue&lt;T&gt;(FutureOr&lt;T&gt; value) async {
  if (value is T) {
    print(value);
    return value;
  } else {
    var result = await value;
    print(result);
    return result;
  }
}</pre>

<p>In the bad example, if you pass it a <code class="highlighter-rouge">Future&lt;Object&gt;</code>, it incorrectly treats it
like a bare, synchronous value.</p>


          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/documentation">&lang;&nbsp;&nbsp;文档注释</a>
      
    </li>
    <li class="next">
      
        <a href="/guides/language/effective-dart/design">设计&nbsp;&nbsp;&rang;</a>
      
    </li>
  </ul>
</nav>


        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-3">
        <div class="content">
          <div class="brand">
            <img src="/assets/shared/dart/logo+text/horizontal/mono.svg" alt="Dart logo" class="brand"/>
          </div>
          <h4><a href="/terms">Terms</a> | <a href="https://policies.google.com/privacy">Privacy</a></h4>
          <style>.menu .material-icons { font-size: 14px; }</style><ul class="menu">
            <li>Site&nbsp;<a href="http://creativecommons.org/licenses/by/3.0/" class="no-automatic-external">CC&nbsp;BY&nbsp;3.0</a></li>
            <li>
              <a href="https://github.com/dart-lang/site-www"
                 title="This site's source is on GitHub."
                 class="no-automatic-external"><i class="fab fa-github fa-sm"></i></a>
              &nbsp;
              <a href="https://github.com/dart-lang/site-www/issues"
                 title="File an issue about this site."
                 class="no-automatic-external"><i class="fas fa-bug fa-sm"></i></a>
              &nbsp;
              <a 
                 title="Site built on 2018/08/06 19:16 CST"
                 
                 class="no-automatic-external"><i class="material-icons">build</i></a>
            </li>
          </ul>
        </div>
      </div>
      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>技术</h4>
          <ul>
            <li><a href="https://flutter.io">Dart 移动开发 (Flutter)</a></li>
            <li><a href="https://webdev.dartlang.org">Dart web 开发</a></li>
            <li><a href="/dart-vm">Dart 服务器开发</a></li>
            <li><a href="https://dart-lang.github.io/observatory/">Observatory 工具</a></li>
            <li><a href="/guides/libraries">Dart 库</a></li>
            <li><a href="/guides/language">Dart 编程语言</a></li>
          </ul>
        </div>
      </div>

      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>资源</h4>
          <ul>
            <li><a href="https://api.dartlang.org/dev">API 参考</a></li>
            <li><a href="https://dartpad.dartlang.org/">DartPad</a></li>
            <li><a href="https://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="http://news.dartlang.org/">Dart 新闻</a></li>
            <li><a href="https://github.com/dart-lang/sdk/issues">Dart bugs 和 <br> 新需求</a></li>
          </ul>
        </div>
      </div>

      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>社区</h4>
          <ul>
            <li><a href="/community">支持和邮件列表</a></li>
            <li><a href="/community/who-uses-dart">谁在用Dart</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
            <li>G+ <a href="https://plus.google.com/communities/114566943291919232850">社区</a> &
                <a href="https://plus.google.com/b/109866369054280216564/+dartlang">公告组</a></li>
            <li><a href="https://gitter.im/dart-lang/home">Gitter聊天室</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
