<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="en_US" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Design consistent, usable libraries.">
  <title>Effective Dart: 设计 | Dart</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/touch-icon-iphone-a46c306c4fbfae0b28d63f512b01d7cb2ccf1e4ca9d7f3aab15ba1170beed4a0.png" rel="apple-touch-icon">
  <link href="/assets/touch-icon-ipad-d0181720760b3912858b6d40da1d5586b1e92c7c8656a485ea41005674401e6b.png" rel="apple-touch-icon" sizes="76x76">
  <link href="/assets/touch-icon-iphone-retina-3d9821a631425376ac6203dea3c23c1940ab7b5c506a25406662fab76cee2e0b.png" rel="apple-touch-icon" sizes="120x120">
  <link href="/assets/touch-icon-ipad-retina-b9715401952522f1daee2b4a4064a1bbfb5ffab78d0a47a7226dc87444d51c32.png" rel="apple-touch-icon" sizes="152x152">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Effective Dart: 设计" />
  <meta name="twitter:description" content="Design consistent, usable libraries." />

  <!-- Open Graph -->
  <meta property="og:title" content="Effective Dart: 设计" />
  <meta property="og:description" content="Design consistent, usable libraries." />
  <meta property="og:url" content="https://www.dartlang.org/guides/language/effective-dart/design" />
  <meta property="og:image" content="https://www.dartlang.org/assets/shared/dart-logo-for-shares.png?2" />
  <link href="https://fonts.googleapis.com/css?family=Google+Sans:300,400,500|Google+Sans+Display:400|Roboto:300,400,500|Roboto+Mono:300,400,700|Material+Icons" rel="stylesheet">
  <link rel="stylesheet" type="text/css" integrity="sha256-lXNilrVoDl/TpTBbRIJ9fTZIFZ6OcziJrUwDEUq+4zk=" crossorigin="anonymous" href="/assets/main-95736296b5680e5fd3a5305b44827d7d3648159e8e733889ad4c03114abee339.css">
  <script src="/assets/main-81783b1b9a1d39209aa2ec2eab702b1f7908b15082a3aef81ba13f2255d48ec4.js" integrity="sha256-gXg7G5odOSCaouwuq3ArH3kIsVCCo674G6E/IlXUjsQ=" crossorigin="anonymous" type="text/javascript"></script>
  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


 </head>
  <body class="default show_banner">
    <header id="page-header" class="site-header">
  <nav id="mainnav" class="site-header">
  <div id="menu-toggle"><i class="icon icon-menu"></i></div>
  <a href="/" class="brand" title="Dart">
    <img src="/assets/shared/dart/logo+text/horizontal/white-e71fb382ad5229792cc704b3ee7a88f8013e986d6e34f0956d89c453b454d0a5.svg" alt="Dart">
  </a>
  <ul class="navbar">
    <li class="mainnav__get-started">
      <a href="/docs" class="nav-link active"><span>文档</span></a>
    </li>
    <li>
      <a href="/platforms" class="nav-link">平台</a>
    </li>
    <li>
      <a href="/community" class="nav-link">社区</a>
    </li>
    <li>
      <a href="https://dartpad.cn/" target="_blank" class="nav-link no-automatic-external">体验 Dart</a>
    </li>
    <li>
      <a href="/get-dart" class="nav-link">安装 Dart</a>
    </li>
    <li><a href="/about_zh_CN">关于</a></li>
    <li class="searchfield">
      <form action="/search" class="site-header__search form-inline" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input class="site-header__searchfield form-control" type="search" name="q" id="q" autocomplete="off" placeholder="Search" aria-label="Search">
      </form>
    </li>
  </ul>
</nav>

  
</header>
 <div class="banner">
  <p class="banner__text">
    
    
    Dart 2.3 发布，针对构建用户界面进行了优化。
    <a class="external" href="https://medium.com/dartlang/announcing-dart-2-3-optimized-for-building-user-interfaces-e84919ca1dff">了解更多。</a>
  </p>
</div>
 

    <div id="sidenav" class="">
  <form action="/search/" class="site-header__search form-inline">
    <input class="site-header__searchfield form-control" type="search" name="q" id="q" autocomplete="off" placeholder="Search" aria-label="Search">
  </form>

  <div class="site-sidebar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a href="/platforms" class="nav-link">平台</a>
      </li>
      <li class="nav-item">
        <a href="/community" class="nav-link">社区</a>
      </li>
      <li class="nav-item">
        <a href="https://dartpad.cn" class="nav-link">体验 Dart</a>
      </li>
      <li class="nav-item">
        <a href="/guides" class="nav-link active">文档</a>
      </li>
    </ul>

    <ul class="nav flex-column"><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-1" role="button"
        aria-expanded="false" aria-controls="sidenav-1"
      >示例 & 概览</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-1">
        <li class="nav-item">
    <a class="nav-link" href="/samples">语言示例</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs">Codelab</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials">概览</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link active" data-toggle="collapse" href="#sidenav-2" role="button"
        aria-expanded="true" aria-controls="sidenav-2"
      >语言</a>

      <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-2">
        <li class="nav-item">
    <a class="nav-link" href="/guides/language/language-tour">概览</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/sound-dart">类型系统</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/spec">规范</a>
  </li><li class="nav-item">
    <a class="nav-link active" href="/guides/language/effective-dart">Effective Dart</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-3" role="button"
        aria-expanded="false" aria-controls="sidenav-3"
      >核心库</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-3">
        <li class="nav-item">
    <a class="nav-link" href="/guides/libraries">综述</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/library-tour">概览</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-3-3"
      href="#sidenav-3-3" role="button"
      aria-expanded="false" aria-controls="sidenav-3-3"
    >文章
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-3-3">
      <li class="nav-item">
    <a class="nav-link" href="/articles/libraries/dart-io">Intro to dart:io</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/articles/libraries/creating-streams">Creating streams</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-4" role="button"
        aria-expanded="false" aria-controls="sidenav-4"
      >包</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-4">
        <li class="nav-item">
    <a class="nav-link" href="/guides/packages">如何使用包</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/useful-libraries">常用的包</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/create-library-packages">创建包</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/publishing">发布包</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-4-5"
      href="#sidenav-4-5" role="button"
      aria-expanded="false" aria-controls="sidenav-4-5"
    >引用包
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-4-5">
      <li class="nav-item">
    <a class="nav-link" href="/tools/pub/dependencies">依赖</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/glossary">术语</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/package-layout">包的设计约定</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/environment-variables">Pub 环境变量</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/pubspec">Pubspec 文件</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/troubleshoot">Pub 问题分析与解决</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/versioning">版本</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-5" role="button"
        aria-expanded="false" aria-controls="sidenav-5"
      >开发</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5">
        <li class="nav-item">
    <a class="nav-link" href="/tutorials/language/futures">Futures & Async-Await</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/json">使用 JSON</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/language/streams">Stream</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/mobile">移动应用</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-5"
      href="#sidenav-5-5" role="button"
      aria-expanded="false" aria-controls="sidenav-5-5"
    >命令行应用 & 服务应用
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-5">
      <li class="nav-item">
    <a class="nav-link" href="/server">综述</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/get-started">入门</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/cmdline">编写命令行应用</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/httpserver">编写 HTTP 客户端和服务端应用</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/server/c-interop">C & C++ 交互</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/server/libraries">库和包</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-6"
      href="#sidenav-5-6" role="button"
      aria-expanded="false" aria-controls="sidenav-5-6"
    >Web 应用
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-6">
      <li class="nav-item">
    <a class="nav-link" href="/web">综述</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/web/get-started">入门</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/web/fetch-data">动态获取数据</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-6-4"
      href="#sidenav-5-6-4" role="button"
      aria-expanded="false" aria-controls="sidenav-5-6-4"
    >底层 Web 编程
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-6-4">
      <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/connect-dart-html">Dart 和 HTML 关联</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/add-elements">在 DOM 中增加 Element</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/remove-elements">在 DOM 中移除 Element</a>
  </li>
  </ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/web/js-interop">JS/TS 交互</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/deployment">开发</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/libraries">库和包</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-6" role="button"
        aria-expanded="false" aria-controls="sidenav-6"
      >工具 & 技巧</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6">
        <li class="nav-item">
    <a class="nav-link" href="/tools">综述</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-2"
      href="#sidenav-6-2" role="button"
      aria-expanded="false" aria-controls="sidenav-6-2"
    >编辑 & 调试
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-2">
      <li class="nav-item">
    <a class="nav-link" href="/tools/dart-devtools">Dart DevTool</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/dartpad">DartPad</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/jetbrains-plugin">IntelliJ & Android Studio</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/vs-code">VS Code</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-3"
      href="#sidenav-6-3" role="button"
      aria-expanded="false" aria-controls="sidenav-6-3"
    >Command-line tools
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-3">
      <li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-6-3-1"
      href="#sidenav-6-3-1" role="button"
      aria-expanded="true" aria-controls="sidenav-6-3-1"
    >Dart SDK
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6-3-1">
      <li class="nav-item">
    <a class="nav-link" href="/tools/sdk">综述</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-vm">dart (Dart VM)</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart2aot">dart2aot & dartaotruntime</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart2js">dart2js (prod JS)</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dartanalyzer">dartanalyzer</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dartdevc">dartdevc (dev JS)</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dartdoc">dartdoc</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dartfmt">dartfmt</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/pub/cmd">pub</a>
  </li>
  </ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-6-3-2"
      href="#sidenav-6-3-2" role="button"
      aria-expanded="true" aria-controls="sidenav-6-3-2"
    >其他命令行工具
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6-3-2">
      <li class="nav-item">
    <a class="nav-link" href="/tools/build_runner">build_runner</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/webdev">webdev</a>
  </li>
  </ul>
  </li>
</ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-4"
      href="#sidenav-6-4" role="button"
      aria-expanded="false" aria-controls="sidenav-6-4"
    >源码管理
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-4">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/formatting">格式化代码</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/private-files">哪些内容不应该被提交</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-5"
      href="#sidenav-6-5" role="button"
      aria-expanded="false" aria-controls="sidenav-6-5"
    >静态分析
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-5">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/analysis-options">Customizing static analysis</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/sound-problems">Fixing common type problems</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-6"
      href="#sidenav-6-6" role="button"
      aria-expanded="false" aria-controls="sidenav-6-6"
    >测试 & 优化
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-6">
      <li class="nav-item">
    <a class="nav-link" href="/guides/testing">测试</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/debugging">调试 Web 应用</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-7" role="button"
        aria-expanded="false" aria-controls="sidenav-7"
      >资源</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-7">
        <li class="nav-item">
    <a class="nav-link" href="/code-of-conduct">行为守则</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/faq">FAQ</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-7-3"
      href="#sidenav-7-3" role="button"
      aria-expanded="false" aria-controls="sidenav-7-3"
    >历史
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-7-3">
      <li class="nav-item">
    <a class="nav-link" href="/dart-2">迁移到 Dart&nbsp;2</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/dart-2">迁移 Web 应用到 Dart&nbsp;2</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/obsolete">过时的 Pub 功能</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link " data-toggle="collapse" href="#sidenav-8" role="button"
        aria-expanded="true" aria-controls="sidenav-8"
      >相关网站</a>

      <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-8">
        <li class="nav-item">
    <a class="nav-link" href="https://api.dartlang.org" target="_blank" rel="noopener">API 参考<i class="fas fa-external-link-alt"></i></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://medium.com/dartlang" target="_blank" rel="noopener">Blog<i class="fas fa-external-link-alt"></i></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://dartpad.cn" target="_blank" rel="noopener">DartPad (在线编辑器)<i class="fas fa-external-link-alt"></i></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://flutter.dev" target="_blank" rel="noopener">Flutter<i class="fas fa-external-link-alt"></i></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://pub.dev" target="_blank" rel="noopener">Pub 包资源<i class="fas fa-external-link-alt"></i></a>
  </li>
</ul>
    </li></ul>

  </div>
</div>

    <main id="page-content">
      







<div id="site-toc--side" class="site-toc ">
  <header class="site-toc__title">
    内容
    <button type="button" class="btn site-toc--button__page-top" aria-label="Page top"></button>
    
  </header>
  <ul class="section-nav nav">
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#命名">命名</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-使用一致的术语">要 使用一致的术语。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-缩写">避免 缩写。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-把最具描述性的名词放到最后">推荐 把最具描述性的名词放到最后。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-尽量让代码看起来像普通的句子">考虑 尽量让代码看起来像普通的句子。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使用名词短语来命名不是布尔类型的变量和属性">推荐 使用名词短语来命名不是布尔类型的变量和属性。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使用非命令式动词短语命名布尔类型的变量和属性">推荐 使用非命令式动词短语命名布尔类型的变量和属性。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-省略命名布尔参数的动词">考虑 省略命名布尔参数的动词。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-为布尔属性或变量取肯定含义的名字">考虑 为布尔属性或变量取“肯定”含义的名字。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使用命令式动词短语来命名带有副作用的函数或者方法">推荐 使用命令式动词短语来命名带有副作用的函数或者方法。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数">考虑 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视">考虑 使用命令式动词短语命名一个函数或方法，若果你希望它的执行能被重视。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-在方法命名中使用-get-开头">避免 在方法命名中使用 get 开头。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数">推荐 使用 to___() 来命名把对象的状态转换到一个新的对象的函数。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数">推荐 使用 as___() 来命名把原来对象转换为另外一种表现形式的函数。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-在方法或者函数名称中描述参数">避免 在方法或者函数名称中描述参数。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-在命名参数时遵循现有的助记符约定">要 在命名参数时，遵循现有的助记符约定。</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#库">库</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使用私有声明">推荐 使用私有声明。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-声明多个类在一个库中">考虑 声明多个类在一个库中。</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#类">类</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类">避免 避免为了使用一个简单的函数而去定义一个单一成员的抽象类</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-定义仅包含静态成员的类">避免 定义仅包含静态成员的类。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-集成一个不期望被集成的类">避免 集成一个不期望被集成的类。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-把能够继承的说明添加到文档中如果这个类可以继承">要 把能够继承的说明添加到文档中，如果这个类可以继承。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-去实现一个不期望成为接口的类该类不想作为接口被实现">避免 去实现一个不期望成为接口的类（该类不想作为接口被实现）。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-对支持接口的类在文档注明">要 对支持接口的类在文档注明</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-去-mixin-一个不期望被-mixin-的类">避免 去 mixin 一个不期望被 mixin 的类</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-对支持-mixin-的类在文档注明">要 对支持 mixin 的类在文档注明</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#构造函数">构造函数</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-在类支持的情况下指定构造函数为--const">考虑 在类支持的情况下，指定构造函数为  const。</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#成员">成员</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-指定字段或顶级变量为-final-">推荐 指定字段或顶级变量为 final 。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-对概念上是访问的属性使用-getter-方法">要 对概念上是访问的属性使用 getter 方法。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-对概念上是修改的属性使用-setter-方法">要 对概念上是修改的属性使用 setter 方法。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#不要-在没有对应的-getter-的情况下定义-setter">不要 在没有对应的 getter 的情况下定义 setter。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-从返回类型为-bool--double--int-或-num-的成员返回-null-">避免 从返回类型为 bool ， double ， int 或 num 的成员返回 null 。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-为了书写流畅而从方法中返回-this-">避免 为了书写流畅，而从方法中返回 this 。</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#类型">类型</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-为类型不明显的公共字段和公共顶级变量指定类型注解">推荐 为类型不明显的公共字段和公共顶级变量指定类型注解。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-为类型不明显的私有字段和私有顶级变量指定类型注解">考虑 为类型不明显的私有字段和私有顶级变量指定类型注解。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-为初始化的局部变量添加类型注解">避免 为初始化的局部变量添加类型注解。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-在函数表达式上注解推断的参数类型">避免 在函数表达式上注解推断的参数类型。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-在泛型调用中参数类型的冗余使用">避免 在泛型调用中参数类型的冗余使用。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-在-dart-推断类型错误的时候进行类型注解">要 在 Dart 推断类型错误的时候进行类型注解。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使用-dynamic-注解替换推断失败的情况">推荐 使用 dynamic 注解替换推断失败的情况。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-使-function-类型注解的特征更明显">推荐 使 function 类型注解的特征更明显</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#不要-为-setter-方法指定返回类型">不要 为 setter 方法指定返回类型。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#不要-使用弃用的-typedef-语法">不要 使用弃用的 typedef 语法。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#推荐-优先使用内联函数类型而后是-typedef-">推荐 优先使用内联函数类型，而后是 typedef 。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#考虑-在参数上使用函数类型语法">考虑 在参数上使用函数类型语法。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-为类型是任何对象的参数使用-object-注解而不是-dynamic-">要 为类型是任何对象的参数使用 Object 注解，而不是 dynamic 。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-使用-futurevoid-作为无法回值异步成员的返回类型">要 使用 Future&lt;void&gt; 作为无法回值异步成员的返回类型。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-使用-futureort-作为返回类型">避免 使用 FutureOr&lt;T&gt; 作为返回类型。</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#参数">参数</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-布尔类型的位置参数">避免 布尔类型的位置参数。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-在调用者需要省略前面参数的方法中使用位置可选参数">避免 在调用者需要省略前面参数的方法中，使用位置可选参数。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-强制参数去接受一个特定表示空参数的值">避免 强制参数去接受一个特定表示”空参数”的值。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-使用开始为闭区间结束为开区间的半开半闭区间作为接受范围">要 使用开始为闭区间，结束为开区间的半开半闭区间作为接受范围。</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#相等">相等</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-对重写--操作符的类重写-hashcode-方法">要 对重写 == 操作符的类，重写 hashCode 方法。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#要-让--操作符的相等遵守数学规则">要 让 == 操作符的相等遵守数学规则。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#避免-为可变类自定义相等">避免 为可变类自定义相等。</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#不要-在自定义--操作符中检查-null-">不要 在自定义 == 操作符中检查 null 。</a></li>
</ul>
</li>
</ul>
</div>


      <article>
        <div class="content">
          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/usage">&lang;&nbsp;&nbsp;使用</a>
      
    </li>
    <li class="next">
      
    </li>
  </ul>
</nav>


          <div>
            <div id="page-github-links" class="btn-group" aria-label="Page GitHub links" role="group">
  <a href="https://github.com/dartchina/site-www-cn/tree/src_zh_CN/src_zh_CN/_guides/language/effective-dart/design.md" class="btn no-automatic-external" title="View page source" target="_blank" rel="noopener">
    <i class="fas fa-file-alt fa-sm"></i>
  </a>
  <a href="https://github.com/dartchina/site-www-cn/issues/new?title='Effective Dart: 设计' page issue&body=
Page URL: https://www.dartlang.org/guides/language/effective-dart/design%0D%0A
Page source: https://github.com/dartchina/site-www-cn/tree/src_zh_CN/src_zh_CN/_guides/language/effective-dart/design.md%0D%0A
%0D%0A
Found a typo? You can fix it yourself by going to the page source and clicking the pencil icon. Or finish creating this issue.%0D%0A
%0D%0A
Description of issue:" class="btn no-automatic-external" title="Report an issue with this page"
    target="_blank" rel="noopener">
    <i class="fas fa-bug fa-sm"></i>
  </a>
</div>

            <h1>Effective Dart: 设计</h1>
          </div>
          







<div id="site-toc--inline" class="site-toc toc-collapsible toc-collapsed">
  <header class="site-toc__title">
    内容
    <button type="button" class="btn site-toc--button__page-top" aria-label="Page top"></button>
    
      <span class="site-toc--inline__toggle toc-toggle-down"><i class="fas fa-chevron-down fa-m"></i></span>
      <span class="site-toc--inline__toggle toc-toggle-up"><i class="fas fa-chevron-up fa-m"></i></span>
    
  </header>
  <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#命名">命名</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-使用一致的术语">要 使用一致的术语。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-缩写">避免 缩写。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-把最具描述性的名词放到最后">推荐 把最具描述性的名词放到最后。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-尽量让代码看起来像普通的句子">考虑 尽量让代码看起来像普通的句子。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用名词短语来命名不是布尔类型的变量和属性">推荐 使用名词短语来命名不是布尔类型的变量和属性。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用非命令式动词短语命名布尔类型的变量和属性">推荐 使用非命令式动词短语命名布尔类型的变量和属性。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-省略命名布尔参数的动词">考虑 省略命名布尔参数的动词。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-为布尔属性或变量取肯定含义的名字">考虑 为布尔属性或变量取“肯定”含义的名字。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用命令式动词短语来命名带有副作用的函数或者方法">推荐 使用命令式动词短语来命名带有副作用的函数或者方法。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数">考虑 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视">考虑 使用命令式动词短语命名一个函数或方法，若果你希望它的执行能被重视。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在方法命名中使用-get-开头">避免 在方法命名中使用 get 开头。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数">推荐 使用 to___() 来命名把对象的状态转换到一个新的对象的函数。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数">推荐 使用 as___() 来命名把原来对象转换为另外一种表现形式的函数。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在方法或者函数名称中描述参数">避免 在方法或者函数名称中描述参数。</a></li>
<li class="toc-entry toc-h3"><a href="#要-在命名参数时遵循现有的助记符约定">要 在命名参数时，遵循现有的助记符约定。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#库">库</a>
<ul>
<li class="toc-entry toc-h3"><a href="#推荐-使用私有声明">推荐 使用私有声明。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-声明多个类在一个库中">考虑 声明多个类在一个库中。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#类">类</a>
<ul>
<li class="toc-entry toc-h3"><a href="#避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类">避免 避免为了使用一个简单的函数而去定义一个单一成员的抽象类</a></li>
<li class="toc-entry toc-h3"><a href="#避免-定义仅包含静态成员的类">避免 定义仅包含静态成员的类。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-集成一个不期望被集成的类">避免 集成一个不期望被集成的类。</a></li>
<li class="toc-entry toc-h3"><a href="#要-把能够继承的说明添加到文档中如果这个类可以继承">要 把能够继承的说明添加到文档中，如果这个类可以继承。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-去实现一个不期望成为接口的类该类不想作为接口被实现">避免 去实现一个不期望成为接口的类（该类不想作为接口被实现）。</a></li>
<li class="toc-entry toc-h3"><a href="#要-对支持接口的类在文档注明">要 对支持接口的类在文档注明</a></li>
<li class="toc-entry toc-h3"><a href="#避免-去-mixin-一个不期望被-mixin-的类">避免 去 mixin 一个不期望被 mixin 的类</a></li>
<li class="toc-entry toc-h3"><a href="#要-对支持-mixin-的类在文档注明">要 对支持 mixin 的类在文档注明</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#构造函数">构造函数</a>
<ul>
<li class="toc-entry toc-h3"><a href="#考虑-在类支持的情况下指定构造函数为--const">考虑 在类支持的情况下，指定构造函数为  const。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#成员">成员</a>
<ul>
<li class="toc-entry toc-h3"><a href="#推荐-指定字段或顶级变量为-final-">推荐 指定字段或顶级变量为 final 。</a></li>
<li class="toc-entry toc-h3"><a href="#要-对概念上是访问的属性使用-getter-方法">要 对概念上是访问的属性使用 getter 方法。</a></li>
<li class="toc-entry toc-h3"><a href="#要-对概念上是修改的属性使用-setter-方法">要 对概念上是修改的属性使用 setter 方法。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-在没有对应的-getter-的情况下定义-setter">不要 在没有对应的 getter 的情况下定义 setter。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-从返回类型为-bool--double--int-或-num-的成员返回-null-">避免 从返回类型为 bool ， double ， int 或 num 的成员返回 null 。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-为了书写流畅而从方法中返回-this-">避免 为了书写流畅，而从方法中返回 this 。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#类型">类型</a>
<ul>
<li class="toc-entry toc-h3"><a href="#推荐-为类型不明显的公共字段和公共顶级变量指定类型注解">推荐 为类型不明显的公共字段和公共顶级变量指定类型注解。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-为类型不明显的私有字段和私有顶级变量指定类型注解">考虑 为类型不明显的私有字段和私有顶级变量指定类型注解。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-为初始化的局部变量添加类型注解">避免 为初始化的局部变量添加类型注解。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在函数表达式上注解推断的参数类型">避免 在函数表达式上注解推断的参数类型。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在泛型调用中参数类型的冗余使用">避免 在泛型调用中参数类型的冗余使用。</a></li>
<li class="toc-entry toc-h3"><a href="#要-在-dart-推断类型错误的时候进行类型注解">要 在 Dart 推断类型错误的时候进行类型注解。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用-dynamic-注解替换推断失败的情况">推荐 使用 dynamic 注解替换推断失败的情况。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使-function-类型注解的特征更明显">推荐 使 function 类型注解的特征更明显</a></li>
<li class="toc-entry toc-h3"><a href="#不要-为-setter-方法指定返回类型">不要 为 setter 方法指定返回类型。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用弃用的-typedef-语法">不要 使用弃用的 typedef 语法。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-优先使用内联函数类型而后是-typedef-">推荐 优先使用内联函数类型，而后是 typedef 。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-在参数上使用函数类型语法">考虑 在参数上使用函数类型语法。</a></li>
<li class="toc-entry toc-h3"><a href="#要-为类型是任何对象的参数使用-object-注解而不是-dynamic-">要 为类型是任何对象的参数使用 Object 注解，而不是 dynamic 。</a></li>
<li class="toc-entry toc-h3"><a href="#要-使用-futurevoid-作为无法回值异步成员的返回类型">要 使用 Future&lt;void&gt; 作为无法回值异步成员的返回类型。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-使用-futureort-作为返回类型">避免 使用 FutureOr&lt;T&gt; 作为返回类型。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#参数">参数</a>
<ul>
<li class="toc-entry toc-h3"><a href="#避免-布尔类型的位置参数">避免 布尔类型的位置参数。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在调用者需要省略前面参数的方法中使用位置可选参数">避免 在调用者需要省略前面参数的方法中，使用位置可选参数。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-强制参数去接受一个特定表示空参数的值">避免 强制参数去接受一个特定表示”空参数”的值。</a></li>
<li class="toc-entry toc-h3"><a href="#要-使用开始为闭区间结束为开区间的半开半闭区间作为接受范围">要 使用开始为闭区间，结束为开区间的半开半闭区间作为接受范围。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#相等">相等</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-对重写--操作符的类重写-hashcode-方法">要 对重写 == 操作符的类，重写 hashCode 方法。</a></li>
<li class="toc-entry toc-h3"><a href="#要-让--操作符的相等遵守数学规则">要 让 == 操作符的相等遵守数学规则。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-为可变类自定义相等">避免 为可变类自定义相等。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-在自定义--操作符中检查-null-">不要 在自定义 == 操作符中检查 null 。</a></li>
</ul>
</li>
</ul>
</div>


          <?code-excerpt replace="/([A-Z]\w*)\d\b/$1/g"?>
<?code-excerpt plaster="none"?>

<p>下面给出的准则用于指导为库编写一致的、可用的 API。</p>

<ul id="markdown-toc">
  <li>
<a href="#%E5%91%BD%E5%90%8D" id="markdown-toc-命名">命名</a>    <ul>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E7%9A%84%E6%9C%AF%E8%AF%AD" id="markdown-toc-要-使用一致的术语"><strong>要</strong> 使用一致的术语。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E7%BC%A9%E5%86%99" id="markdown-toc-避免-缩写"><strong>避免</strong> 缩写。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E6%8A%8A%E6%9C%80%E5%85%B7%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%9A%84%E5%90%8D%E8%AF%8D%E6%94%BE%E5%88%B0%E6%9C%80%E5%90%8E" id="markdown-toc-推荐-把最具描述性的名词放到最后"><strong>推荐</strong> 把最具描述性的名词放到最后。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E5%B0%BD%E9%87%8F%E8%AE%A9%E4%BB%A3%E7%A0%81%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%83%8F%E6%99%AE%E9%80%9A%E7%9A%84%E5%8F%A5%E5%AD%90" id="markdown-toc-考虑-尽量让代码看起来像普通的句子"><strong>考虑</strong> 尽量让代码看起来像普通的句子。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E4%B8%8D%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" id="markdown-toc-推荐-使用名词短语来命名不是布尔类型的变量和属性"><strong>推荐</strong> 使用名词短语来命名不是布尔类型的变量和属性。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" id="markdown-toc-推荐-使用非命令式动词短语命名布尔类型的变量和属性"><strong>推荐</strong> 使用非命令式动词短语命名布尔类型的变量和属性。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E7%9C%81%E7%95%A5%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E8%AF%8D" id="markdown-toc-考虑-省略命名布尔参数的动词"><strong>考虑</strong> 省略命名布尔<em>参数</em>的动词。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%B8%BA%E5%B8%83%E5%B0%94%E5%B1%9E%E6%80%A7%E6%88%96%E5%8F%98%E9%87%8F%E5%8F%96%E8%82%AF%E5%AE%9A%E5%90%AB%E4%B9%89%E7%9A%84%E5%90%8D%E5%AD%97" id="markdown-toc-考虑-为布尔属性或变量取肯定含义的名字"><strong>考虑</strong> 为布尔属性或变量取“肯定”含义的名字。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95" id="markdown-toc-推荐-使用命令式动词短语来命名带有副作用的函数或者方法"><strong>推荐</strong> 使用命令式动词短语来命名带有副作用的函数或者方法。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%88%96%E8%80%85%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0" id="markdown-toc-考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数"><strong>考虑</strong> 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95%E8%8B%A5%E6%9E%9C%E4%BD%A0%E5%B8%8C%E6%9C%9B%E5%AE%83%E7%9A%84%E6%89%A7%E8%A1%8C%E8%83%BD%E8%A2%AB%E9%87%8D%E8%A7%86" id="markdown-toc-考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视"><strong>考虑</strong> 使用命令式动词短语命名一个函数或方法，若果你希望它的执行能被重视。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E4%B8%AD%E4%BD%BF%E7%94%A8-get-%E5%BC%80%E5%A4%B4" id="markdown-toc-避免-在方法命名中使用-get-开头"><strong>避免</strong> 在方法命名中使用 <code class="highlighter-rouge">get</code> 开头。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-to___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0" id="markdown-toc-推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数"><strong>推荐</strong> 使用 <code class="highlighter-rouge">to___()</code> 来命名把对象的状态转换到一个新的对象的函数。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-as___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%8E%9F%E6%9D%A5%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0" id="markdown-toc-推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数"><strong>推荐</strong> 使用 <code class="highlighter-rouge">as___()</code> 来命名把原来对象转换为另外一种表现形式的函数。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E4%B8%AD%E6%8F%8F%E8%BF%B0%E5%8F%82%E6%95%B0" id="markdown-toc-避免-在方法或者函数名称中描述参数"><strong>避免</strong> 在方法或者函数名称中描述参数。</a></li>
      <li><a href="#%E8%A6%81-%E5%9C%A8%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E6%97%B6%E9%81%B5%E5%BE%AA%E7%8E%B0%E6%9C%89%E7%9A%84%E5%8A%A9%E8%AE%B0%E7%AC%A6%E7%BA%A6%E5%AE%9A" id="markdown-toc-要-在命名参数时遵循现有的助记符约定"><strong>要</strong> 在命名参数时，遵循现有的助记符约定。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%BA%93" id="markdown-toc-库">库</a>    <ul>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E5%A3%B0%E6%98%8E" id="markdown-toc-推荐-使用私有声明"><strong>推荐</strong> 使用私有声明。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E4%B8%AD" id="markdown-toc-考虑-声明多个类在一个库中"><strong>考虑</strong> 声明多个类在一个库中。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E7%B1%BB" id="markdown-toc-类">类</a>    <ul>
      <li><a href="#%E9%81%BF%E5%85%8D-%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BA%86%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E8%80%8C%E5%8E%BB%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8D%95%E4%B8%80%E6%88%90%E5%91%98%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB" id="markdown-toc-避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类"><strong>避免</strong> 避免为了使用一个简单的函数而去定义一个单一成员的抽象类</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%AE%9A%E4%B9%89%E4%BB%85%E5%8C%85%E5%90%AB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB" id="markdown-toc-避免-定义仅包含静态成员的类"><strong>避免</strong> 定义仅包含静态成员的类。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E9%9B%86%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB%E9%9B%86%E6%88%90%E7%9A%84%E7%B1%BB" id="markdown-toc-避免-集成一个不期望被集成的类"><strong>避免</strong> 集成一个不期望被集成的类。</a></li>
      <li><a href="#%E8%A6%81-%E6%8A%8A%E8%83%BD%E5%A4%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%B4%E6%98%8E%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%96%87%E6%A1%A3%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF" id="markdown-toc-要-把能够继承的说明添加到文档中如果这个类可以继承"><strong>要</strong> 把能够继承的说明添加到文档中，如果这个类可以继承。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E6%88%90%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E8%AF%A5%E7%B1%BB%E4%B8%8D%E6%83%B3%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E8%A2%AB%E5%AE%9E%E7%8E%B0" id="markdown-toc-避免-去实现一个不期望成为接口的类该类不想作为接口被实现"><strong>避免</strong> 去实现一个不期望成为接口的类（该类不想作为接口被实现）。</a></li>
      <li><a href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" id="markdown-toc-要-对支持接口的类在文档注明"><strong>要</strong> 对支持接口的类在文档注明</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%8E%BB-mixin-%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB-mixin-%E7%9A%84%E7%B1%BB" id="markdown-toc-避免-去-mixin-一个不期望被-mixin-的类"><strong>避免</strong> 去 mixin 一个不期望被 mixin 的类</a></li>
      <li><a href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81-mixin-%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" id="markdown-toc-要-对支持-mixin-的类在文档注明"><strong>要</strong> 对支持 mixin 的类在文档注明</a></li>
    </ul>
  </li>
  <li>
<a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" id="markdown-toc-构造函数">构造函数</a>    <ul>
      <li><a href="#%E8%80%83%E8%99%91-%E5%9C%A8%E7%B1%BB%E6%94%AF%E6%8C%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%8C%87%E5%AE%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA--const" id="markdown-toc-考虑-在类支持的情况下指定构造函数为--const"><strong>考虑</strong> 在类支持的情况下，指定构造函数为  <code class="highlighter-rouge">const</code>。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E6%88%90%E5%91%98" id="markdown-toc-成员">成员</a>    <ul>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E6%88%96%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E4%B8%BA-final-" id="markdown-toc-推荐-指定字段或顶级变量为-final-"><strong>推荐</strong> 指定字段或顶级变量为 <code class="highlighter-rouge">final</code> 。</a></li>
      <li><a href="#%E8%A6%81-%E5%AF%B9%E6%A6%82%E5%BF%B5%E4%B8%8A%E6%98%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8-getter-%E6%96%B9%E6%B3%95" id="markdown-toc-要-对概念上是访问的属性使用-getter-方法"><strong>要</strong> 对概念上是访问的属性使用 getter 方法。</a></li>
      <li><a href="#%E8%A6%81-%E5%AF%B9%E6%A6%82%E5%BF%B5%E4%B8%8A%E6%98%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8-setter-%E6%96%B9%E6%B3%95" id="markdown-toc-要-对概念上是修改的属性使用-setter-方法"><strong>要</strong> 对概念上是修改的属性使用 setter 方法。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84-getter-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%9A%E4%B9%89-setter" id="markdown-toc-不要-在没有对应的-getter-的情况下定义-setter"><strong>不要</strong> 在没有对应的 getter 的情况下定义 setter。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%BB%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%BA-bool--double--int-%E6%88%96-num-%E7%9A%84%E6%88%90%E5%91%98%E8%BF%94%E5%9B%9E-null-" id="markdown-toc-避免-从返回类型为-bool--double--int-或-num-的成员返回-null-"><strong>避免</strong> 从返回类型为 <code class="highlighter-rouge">bool</code> ， <code class="highlighter-rouge">double</code> ， <code class="highlighter-rouge">int</code> 或 <code class="highlighter-rouge">num</code> 的成员返回 <code class="highlighter-rouge">null</code> 。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%B8%BA%E4%BA%86%E4%B9%A6%E5%86%99%E6%B5%81%E7%95%85%E8%80%8C%E4%BB%8E%E6%96%B9%E6%B3%95%E4%B8%AD%E8%BF%94%E5%9B%9E-this-" id="markdown-toc-避免-为了书写流畅而从方法中返回-this-"><strong>避免</strong> 为了书写流畅，而从方法中返回 <code class="highlighter-rouge">this</code> 。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E7%B1%BB%E5%9E%8B" id="markdown-toc-类型">类型</a>    <ul>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%8E%E6%98%BE%E7%9A%84%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%92%8C%E5%85%AC%E5%85%B1%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" id="markdown-toc-推荐-为类型不明显的公共字段和公共顶级变量指定类型注解"><strong>推荐</strong> 为类型不明显的公共字段和公共顶级变量指定类型注解。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%8E%E6%98%BE%E7%9A%84%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E5%92%8C%E7%A7%81%E6%9C%89%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" id="markdown-toc-考虑-为类型不明显的私有字段和私有顶级变量指定类型注解"><strong>考虑</strong> 为类型不明显的私有字段和私有顶级变量指定类型注解。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%B8%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" id="markdown-toc-避免-为初始化的局部变量添加类型注解"><strong>避免</strong> 为初始化的局部变量添加类型注解。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8A%E6%B3%A8%E8%A7%A3%E6%8E%A8%E6%96%AD%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B" id="markdown-toc-避免-在函数表达式上注解推断的参数类型"><strong>避免</strong> 在函数表达式上注解推断的参数类型。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%B3%9B%E5%9E%8B%E8%B0%83%E7%94%A8%E4%B8%AD%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%97%E4%BD%99%E4%BD%BF%E7%94%A8" id="markdown-toc-避免-在泛型调用中参数类型的冗余使用"><strong>避免</strong> 在泛型调用中参数类型的冗余使用。</a></li>
      <li><a href="#%E8%A6%81-%E5%9C%A8-dart-%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" id="markdown-toc-要-在-dart-推断类型错误的时候进行类型注解"><strong>要</strong> 在 Dart 推断类型错误的时候进行类型注解。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-dynamic-%E6%B3%A8%E8%A7%A3%E6%9B%BF%E6%8D%A2%E6%8E%A8%E6%96%AD%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%83%85%E5%86%B5" id="markdown-toc-推荐-使用-dynamic-注解替换推断失败的情况"><strong>推荐</strong> 使用 <code class="highlighter-rouge">dynamic</code> 注解替换推断失败的情况。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF-function-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%89%B9%E5%BE%81%E6%9B%B4%E6%98%8E%E6%98%BE" id="markdown-toc-推荐-使-function-类型注解的特征更明显"><strong>推荐</strong> 使 function 类型注解的特征更明显</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%B8%BA-setter-%E6%96%B9%E6%B3%95%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" id="markdown-toc-不要-为-setter-方法指定返回类型"><strong>不要</strong> 为 setter 方法指定返回类型。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8%E5%BC%83%E7%94%A8%E7%9A%84-typedef-%E8%AF%AD%E6%B3%95" id="markdown-toc-不要-使用弃用的-typedef-语法"><strong>不要</strong> 使用弃用的 typedef 语法。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%80%8C%E5%90%8E%E6%98%AF-typedef-" id="markdown-toc-推荐-优先使用内联函数类型而后是-typedef-"><strong>推荐</strong> 优先使用内联函数类型，而后是 typedef 。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E5%9C%A8%E5%8F%82%E6%95%B0%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%AF%AD%E6%B3%95" id="markdown-toc-考虑-在参数上使用函数类型语法"><strong>考虑</strong> 在参数上使用函数类型语法。</a></li>
      <li><a href="#%E8%A6%81-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%BB%E4%BD%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8-object-%E6%B3%A8%E8%A7%A3%E8%80%8C%E4%B8%8D%E6%98%AF-dynamic-" id="markdown-toc-要-为类型是任何对象的参数使用-object-注解而不是-dynamic-"><strong>要</strong> 为类型是任何对象的参数使用 <code class="highlighter-rouge">Object</code> 注解，而不是 <code class="highlighter-rouge">dynamic</code> 。</a></li>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-futurevoid-%E4%BD%9C%E4%B8%BA%E6%97%A0%E6%B3%95%E5%9B%9E%E5%80%BC%E5%BC%82%E6%AD%A5%E6%88%90%E5%91%98%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" id="markdown-toc-要-使用-futurevoid-作为无法回值异步成员的返回类型"><strong>要</strong> 使用 <code class="highlighter-rouge">Future&lt;void&gt;</code> 作为无法回值异步成员的返回类型。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%BD%BF%E7%94%A8-futureort-%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" id="markdown-toc-避免-使用-futureort-作为返回类型"><strong>避免</strong> 使用 <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> 作为返回类型。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%8F%82%E6%95%B0" id="markdown-toc-参数">参数</a>    <ul>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0" id="markdown-toc-避免-布尔类型的位置参数"><strong>避免</strong> 布尔类型的位置参数。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E8%B0%83%E7%94%A8%E8%80%85%E9%9C%80%E8%A6%81%E7%9C%81%E7%95%A5%E5%89%8D%E9%9D%A2%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0" id="markdown-toc-避免-在调用者需要省略前面参数的方法中使用位置可选参数"><strong>避免</strong> 在调用者需要省略前面参数的方法中，使用位置可选参数。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%BC%BA%E5%88%B6%E5%8F%82%E6%95%B0%E5%8E%BB%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E8%A1%A8%E7%A4%BA%E7%A9%BA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC" id="markdown-toc-避免-强制参数去接受一个特定表示空参数的值"><strong>避免</strong> 强制参数去接受一个特定表示”空参数”的值。</a></li>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E5%BC%80%E5%A7%8B%E4%B8%BA%E9%97%AD%E5%8C%BA%E9%97%B4%E7%BB%93%E6%9D%9F%E4%B8%BA%E5%BC%80%E5%8C%BA%E9%97%B4%E7%9A%84%E5%8D%8A%E5%BC%80%E5%8D%8A%E9%97%AD%E5%8C%BA%E9%97%B4%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%97%E8%8C%83%E5%9B%B4" id="markdown-toc-要-使用开始为闭区间结束为开区间的半开半闭区间作为接受范围"><strong>要</strong> 使用开始为闭区间，结束为开区间的半开半闭区间作为接受范围。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E7%9B%B8%E7%AD%89" id="markdown-toc-相等">相等</a>    <ul>
      <li><a href="#%E8%A6%81-%E5%AF%B9%E9%87%8D%E5%86%99--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E7%B1%BB%E9%87%8D%E5%86%99-hashcode-%E6%96%B9%E6%B3%95" id="markdown-toc-要-对重写--操作符的类重写-hashcode-方法"><strong>要</strong> 对重写 <code class="highlighter-rouge">==</code> 操作符的类，重写 <code class="highlighter-rouge">hashCode</code> 方法。</a></li>
      <li><a href="#%E8%A6%81-%E8%AE%A9--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E7%9B%B8%E7%AD%89%E9%81%B5%E5%AE%88%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%99" id="markdown-toc-要-让--操作符的相等遵守数学规则"><strong>要</strong> 让 <code class="highlighter-rouge">==</code> 操作符的相等遵守数学规则。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%B8%BA%E5%8F%AF%E5%8F%98%E7%B1%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E7%AD%89" id="markdown-toc-避免-为可变类自定义相等"><strong>避免</strong> 为可变类自定义相等。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89--%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%AD%E6%A3%80%E6%9F%A5-null-" id="markdown-toc-不要-在自定义--操作符中检查-null-"><strong>不要</strong> 在自定义 <code class="highlighter-rouge">==</code> 操作符中检查 <code class="highlighter-rouge">null</code> 。</a></li>
    </ul>
  </li>
</ul>

<h2 id="命名">
<a id="命名" class="anchor" href="#%E5%91%BD%E5%90%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a>命名</h2>

<p>命名是编写可读，可维护代码的重要部分。
以下最佳实践可帮助你实现这个目标。</p>

<h3 id="要-使用一致的术语">
<a id="要-使用一致的术语" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E7%9A%84%E6%9C%AF%E8%AF%AD" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用一致的术语。</h3>

<p>在你的代码中，同样的东西要使用同样的名字。
如果之前已经存在的 API 之外命名，并且用户已经熟知，
那么请继续使用这个命名。</p>

<pre class="prettyprint lang-dart good-style">pageCount         // A field.
updatePageCount() // Consistent with pageCount.
toSomething()     // Consistent with Iterable's toList().
asSomething()     // Consistent with List's asMap().
Point             // A familiar concept.</pre>

<pre class="prettyprint lang-dart bad-style">renumberPages()      // Confusingly different from pageCount.
convertToSomething() // Inconsistent with toX() precedent.
wrappedAsSomething() // Inconsistent with asX() precedent.
Cartesian            // Unfamiliar to most users.</pre>

<p>总的目的是充分利用用户已经知道的内容。
这里包括他们所了解的问题领域，所熟悉的核心库，以及你自己 API 那部分。
基于以上这些内容，他们在使用之前，不需要学习大量的新知识。</p>

<h3 id="避免-缩写">
<a id="避免-缩写" class="anchor" href="#%E9%81%BF%E5%85%8D-%E7%BC%A9%E5%86%99" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 缩写。</h3>

<p>只使用广为人知的缩写，对于特有领域的缩写，请避免使用。
如果要使用，请 <a href="/guides/language/effective-dart/style#identifiers">正确的指定首字母大小写</a>。</p>

<pre class="prettyprint lang-dart good-style">pageCount
buildRectangles
IOStream
HttpRequest</pre>

<pre class="prettyprint lang-dart bad-style">numPages    // "num" is an abbreviation of number(of)
buildRects
InputOutputStream
HypertextTransferProtocolRequest</pre>

<h3 id="推荐-把最具描述性的名词放到最后">
<a id="推荐-把最具描述性的名词放到最后" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E6%8A%8A%E6%9C%80%E5%85%B7%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%9A%84%E5%90%8D%E8%AF%8D%E6%94%BE%E5%88%B0%E6%9C%80%E5%90%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 把最具描述性的名词放到最后。</h3>

<p>最后一个词应该是最具描述性的东西。
你可以在其前面添加其他单词，例如形容词，以进一步描述该事物。</p>

<pre class="prettyprint lang-dart good-style">pageCount             // A count (of pages).
ConversionSink        // A sink for doing conversions.
ChunkedConversionSink // A ConversionSink that's chunked.
CssFontFaceRule       // A rule for font faces in CSS.</pre>

<pre class="prettyprint lang-dart bad-style">numPages                  // Not a collection of pages.
CanvasRenderingContext2D  // Not a "2D".
RuleFontFaceCss           // Not a CSS.</pre>

<h3 id="考虑-尽量让代码看起来像普通的句子">
<a id="考虑-尽量让代码看起来像普通的句子" class="anchor" href="#%E8%80%83%E8%99%91-%E5%B0%BD%E9%87%8F%E8%AE%A9%E4%BB%A3%E7%A0%81%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%83%8F%E6%99%AE%E9%80%9A%E7%9A%84%E5%8F%A5%E5%AD%90" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 尽量让代码看起来像普通的句子。</h3>

<p>当你不知道如何命名 API 的时候，
使用你的 API 编写些代码，试着让代码看起来像普通的句子。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (code-like-prose)"?>
<pre class="prettyprint lang-dart good-style">// "If errors is empty..."
if (errors.isEmpty) ...

// "Hey, subscription, cancel!"
subscription.cancel();

// "Get the monsters where the monster has claws."
monsters.where((monster) =&gt; monster.hasClaws);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (code-like-prose)" replace="/ as bool//g"?>
<pre class="prettyprint lang-dart bad-style">// Telling errors to empty itself, or asking if it is?
if (errors.empty) ...

// Toggle what? To what?
subscription.toggle();

// Filter the monsters with claws *out* or include *only* those?
monsters.filter((monster) =&gt; monster.hasClaws);</pre>

<p>尝试着使用你自己的 API，并且阅读写出来的代码，可以帮助你为 API 命名，但是不要过于冗余。
添加文章和其他词性以强制名字读起来就像语法正确的句子一样，是没用的。</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (code-like-prose-overdone)"?>
<pre class="prettyprint lang-dart bad-style">if (theCollectionOfErrors.isEmpty) ...

monsters.producesANewSequenceWhereEach((monster) =&gt; monster.hasClaws);</pre>

<h3 id="推荐-使用名词短语来命名不是布尔类型的变量和属性">
<a id="推荐-使用名词短语来命名不是布尔类型的变量和属性" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E4%B8%8D%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用名词短语来命名不是布尔类型的变量和属性。</h3>

<p>读者关注属性是<em>什么</em>。
如果用户更关心<em>如何</em>确定一个属性，则很可能应该是一个使用动词短语命名函数。</p>

<pre class="prettyprint lang-dart good-style">list.length
context.lineWidth
quest.rampagingSwampBeast</pre>

<pre class="prettyprint lang-dart bad-style">list.deleteItems</pre>

<h3 id="推荐-使用非命令式动词短语命名布尔类型的变量和属性">
<a id="推荐-使用非命令式动词短语命名布尔类型的变量和属性" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用非命令式动词短语命名布尔类型的变量和属性。</h3>

<p>布尔名称通常用在控制语句中当做条件，
因此你要应该让这个名字在控制语句中读起来语感很好。比较下面的两个：</p>

<pre class="prettyprint lang-dart">if (window.closeable) ...  // Adjective.
if (window.canClose) ...   // Verb.</pre>

<p>好的名字往往以某一种动词作为开头：</p>

<ul>
  <li>
    <p>“to be” 形式： <code class="highlighter-rouge">isEnabled</code>， <code class="highlighter-rouge">wasShown</code>， <code class="highlighter-rouge">willFire</code>。 
    就目前来看，这些时做常见的。</p>
  </li>
  <li>
    <p>一个 [辅助动词][]: <code class="highlighter-rouge">hasElements</code>， <code class="highlighter-rouge">canClose</code>，
<code class="highlighter-rouge">shouldConsume</code>， <code class="highlighter-rouge">mustSave</code>。</p>
  </li>
  <li>
    <p>一个主动动词： <code class="highlighter-rouge">ignoresInput</code>， <code class="highlighter-rouge">wroteFile</code>。
因为经常引起歧义，所以这种形式比较少见。
<code class="highlighter-rouge">loggedResult</code> 是一个不好的命名，因为它的意思可能是：
“whether or not a result was logged” 或者 “the result that was logged”。
<code class="highlighter-rouge">closingConnection</code> 的意思可能是：
“whether the connection is closing” 或者 “the connection that is closing”。
<em>只有</em> 当名字可以预期的时候才使用主动动词。</p>
  </li>
</ul>

<p>可以使用命令式动词来区分布尔变量名字和函数名字。
一个布尔变量的名字不应该看起来像一个命令，告诉这个对象做什么事情。
原因在于访问一个变量的属性并没有修改对象的状态。
（如果这个属性<em>确实</em>修改了对象的状态，则它应该是一个函数。）</p>

<pre class="prettyprint lang-dart good-style">isEmpty
hasElements
canClose
closesWindow
canShowPopup
hasShownPopup</pre>

<pre class="prettyprint lang-dart bad-style">empty         // Adjective or verb?
withElements  // Sounds like it might hold elements.
closeable     // Sounds like an interface.
              // "canClose" reads better as a sentence.
closingWindow // Returns a bool or a window?
showPopup     // Sounds like it shows the popup.</pre>

<aside class="alert alert-info">
  <p>这条规则有一个例外。 Angular组件中的输入属性有时会使用命令式动词来表示布尔设置器，
因为这些 setter 是在模板中调用的，而不是从其它 Dart 代码中调用的。</p>

</aside>

<h3 id="考虑-省略命名布尔参数的动词">
<a id="考虑-省略命名布尔参数的动词" class="anchor" href="#%E8%80%83%E8%99%91-%E7%9C%81%E7%95%A5%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E8%AF%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 省略命名布尔<em>参数</em>的动词。</h3>

<p>提炼于上一条规则。对于命名布尔参数，
没有动词的名称通常看起来更加舒服。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (omit-verb-for-bool-param)"?>
<pre class="prettyprint lang-dart good-style">Isolate.spawn(entryPoint, message, paused: false);
var copy = List.from(elements, growable: true);
var regExp = RegExp(pattern, caseSensitive: false);</pre>

<h3 id="考虑-为布尔属性或变量取肯定含义的名字">
<a id="考虑-为布尔属性或变量取肯定含义的名字" class="anchor" href="#%E8%80%83%E8%99%91-%E4%B8%BA%E5%B8%83%E5%B0%94%E5%B1%9E%E6%80%A7%E6%88%96%E5%8F%98%E9%87%8F%E5%8F%96%E8%82%AF%E5%AE%9A%E5%90%AB%E4%B9%89%E7%9A%84%E5%90%8D%E5%AD%97" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 为布尔属性或变量取“肯定”含义的名字。</h3>

<p>大多数布尔值名称具有概念形式上的“肯定”和“否定”，
前者感觉更现实基本描述，后者是对基本描述的否定，例如：
“open” 和 “closed”， “enabled” 和 “disabled”，等等。
通常后者的名称字面上有个前缀，用来否定前者：
“visible” 和 “<em>in</em>-visible”，
“connected” 和 “<em>dis</em>-connected”，
“zero” 和 “<em>non</em>-zero”。</p>

<p>当选择 <code class="highlighter-rouge">true</code> 代表两种情况中的其中一种情况
在布尔的两种情况中，当选择 <code class="highlighter-rouge">true</code> 代表其中一种情况，
或使用这种情况作为属性名称时，更倾向使用“肯定”或基本描述的方式。
布尔成员通常嵌套在逻辑表达式中，包括否定运算符。
如果属性本身读起来想是个“否定”的，
这将让读者耗费更多精力去阅读双重否定及理解代码的含义。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (positive)"?>
<pre class="prettyprint lang-dart good-style">if (socket.isConnected &amp;&amp; database.hasData) {
  socket.write(database.read());
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (positive)"?>
<pre class="prettyprint lang-dart bad-style">if (!socket.isDisconnected &amp;&amp; !database.isEmpty) {
  socket.write(database.read());
}</pre>

<p>上面规则中有一个例外，就是“否定”用户绝大多数用到的形式是。
选择“肯定”方式，将会迫使在他们到处使用 <code class="highlighter-rouge">!</code> 对属性进行取反操作。
这样相反，属性应该使用“否定”形式进行命名。</p>

<p>对于一些属性，没有明显的“肯定”形式。
文档已经刷新 “saved” 到磁盘，或者 “<em>un</em>-changed”？
文档还未属性 “<em>un</em>-saved” 到磁盘，或者 “changed”？
在模棱两可的情况下，倾向于选择不太可能被用户否定或较短的名字。</p>

<h3 id="推荐-使用命令式动词短语来命名带有副作用的函数或者方法">
<a id="推荐-使用命令式动词短语来命名带有副作用的函数或者方法" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用命令式动词短语来命名带有副作用的函数或者方法。</h3>

<p>函数通常返回一个结果给调用者，并且执行一些任务或者带有副作用。
在像 Dart 这种命令式语言中，调用函数通常为了实现其副作用：
可能改变了对象的内部状态、
产生一些输出内容、或者和外部世界沟通等。</p>

<p>这种类型的成员应该使用命令式动词短语来命名，强调
该成员所执行的任务。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (verb-for-func-with-side-effect)"?>
<pre class="prettyprint lang-dart good-style">list.add("element");
queue.removeFirst();
window.refresh();</pre>

<p>这样，调用的方法读起来会让人觉得是一个执行命令。</p>

<h3 id="考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数">
<a id="考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数" class="anchor" href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%88%96%E8%80%85%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数。</h3>

<p>虽然这些函数可能也有副作用，但是其主要目的是返回一个数据给调用者。
如果该函数无需参数通常应该是一个 getter 。
有时候获取一个属性则需要一些参数，比如，
<code class="highlighter-rouge">elementAt()</code> 从集合中返回一个数据，但是需要一个指定返回那个数据的参数。</p>

<p>在<em>语法</em>上看这是一个函数，其实<em>严格来说</em>其返回的是集合中的一个属性，
应该使用一个能够表示该函数返回的是<em>什么</em>的词语来命名。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (noun-for-func-returning-value)"?>
<pre class="prettyprint lang-dart good-style">var element = list.elementAt(3);
var first = list.firstWhere(test);
var char = string.codeUnitAt(4);</pre>

<p>这条规则比前一条要宽松一些。有时候一些
函数没有副作用，但仍然使用一个动词短语来命名，例如：
<code class="highlighter-rouge">list.take()</code> 或者 <code class="highlighter-rouge">string.split()</code>。</p>

<h3 id="考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视">
<a id="考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视" class="anchor" href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95%E8%8B%A5%E6%9E%9C%E4%BD%A0%E5%B8%8C%E6%9C%9B%E5%AE%83%E7%9A%84%E6%89%A7%E8%A1%8C%E8%83%BD%E8%A2%AB%E9%87%8D%E8%A7%86" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 使用命令式动词短语命名一个函数或方法，若果你希望它的执行能被重视。</h3>

<p>当一个成员产生的结果没有额外的影响，它通常应该使用一个 getter 或者一个名词短语描述来命名，用于描述它返回的结果。
但是，有时候执行产生的结果很重要。
它可能容易导致运行时故障，或者使用重量级的资源（例如，网络或文件 I/O）。
在这种情况下，你希望调用者考虑成员在进行的工作，
这时，为成员提供描述该工作的动词短语。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (verb-for-func-with-work)"?>
<pre class="prettyprint lang-dart good-style">var table = database.downloadData();
var packageVersions = packageGraph.solveConstraints();</pre>

<p>但请注意，此准则比前两个更宽松。操作执行工作的实现细节通常与调用这无关，
并且性能和健壮性是随时间经常改变的。
大多数情况下，根据成员为调用者做了“什么”来命名，而不是“如何”做。</p>

<h3 id="避免-在方法命名中使用-get-开头">
<a id="避免-在方法命名中使用-get-开头" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E4%B8%AD%E4%BD%BF%E7%94%A8-get-%E5%BC%80%E5%A4%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在方法命名中使用 <code class="highlighter-rouge">get</code> 开头。</h3>

<p>在大多数情况下，getter 方法名称中应该移除 <code class="highlighter-rouge">get</code> 。
例如，定义一个名为 <code class="highlighter-rouge">breakfastOrder</code> 的 getter 方法，
来替代名为 <code class="highlighter-rouge">getBreakfastOrder()</code> 的方法。</p>

<p>即使成员因为需要传入参数或者 getter 不适用，
而需要通过方法来实现，也应该避免使用 <code class="highlighter-rouge">get</code> 开头。
与之前的准则一样：</p>

<ul>
  <li>
    <p>如果调用者主要关心的是方法的返回值，只需删除 <code class="highlighter-rouge">get</code> 并使用<a href="#prefer-a-noun-phrase-or-non-imperative-verb-phrase-for-a-function-or-method-if-returning-a-value-is-its-primary-purpose">名词短语</a>命名，
如 <code class="highlighter-rouge">breakfastOrder()</code> 。</p>
  </li>
  <li>
    <p>如果调用者关心的是正在完成的工作，请使用<a href="#consider-an-imperative-verb-phrase-for-a-function-or-method-if-you-want-to-draw-attention-to-the-work-it-performs">动名词短语</a>命名，
这种情况下应该选择一个更能准确描述工作的动名词，而不是使用 <code class="highlighter-rouge">get</code> 命名，
如 <code class="highlighter-rouge">create</code>， <code class="highlighter-rouge">download</code>， <code class="highlighter-rouge">fetch</code>， <code class="highlighter-rouge">calculate</code>， <code class="highlighter-rouge">request</code>， <code class="highlighter-rouge">aggregate</code>，等等。</p>
  </li>
</ul>

<h3 id="推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数">
<a id="推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-to___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用 <code class="highlighter-rouge">to___()</code> 来命名把对象的状态转换到一个新的对象的函数。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/use_to_and_as_if_applicable.html">use_to_and_as_if_applicable</a></p>

<p>一个转换函数返回一个新的对象，里面包含一些原对象的状态，但通常新对象的形式或表现方式与原对象不同。
核心库有一个约定，这些类型结果的方法名应该以 <code class="highlighter-rouge">to</code> 作为开头。</p>

<p>如果要定义一个转换函数，遵循该约定是非常有益的。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (to___)"?>
<pre class="prettyprint lang-dart good-style">list.toSet();
stackTrace.toString();
dateTime.toLocal();</pre>

<h3 id="推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数">
<a id="推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-as___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%8E%9F%E6%9D%A5%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用 <code class="highlighter-rouge">as___()</code> 来命名把原来对象转换为另外一种表现形式的函数。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/use_to_and_as_if_applicable.html">use_to_and_as_if_applicable</a></p>

<p>转换函数提供的是“快照功能”。返回的对象有自己的数据副本，
修改原来对象的数据不会改变返回的对象中的数据。
另外一种函数返回的是同一份数据的另外一种表现形式，返回的是一个新的对象，
但是其内部引用的数据和原来对象引用的数据一样。
修改原来对象中的数据，新返回的对象中的数据也一起被修改。</p>

<p>这种函数在核心库中被命名为 <code class="highlighter-rouge">as___()</code>。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (as___)"?>
<pre class="prettyprint lang-dart good-style">var map = table.asMap();
var list = bytes.asFloat32List();
var future = subscription.asFuture();</pre>

<h3 id="避免-在方法或者函数名称中描述参数">
<a id="避免-在方法或者函数名称中描述参数" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E4%B8%AD%E6%8F%8F%E8%BF%B0%E5%8F%82%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在方法或者函数名称中描述参数。</h3>

<p>在调用代码的时候可以看到参数，所以无需再次显示参数了。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-desc-param-in-func)"?>
<pre class="prettyprint lang-dart good-style">list.add(element);
map.remove(key);</pre>

<pre class="prettyprint lang-dart bad-style">list.addElement(element)
map.removeKey(key)</pre>

<p>但是，对于具有多个类似的函数的时候，使用参数名字可以消除歧义，
这个时候应该带有参数名字。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (desc-param-in-func-ok)"?>
<pre class="prettyprint lang-dart good-style">map.containsKey(key);
map.containsValue(value);</pre>

<h3 id="要-在命名参数时遵循现有的助记符约定">
<a id="要-在命名参数时遵循现有的助记符约定" class="anchor" href="#%E8%A6%81-%E5%9C%A8%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E6%97%B6%E9%81%B5%E5%BE%AA%E7%8E%B0%E6%9C%89%E7%9A%84%E5%8A%A9%E8%AE%B0%E7%AC%A6%E7%BA%A6%E5%AE%9A" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 在命名参数时，遵循现有的助记符约定。</h3>

<p>单字母命名没有直接的启发性，但是几乎所有通用类型都使用时情况就不一样了。
幸运的是，它们大多数以一致的助记方式在使用，这些约定如下：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">E</code> 用于集合中的 <strong>元素</strong> 类型:</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-e)" replace="/\n\n/\n/g"?>
    <pre class="prettyprint lang-dart good-style">class IterableBase&lt;E&gt; {}
class List&lt;E&gt; {}
class HashSet&lt;E&gt; {}
class RedBlackTree&lt;E&gt; {}</pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">K</code> 和 <code class="highlighter-rouge">V</code> 分别用于关联集合中的 <strong>key</strong> 和 <strong>value</strong> 类型：</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-k-v)" replace="/\n\n/\n/g"?>
    <pre class="prettyprint lang-dart good-style">class Map&lt;K, V&gt; {}
class Multimap&lt;K, V&gt; {}
class MapEntry&lt;K, V&gt; {}</pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">R</code> 用于函数或类方法的 <strong>返回值</strong> 类型。 这种情况并不常见，
但有时会出现在typedef中，或实现访问者模式的类中：</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-r)"?>
    <pre class="prettyprint lang-dart good-style">abstract class ExpressionVisitor&lt;R&gt; {
  R visitBinary(BinaryExpression node);
  R visitLiteral(LiteralExpression node);
  R visitUnary(UnaryExpression node);
}</pre>
  </li>
  <li>
    <p>除此以外，对于具有单个类型参数的泛型，如果助记符能在周围类型中明显表达泛型含义，
请使用<code class="highlighter-rouge">T</code>，<code class="highlighter-rouge">S</code> 和 <code class="highlighter-rouge">U</code> 。
这里允许多个字母嵌套且不会与周围命名产生歧义。例如：</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-t)"?>
    <pre class="prettyprint lang-dart good-style">class Future&lt;T&gt; {
  Future&lt;S&gt; then&lt;S&gt;(FutureOr&lt;S&gt; onValue(T value)) =&gt; ...
}</pre>

    <p>这里，通常 <code class="highlighter-rouge">then&lt;S&gt;()</code> 方法使用 <code class="highlighter-rouge">S</code> 避免 <code class="highlighter-rouge">Future&lt;T&gt;</code> 中的 <code class="highlighter-rouge">T</code> 产生歧义。</p>
  </li>
</ul>

<p>如果上述情况都不合适，则可以使用另一个单字母助记符名称或描述性的名称：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-graph)"?>
<pre class="prettyprint lang-dart good-style">class Graph&lt;N, E&gt; {
  final List&lt;N&gt; nodes = [];
  final List&lt;E&gt; edges = [];
}

class Graph&lt;Node, Edge&gt; {
  final List&lt;Node&gt; nodes = [];
  final List&lt;Edge&gt; edges = [];
}</pre>

<p>在实践中，以上的约定涵盖了大多数参数类型。</p>

<h2 id="库">
<a id="库" class="anchor" href="#%E5%BA%93" aria-hidden="true"><span class="octicon octicon-link"></span></a>库</h2>

<p>以 ( <code class="highlighter-rouge">_</code> ) 开头的成员只能在其库的内部被访问，是库的私有成员。
这是 Dart 语言的内置特性，不仅仅是惯例。</p>

<h3 id="推荐-使用私有声明">
<a id="推荐-使用私有声明" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E5%A3%B0%E6%98%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用私有声明。</h3>

<p>库中的公开声明—顶级定义或者在类中定义—是一种信号，
表示其他库可以并应该访问这些成员。
同时公开声明也是一种你的库需要实现的契约，
当使用这些成员的时候，应该实现其宣称的功能。</p>

<p>如果某个成员你不希望公开，则在成员名字之前添加一个 <code class="highlighter-rouge">_</code> 即可。
减少公开的接口让你的库更容易维护，也让用户更加容易掌握你的库如何使用。</p>

<p>另外，分析工具还可以分析出没有用到的私有成员定义，然后告诉你可以删除这些无用的代码。
私有成员第三方代码无法调用而你自己在库中也没有使用，所以是无用的代码。</p>

<h3 id="考虑-声明多个类在一个库中">
<a id="考虑-声明多个类在一个库中" class="anchor" href="#%E8%80%83%E8%99%91-%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E4%B8%AD" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 声明多个类在一个库中。</h3>

<p>一些其他语言，比如 Java。将文件结构和类结构进行捆绑&amp;mdash：每个文件仅能定义一个顶级类。
Dart 没有这样的限制。库与类是相互独立的。如果多个类，顶级变量，以及函数，他们再逻辑上
归为同一类，那么将他们包含到单一的库中，这样做是非常棒的。</p>

<p>将多个类组织到一个库中，就可以使用一些有用的模式。因为在 Dart 中私有特性是在库级别上有效，
而不是在类级别，基于这个模式你可以定义类似于 C++ 中的 “friend” 类。所有定义在同一个库中
的类可以互相访问彼此的私有成员，但库以外的代码无法发访问。</p>

<p>当然，该规则并不意味着你<em>应该</em>将你所有的类组织到一个庞大单一的库中，规则只是说允许你将多
个类组织到一个库中。</p>

<h2 id="类">
<a id="类" class="anchor" href="#%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>类</h2>

<p>Dart是一种 “纯粹的” 面向对象语言，因为所有对象都是类的实例。但是 Dart 并没有要求所有代码都
定义到类中— 类似在面向过程或函数的语言，你可以在 Dart 中定义顶级变量，常量，以及函数。</p>

<h3 id="避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类">
<a id="避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BA%86%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E8%80%8C%E5%8E%BB%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8D%95%E4%B8%80%E6%88%90%E5%91%98%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 避免为了使用一个简单的函数而去定义一个单一成员的抽象类</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/one_member_abstracts.html">one_member_abstracts</a></p>

<p>和 Java 不同，Dart 拥有一等公民的函数，闭包，以及它们简洁的使用语法。如果你仅仅是需要一个
类似于回调的功能，那么使用函数即可。 例如如果你正在定义一个类，并且它仅拥有一个毫无意义名称的
抽象成员，如 <code class="highlighter-rouge">call</code> 或 <code class="highlighter-rouge">invoke</code> ，那么这时你很可能只是需要一个函数。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (one-member-abstract-class)"?>
<pre class="prettyprint lang-dart good-style">typedef Predicate&lt;E&gt; = bool Function(E element);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (one-member-abstract-class)"?>
<pre class="prettyprint lang-dart bad-style">abstract class Predicate&lt;E&gt; {
  bool test(E element);
}</pre>

<h3 id="避免-定义仅包含静态成员的类">
<a id="避免-定义仅包含静态成员的类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%AE%9A%E4%B9%89%E4%BB%85%E5%8C%85%E5%90%AB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 定义仅包含静态成员的类。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_classes_with_only_static_members.html">avoid_classes_with_only_static_members</a></p>

<p>在 Java 和 C# 中，所有的定义<em>必须</em>要在类中。所有常常会看到一些这样的类，这些
类中仅仅放置了些静态成员。其他类仅用于命名空间—一种为一堆成员提供共享
前缀将它们相互关联或避免名称冲突的方法。</p>

<p>Dart 拥有一等公民的函数，变量，以及常量，所以你不<em>需要</em>通过类来定义这些东西。
如果你想要的是一个命名空间，那么使用库即可。库支持导入前缀和显示/隐藏组合器。
这些功能强大的工具可让代码的开发者以最适合他们的方式处理名称冲突。</p>

<p>如果函数或变量在逻辑上与类无关，那么应该将其置于顶层。如果担心名称冲突，
那么请为其指定更精确的名称，或将其移动到可以使用前缀导入的单独库中。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (class-only-static)"?>
<pre class="prettyprint lang-dart good-style">DateTime mostRecent(List&lt;DateTime&gt; dates) {
  return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);
}

const _favoriteMammal = 'weasel';</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (class-only-static)"?>
<pre class="prettyprint lang-dart bad-style">class DateUtils {
  static DateTime mostRecent(List&lt;DateTime&gt; dates) {
    return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);
  }
}

class _Favorites {
  static const mammal = 'weasel';
}</pre>

<p>通常在 Dart 中，类定义了<em>一类对象</em>。一个类型，如果类型从来没有被初始化，
那么这是另一种的代码气息。</p>

<p>当然，这并不是一条硬性规则。对于常量和类似枚举的类型，将它们组合在一个类
中看起来也是很自然。</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (class-only-static-exception)"?>
<pre class="prettyprint lang-dart good-style">class Color {
  static const red = '#f00';
  static const green = '#0f0';
  static const blue = '#00f';
  static const black = '#000';
  static const white = '#fff';
}</pre>

<h3 id="避免-集成一个不期望被集成的类">
<a id="避免-集成一个不期望被集成的类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E9%9B%86%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB%E9%9B%86%E6%88%90%E7%9A%84%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 集成一个不期望被集成的类。</h3>

<p>如果一个类的构造函数从生成构造函数被更改为工厂构造函数，则调用该构造函数的任何子类构造函数都
将失败。 此外，如果一个类改变了它在 <code class="highlighter-rouge">this</code> 上调用的自己的方法，那么覆盖这些方法并期望他们在
某些点被调用的子类再调用时会失败。</p>

<p>以上两种情况都意味着一个类需要考虑是否要允许被子类化。这种情况可以通过文档注释来沟通，或者为类
提供一个显示命名，如 <code class="highlighter-rouge">IterableBase</code>。如果该类的作者不这样做，最好假设你<em>不</em>能够继承这个类。
否则，后续对它的修改可能会破坏你的代码。</p>

<h3 id="要-把能够继承的说明添加到文档中如果这个类可以继承">
<a id="要-把能够继承的说明添加到文档中如果这个类可以继承" class="anchor" href="#%E8%A6%81-%E6%8A%8A%E8%83%BD%E5%A4%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%B4%E6%98%8E%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%96%87%E6%A1%A3%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 把能够继承的说明添加到文档中，如果这个类可以继承。</h3>

<p>该规则是上条规则的结果。如果允许你的类被子类化，请在文档中说明情况。使用 <code class="highlighter-rouge">Base</code> 作为类名的后缀，
或者在类的注释文档中注明。</p>

<h3 id="避免-去实现一个不期望成为接口的类该类不想作为接口被实现">
<a id="避免-去实现一个不期望成为接口的类该类不想作为接口被实现" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E6%88%90%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E8%AF%A5%E7%B1%BB%E4%B8%8D%E6%83%B3%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E8%A2%AB%E5%AE%9E%E7%8E%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 去实现一个不期望成为接口的类（该类不想作为接口被实现）。</h3>

<p>隐式接口是Dart中的一个强大工具，当一个类中可以很容易的推断出一些已经约定的有特征的实现时，
隐式接口可以避免重复定义这个类的约定。</p>

<p>但是通过类的隐式接口实现的新类，新类会与这个类产生非常紧密的耦合。也就是说，对于接口类的
<em>任何</em>修改，你实现的新类都会被破坏。例如，向类中添加新成员通常是安全，不会产生破坏性的改变。
但是如果你实现了这个类的接口，那么现在你的类会产生一个静态错误，因为它缺少了新方法的实现。</p>

<p>库的维护人员需要能够在不破坏用户代码的情况下迭代现有的累。如果把每个类都看待成是暴露给用户
的接口，用户可以自由的实现，这时修改这些类将变得非常困难。反过来，这个困难将导致你的库
迭代缓慢，从而无法适应新的需求。</p>

<p>为了给你的类的开发人员提供更多的余地，避免实现隐式接口，除非那些类明确需要实现。否则，
你可能会引入开发者没有预料到的耦合情况，这样可能会在没有意识到的情况下破坏你的代码。</p>

<h3 id="要-对支持接口的类在文档注明">
<a id="要-对支持接口的类在文档注明" class="anchor" href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 对支持接口的类在文档注明</h3>

<p>如果你的类可以被用作接口，那么将这个情况注明到类的文档中。</p>

<h3 id="避免-去-mixin-一个不期望被-mixin-的类">
<a id="避免-去-mixin-一个不期望被-mixin-的类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%8E%BB-mixin-%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB-mixin-%E7%9A%84%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 去 mixin 一个不期望被 mixin 的类</h3>

<p>如果在一个类中定义了一个之前从来没有被定义过的构造函数，那么这会破坏已被混入的其他类。
在类中，这样看似无害的变化，并且对 mixin 的限制和并不为其他人说知。作者可能会添加一
个构造函数但并没有意识到它会破坏你 mixin 到它里的类。</p>

<p>与子类化一样，这意味着需要考虑一个类是否允许用于 mixin。如果该类没有文档注释或明显的名称，
如 <code class="highlighter-rouge">IterableMixin</code> ，你应该假设你不能 mix 这个类。</p>

<h3 id="要-对支持-mixin-的类在文档注明">
<a id="要-对支持-mixin-的类在文档注明" class="anchor" href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81-mixin-%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 对支持 mixin 的类在文档注明</h3>

<p>在类的文档中要提到，这个类是否可以或必须用于 mixin 。如果你的类被设计只作为 mixin 使用，
那么考虑在类名以 <code class="highlighter-rouge">Mixin</code> 结尾。</p>

<h2 id="构造函数">
<a id="构造函数" class="anchor" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造函数</h2>

<p>通过声明与类具有相同名称的函数以及附加可选的标识符来创建 Dart 构造函数。 后者附加标示符的
构造函数被称为<em>命名构造函数</em>。</p>

<h3 id="考虑-在类支持的情况下指定构造函数为--const">
<a id="考虑-在类支持的情况下指定构造函数为--const" class="anchor" href="#%E8%80%83%E8%99%91-%E5%9C%A8%E7%B1%BB%E6%94%AF%E6%8C%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%8C%87%E5%AE%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA--const" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 在类支持的情况下，指定构造函数为  <code class="highlighter-rouge">const</code>。</h3>

<p>如果一个类，它所有的字段都是 final ，并且构造函数出了初始化他们之外没有任
何其他操作，那么可以将其作为 <code class="highlighter-rouge">const</code> 构造函数。这样就能够允许用户在需要
常量的位置创建类的实例—一些大型的常量，switch case 语句，默认参数中，
以及其他的情况。</p>

<p>如果没有显示的指定为 <code class="highlighter-rouge">const</code> 构造函数，那么就无法实现上述目的。</p>

<p>但需要注意的是，构造函数被指定为 <code class="highlighter-rouge">const</code> ，那它就是公共 API 的一中承诺。
如果后面将构造函数更改为非 <code class="highlighter-rouge">const</code> ，那么在常量表达式中调用它的代码就会被破坏。
如果不想做出这样的承诺，那么就不要指定它为 <code class="highlighter-rouge">const</code> 构造函数。在实际运用中，
<code class="highlighter-rouge">const</code> 构造函数对于简单的，不可变的数据记录类是非常有用的。</p>

<h2 id="成员">
<a id="成员" class="anchor" href="#%E6%88%90%E5%91%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员</h2>

<p>成员属于对象，成员可以是方法或实例变量。</p>

<h3 id="推荐-指定字段或顶级变量为-final-">
<a id="推荐-指定字段或顶级变量为-final-" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E6%88%96%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E4%B8%BA-final-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 指定字段或顶级变量为 <code class="highlighter-rouge">final</code> 。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/prefer_final_fields.html">prefer_final_fields</a></p>

<p>状态不可变—随着时间推移状态不发生变化—有益于程序员推理。类和库中可变状态量越少，类和库
越容易维护。</p>

<p>当然，可变数据是非常有用的。但是，如果并不需要可变数据，应该尽可能默认指定字段和顶级变量为 <code class="highlighter-rouge">final</code> 。</p>

<h3 id="要-对概念上是访问的属性使用-getter-方法">
<a id="要-对概念上是访问的属性使用-getter-方法" class="anchor" href="#%E8%A6%81-%E5%AF%B9%E6%A6%82%E5%BF%B5%E4%B8%8A%E6%98%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8-getter-%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 对概念上是访问的属性使用 getter 方法。</h3>

<p>判定一个成员应该是一个 getter 而不是一个方法是一件具有挑战性的事情。它虽然微妙，但对于好的
API 设计是非常重要的，也导致本规则会很长。其他的一些语言文化中回避了getter。他们只有在几乎
类似于字段访问的时候才会使用—它仅仅是根据对象的状态进行微小的计算。任何比这更复杂或
重量级的东西得到带有 <code class="highlighter-rouge">()</code> 的名字后面，给出一种”计算的操作在这！”信号。因为 <code class="highlighter-rouge">.</code> 后面只跟名称
意味着是”字段”。</p>

<p>Dart 与他们 <em>不</em> 同。在 Dart 中，所有点名称都可以是进行计算的成员调用。字段是特殊的—
字段的 getter 的实现是有语言提供的。换句话说，在 Dart 中，getter 不是”访问特别慢的字段”；
字段是”访问特别快的 getter “。</p>

<p>即便如此，选择 getter 而不是方法对于调用者来说是一个重要信号。信号大致的意思成员的操作
“类似于字段”。至少原则上可以这么认为，只要调用者清楚，这个操作<em>可以</em>使用字段来实现。这意味着：</p>

<ul>
  <li>
    <p><strong>操作返回一个结果但不接受任何参数。</strong></p>
  </li>
  <li>
    <p><strong>调用者主要关系结果。</strong> 如果希望调用者关系操作产生结果的方式多于产生的结果，那么为操作
提供一个方法，使用描述工作的动词作为方法的名称。</p>

    <p>这并<em>不</em>意味着操作必须特别快才能成为 getter 方法。<code class="highlighter-rouge">IterableBase.length</code> 复杂度是
 <code class="highlighter-rouge">O(n)</code>，是可以的。使用 getter 方法进行重要计算是没问题的。但是如果它做了<em>超</em>大量的工作，
 你可能需要通过一个描述其功能的动词的方法来引起使用者的注意。</p>

    <pre class="prettyprint lang-dart bad-style">connection.nextIncomingMessage; // Does network I/O.
expression.normalForm; // Could be exponential to calculate.</pre>
  </li>
  <li>
    <p><strong>操作不会产生使用者可见的副作用。</strong> 在程序中访问一个实际的字段不会改变对象或者其他的状态。
操作不会产生输出，写入文件等。同样 getter 方法也一样。</p>

    <p>注意关键字”使用者可见”。只要调用者不<em>关心</em>这些副作用。getter 方法可以修改隐藏状态或产生
带外副作用。 getter 方法可以惰性计算和存储他们的结果，写入缓存， log 等。这样是没有问题的。</p>

    <pre class="prettyprint lang-dart bad-style">stdout.newline; // Produces output.
list.clear; // Modifies object.</pre>
  </li>
  <li>
    <p><strong>操作是<em>幂等</em>的。</strong> “幂等”是一个怪异的词，在这里可以理解为调用多次操作，除非在这些操作
调用之间某些状态被修改，否则每次操作都产生相同的结果。（很明显，如果在调用之间向列表添加
元素， <code class="highlighter-rouge">list.length</code> 会产生不同的结果。）</p>

    <p>这里”相同的结果”并不意味着 getter 方法必须一定要在每次调用成功后都返回相同的对象。如果
按这样的要求会迫使很过 getter 方法需要进行脆弱的缓存（brittle caching），这样就否定了
使用 getter 的全部意义。常见的非常好的示例是，每次调用一个 getter 方法返回一个新的 
future 或 list。重点在于， future 完成后返回相同的值，list 包含了相同的元素。</p>

    <p>换句话说，<em>调用者关系的</em>是结果值应该相等。</p>

    <pre class="prettyprint lang-dart bad-style">DateTime.now; // New result each time.</pre>
  </li>
  <li>
    <p><strong>结果对象不用公开所有原始对象的状态。</strong> 一个字段仅公开对象的一部分。如果操作返回的结果
公开了原始对象的整个状态，那么把该操作作为 <a href="#prefer-naming-a-method-to___-if-it-copies-the-objects-state-to-a-new-object"><code class="highlighter-rouge">to___()</code></a> 或 <a href="#prefer-naming-a-method-as___-if-it-returns-a-different-representation-backed-by-the-original-object"><code class="highlighter-rouge">as___()</code></a> 方法
可能会更好。</p>
  </li>
</ul>

<p>如果操作符合上述描述，那么它应该是一个 getter 方法。看似满足这一系列要求的成员并不多，但实际上
会超出你的想象。许多操作只是对某些状态进行一些计算，其中大多数能够，并且也应该作为 getter 方法。</p>

<pre class="prettyprint lang-dart good-style">rectangle.area;
collection.isEmpty;
button.canShow;
dataSet.minimumValue;</pre>

<h3 id="要-对概念上是修改的属性使用-setter-方法">
<a id="要-对概念上是修改的属性使用-setter-方法" class="anchor" href="#%E8%A6%81-%E5%AF%B9%E6%A6%82%E5%BF%B5%E4%B8%8A%E6%98%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8-setter-%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 对概念上是修改的属性使用 setter 方法。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/use_setters_to_change_properties.html">use_setters_to_change_properties</a></p>

<p>判定一个成员应该是一个 setter 而不是一个方法与 getter 的判定一样。两者的操作都应该是
“类似于字段”的操作。</p>

<p>对于 setter 方法，”类似于字段”意味着：</p>

<ul>
  <li>
    <p><strong>操作只有一个参数，不会返回结果。</strong></p>
  </li>
  <li>
    <p><strong>操作会更改对象中的某些状态。</strong></p>
  </li>
  <li>
    <p><strong>操作是<em>幂等</em>的。</strong> 使用相同的值调用相同的 setter 两次，就调用者而言，第二次不应该执
行任何操作。在内部，也许你会得到一些无效的缓存或者多次的日志记录。没关系，从调用者的角度
来看，第二次调用似乎没做任何事情。</p>
  </li>
</ul>

<pre class="prettyprint lang-dart good-style">rectangle.width = 3;
button.visible = false;</pre>

<h3 id="不要-在没有对应的-getter-的情况下定义-setter">
<a id="不要-在没有对应的-getter-的情况下定义-setter" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84-getter-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%9A%E4%B9%89-setter" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 在没有对应的 getter 的情况下定义 setter。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_setters_without_getters.html">avoid_setters_without_getters</a></p>

<p>用户将 getter 和 setter 视为一个对象的可见属性。一个 “dropbox” 属性可以被写入但无法读
取，会令人感到困惑。并且也混淆了他们对属性如何工作的直观理解。 例如，没有 getter 的 setter 
意味着你可以使用 <code class="highlighter-rouge">=</code> 来修改它，但却不能使用 <code class="highlighter-rouge">+=</code> 。</p>

<p>本规则意义并<em>不</em>是说，你需要先添加一个 getter 才被允许添加 setter ，对象通常不应该暴露出
多余的状态。如果某个对象的某个状态可以修改但不能以相同的方式访问，请改用方法实现。</p>

<aside class="alert alert-info">
  <p>这条规则有一处例外。在<a href="https://webdev.dartlang.org/angular">Angular</a> 组件类上，从模板调用的初始化组件 setter 可以公开。
通常，这些 setter 是不打算在 Dart 中调用的，也就不需要相应的 getter。（如果在 Dart 代码
中使用它们，那么它们<em>应该</em>有一个对应的 getter 。）</p>

</aside>

<h3 id="避免-从返回类型为-bool--double--int-或-num-的成员返回-null-">
<a id="避免-从返回类型为-bool--double--int-或-num-的成员返回-null-" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%BB%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%BA-bool--double--int-%E6%88%96-num-%E7%9A%84%E6%88%90%E5%91%98%E8%BF%94%E5%9B%9E-null-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 从返回类型为 <code class="highlighter-rouge">bool</code> ， <code class="highlighter-rouge">double</code> ， <code class="highlighter-rouge">int</code> 或 <code class="highlighter-rouge">num</code> 的成员返回 <code class="highlighter-rouge">null</code> 。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_returning_null.html">avoid_returning_null</a></p>

<p>尽管在 Dart 中所有类型都可以为空，但用户几乎都不会考虑它们是 <code class="highlighter-rouge">null</code> 的情况。而小写命名是
源于 “Java primitive” 的提倡。</p>

<p>在 API 中有一个 “nullable primitive” 类型可能会偶尔被用到。例如，指出 map 中不存在的 
key 值，但这样的应用并不多见。</p>

<p>如果确实有成员可能返回 <code class="highlighter-rouge">null</code> 的类型，请在文档中注明，以及在什么情况下回返回 <code class="highlighter-rouge">null</code>。</p>

<h3 id="避免-为了书写流畅而从方法中返回-this-">
<a id="避免-为了书写流畅而从方法中返回-this-" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%B8%BA%E4%BA%86%E4%B9%A6%E5%86%99%E6%B5%81%E7%95%85%E8%80%8C%E4%BB%8E%E6%96%B9%E6%B3%95%E4%B8%AD%E8%BF%94%E5%9B%9E-this-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 为了书写流畅，而从方法中返回 <code class="highlighter-rouge">this</code> 。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_returning_this.html">avoid_returning_this</a></p>

<p>方法级联是链接方法调用的更好的解决方式。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (cascades)"?>
<pre class="prettyprint lang-dart good-style">var buffer = StringBuffer()
  ..write('one')
  ..write('two')
  ..write('three');</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (cascades)"?>
<pre class="prettyprint lang-dart bad-style">var buffer = StringBuffer()
    .write('one')
    .write('two')
    .write('three');</pre>

<h2 id="类型">
<a id="类型" class="anchor" href="#%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型</h2>

<p>程序中的类型用于约束流入代码各位置的<em>值</em>的不同类型。类型会出现在两种位置：声明中的<em>类型注解（type 
annotations）</em>和<em>泛型调用（generic invocations）</em>的类型参数。</p>

<p>当你想到<em>静态类型</em>时，通常会联想到类型注解。类型注解可以用于为变量，参数，字段，或者返回值
声明类型。在下面的示例中，<code class="highlighter-rouge">bool</code> 和 <code class="highlighter-rouge">String</code> 是类型注解。他们位于代码静态声明结构的前面，
并且他们不会在运行时”执行”。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (annotate-declaration)"?>
<pre class="prettyprint lang-dart">bool isEmpty(String parameter) {
  bool result = parameter.length == 0;
  return result;
}</pre>

<p>泛型调用可以是一个字面量集合的定义，一个泛型类构造函数的调用，或者一个泛型方法的调用。在下面
的示例中，<code class="highlighter-rouge">num</code> 和 <code class="highlighter-rouge">int</code> 都是泛型调用的类型参数。虽然它们是类型，但是它们也是第一类实体，
在运行时会被提升并传递给调用。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (annotate-invocation)"?>
<pre class="prettyprint lang-dart">var lists = &lt;num&gt;[1, 2];
lists.addAll(List&lt;num&gt;.filled(3, 4));
lists.cast&lt;int&gt;();</pre>

<p>这里再强调一下”泛型调用”，因为类型参数<em>也</em>可以出现在类型注解中：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (annotate-type-arg)"?>
<pre class="prettyprint lang-dart">List&lt;int&gt; ints = [1, 2];</pre>

<p>这里，<code class="highlighter-rouge">int</code> 是一个类型参数，但它出现在了类型注解中，而不是泛型调用。通常来说不需要担心这种情况，
但在几个地方，对于类型的运用是泛型调用而不是类型注解有不同的指导。</p>

<p>在大多数地方，Dart 允许省略类型注解并根据附近的上下文提供推断类型，或默认指定为 <code class="highlighter-rouge">dynamic</code> 
类型。Dart 同时具有类型推断和 <code class="highlighter-rouge">dynamic</code> 类型的情况，导致对代码中 “untyped” 的含义产生一些
混淆。意思就是不<em>写</em>类型就是动态类型吗？为避免这种混淆，应该避免说 “untyped” ，而是使用以下
术语：</p>

<ul>
  <li>
    <p>如果代码是<em>类型注解</em>，则在代码中显式写入类型。</p>
  </li>
  <li>
    <p>如果代码的类型是<em>推断</em>的，则不必写类型注解，Dart 会自己会找出它的类型。规则不考虑推断可能
会失败的情况，在一些地方，推理失败会产生一个静态错误。在其他情况下，Dart 使用 <code class="highlighter-rouge">dynamic</code>
作为备选类型。</p>
  </li>
  <li>
    <p>如果代码是<em>动态类型</em>，那么它的静态类型就是特殊的 <code class="highlighter-rouge">dynamic</code> 类型。代码可以明确地注解为 
<code class="highlighter-rouge">dynamic</code> 类型，也可以由 Dart 进行推断。</p>
  </li>
</ul>

<p>换句话说，对于代码的类型是 <code class="highlighter-rouge">dynamic</code> 类型还是其他类型，在类型注解或类型推断中是正交的。</p>

<p>类型推断是一种强大的工具，可以免于编写和阅读那些明显或无趣的类型。在明显的情况下省略类型也会
引起读者注意那些被显式注解的重要类型，例如强制类型转换。</p>

<p>显示类型也是代码健壮和高可维护的关键。它们定义了API的静态形状。注明并约束流入代码各位置的值
的不同类型值。</p>

<p>这些准则促使我们在简洁性和明确性，灵活性和安全性之间找到了最佳平衡。在决定要编写类型钱前
您需要回答这两问题：</p>

<ul>
  <li>我应该书写哪种类型那？因为我期望这些类型在代码中最好是被看到！</li>
  <li>我应该书写哪种类型那？因为推理无法为我提供这些类型！</li>
</ul>

<p>这些规则可以帮助你回答第一个问题：</p>

<ul>
  <li><a href="#%E6%8E%A8%E8%8D%90-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%8E%E6%98%BE%E7%9A%84%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%92%8C%E5%85%AC%E5%85%B1%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><strong>推荐</strong> 为类型不明显的公共字段和顶级变量指定类型注解。</a></li>
  <li><a href="#%E8%80%83%E8%99%91-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%8E%E6%98%BE%E7%9A%84%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E5%92%8C%E7%A7%81%E6%9C%89%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><strong>考虑</strong> 为类型不明显的私有字段和私有顶级变量指定类型注解。</a></li>
  <li><a href="#%E9%81%BF%E5%85%8D-%E4%B8%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><strong>避免</strong> 为初始化的局部变量添加类型注解。</a></li>
  <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8A%E6%B3%A8%E8%A7%A3%E6%8E%A8%E6%96%AD%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><strong>避免</strong> 在函数表达式上注解推断的参数类型。</a></li>
  <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%B3%9B%E5%9E%8B%E8%B0%83%E7%94%A8%E4%B8%AD%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%97%E4%BD%99%E4%BD%BF%E7%94%A8"><strong>避免</strong> 在泛型调用中参数类型的冗余使用。</a></li>
</ul>

<p>这些规则涵盖了第二个问题：</p>

<ul>
  <li><a href="#%E8%A6%81-%E5%9C%A8-dart-%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><strong>要</strong> 在 Dart 推断类型错误的时候进行类型注解。</a></li>
  <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-dynamic-%E6%B3%A8%E8%A7%A3%E6%9B%BF%E6%8D%A2%E6%8E%A8%E6%96%AD%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%83%85%E5%86%B5"><strong>推荐</strong> 使用 <code class="highlighter-rouge">dynamic</code> 注解替换推断失败的情况。</a></li>
</ul>

<p>其余指南涵盖了和类型有关的其他具体问题。</p>

<h3 id="推荐-为类型不明显的公共字段和公共顶级变量指定类型注解">
<a id="推荐-为类型不明显的公共字段和公共顶级变量指定类型注解" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%8E%E6%98%BE%E7%9A%84%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%92%8C%E5%85%AC%E5%85%B1%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 为类型不明显的公共字段和公共顶级变量指定类型注解。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/prefer_typing_uninitialized_variables.html">prefer_typing_uninitialized_variables</a></p>

<p>类型注解是关于如何使用库的重要文档。它们在程序的区域之间形成边界以隔离类型错误来源。思考下面代码：</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (type_annotate_public_apis)"?>
<pre class="prettyprint lang-dart bad-style">install(id, destination) =&gt; ...</pre>

<p>在这里，无法判断：这个 <code class="highlighter-rouge">id</code> 是什么，一个字符串？<code class="highlighter-rouge">destination</code> 又是什么，一个字符串还是一个 
<code class="highlighter-rouge">File</code> 对象？方法是同步的还是异步的？下面的实例会清晰很多：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (type_annotate_public_apis)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;bool&gt; install(PackageId id, String destination) =&gt; ...</pre>

<p>但在一些情况下，类型非常明显，根本没有指明类型的必要：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (inferred)"?>
<pre class="prettyprint lang-dart good-style">const screenWidth = 640; // Inferred as int.</pre>

<p>这里的”明显”并没有精确的定义，下面这些可以作为很好的参考：</p>

<ul>
  <li>字面量。</li>
  <li>构造函数调用。</li>
  <li>引用的其他类型明确的常量。</li>
  <li>数字和字符串的简单表达式。</li>
  <li>读者熟悉的工厂方法，如 <code class="highlighter-rouge">int.parse()</code>， <code class="highlighter-rouge">Future.wait()</code> 等。</li>
</ul>

<p>如有疑问，请添加类型注解。即使类型很明显，但可能任然希望明确的注解。如果推断类型依赖于其他库中的值
或声明，可能需要添加注解的声明。这样自己的API就不会因为其他库的修改而被悄无声息的改变了类型。</p>

<h3 id="考虑-为类型不明显的私有字段和私有顶级变量指定类型注解">
<a id="考虑-为类型不明显的私有字段和私有顶级变量指定类型注解" class="anchor" href="#%E8%80%83%E8%99%91-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%8E%E6%98%BE%E7%9A%84%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E5%92%8C%E7%A7%81%E6%9C%89%E9%A1%B6%E7%BA%A7%E5%8F%98%E9%87%8F%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 为类型不明显的私有字段和私有顶级变量指定类型注解。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/prefer_typing_uninitialized_variables.html">prefer_typing_uninitialized_variables</a></p>

<p>为公共声明进行类型注解有助于使用代码的<em>用户</em>，为私有成员进行类型注解有助于代码的<em>维护人员</em>。
私有声明的范围较小，熟悉与它相关代码的人才需要知道它们的声明类型。在这里就更倾向于省略注解，
通过推理得到私有声明的类型。这也是为什么该规则相对于上一条更为柔和。</p>

<p>如果你认为初始化表达式—无论是什么表达式—足够清晰，那么可以省略它的注解。但是
如果你认为注解有助于使代码更清晰，那么你应该加上这个注解。</p>

<h3 id="避免-为初始化的局部变量添加类型注解">
<a id="避免-为初始化的局部变量添加类型注解" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%B8%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 为初始化的局部变量添加类型注解。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/omit_local_variable_types.html">omit_local_variable_types</a></p>

<p>局部变量，特别是现代的函数往往很少，范围也很小。省略局部变量类型会将读者的注意力集中在变量的
<em>名称</em>及初始化值上。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (omit-types-on-locals)"?>
<pre class="prettyprint lang-dart good-style">List&lt;List&lt;Ingredient&gt;&gt; possibleDesserts(Set&lt;Ingredient&gt; pantry) {
  var desserts = &lt;List&lt;Ingredient&gt;&gt;[];
  for (var recipe in cookbook) {
    if (pantry.containsAll(recipe)) {
      desserts.add(recipe);
    }
  }

  return desserts;
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (omit-types-on-locals)"?>
<pre class="prettyprint lang-dart bad-style">List&lt;List&lt;Ingredient&gt;&gt; possibleDesserts(Set&lt;Ingredient&gt; pantry) {
  List&lt;List&lt;Ingredient&gt;&gt; desserts = &lt;List&lt;Ingredient&gt;&gt;[];
  for (List&lt;Ingredient&gt; recipe in cookbook) {
    if (pantry.containsAll(recipe)) {
      desserts.add(recipe);
    }
  }

  return desserts;
}</pre>

<p>如果局部变量没有初始值设定项，那么就无法判断它的类型了。这种情况下，最好是为变量加上类型注解。
否则，你的到的会是一个 <code class="highlighter-rouge">dynamic</code> 类型，并失去静态类型的好处。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (uninitialized-local)"?>
<pre class="prettyprint lang-dart good-style">List&lt;AstNode&gt; parameters;
if (node is Constructor) {
  parameters = node.signature;
} else if (node is Method) {
  parameters = node.parameters;
}</pre>

<h3 id="避免-在函数表达式上注解推断的参数类型">
<a id="避免-在函数表达式上注解推断的参数类型" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8A%E6%B3%A8%E8%A7%A3%E6%8E%A8%E6%96%AD%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在函数表达式上注解推断的参数类型。</h3>

<p>匿名函数几乎都是作为一个回调参数类型立即传递给一个方法。（如果一个匿名函数没有立即使用，那么
有必要为它进行命名声明。）当在类型化上下文中创建函数表达式时，Dart 会尝试根据预期类型来推断
函数的参数类型。</p>

<p>例如，当为 <code class="highlighter-rouge">Iterable.map()</code> 传递一个函数表达式时，函数的参数类型会根据 <code class="highlighter-rouge">map()</code> 回调中所
期望的类型进行推断。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (func-expr-no-param-type)"?>
<pre class="prettyprint lang-dart good-style">var names = people.map((person) =&gt; person.name);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (func-expr-no-param-type)"?>
<pre class="prettyprint lang-dart bad-style">var names = people.map((Person person) =&gt; person.name);</pre>

<p>在极少数周围环境不明确的情况下，当无法为一个或多个函数提供参数类型时，需要为它们进行类型注解。</p>

<h3 id="避免-在泛型调用中参数类型的冗余使用">
<a id="避免-在泛型调用中参数类型的冗余使用" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%B3%9B%E5%9E%8B%E8%B0%83%E7%94%A8%E4%B8%AD%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%97%E4%BD%99%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在泛型调用中参数类型的冗余使用。</h3>

<p>如果推断的类型结果与指定相同，那么参数指定就是多余的。如果泛型调用是初始化变量，或者是函数参数，
那么推断会自动为其填充类型：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (redundant)"?>
<pre class="prettyprint lang-dart good-style">Set&lt;String&gt; things = Set();</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (redundant)"?>
<pre class="prettyprint lang-dart bad-style">Set&lt;String&gt; things = Set&lt;String&gt;();</pre>

<p>在这里，初始化过程中，构造函数参数的类型是通过变量的类型注解推断得到的。</p>

<p>在其他情况下，如果没有足够的信息来推断类型时，应该为参数添加类型注解：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (explicit)"?>
<pre class="prettyprint lang-dart good-style">var things = Set&lt;String&gt;();</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (explicit)"?>
<pre class="prettyprint lang-dart bad-style">var things = Set();</pre>

<p>在这里，由于变量没有类型注解，因此没有足够的上下文来确定创建的 <code class="highlighter-rouge">Set</code> 是什么类型，因此应该显式
的提供参数类型。</p>

<h3 id="要-在-dart-推断类型错误的时候进行类型注解">
<a id="要-在-dart-推断类型错误的时候进行类型注解" class="anchor" href="#%E8%A6%81-%E5%9C%A8-dart-%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 在 Dart 推断类型错误的时候进行类型注解。</h3>

<p>有时候，Dart 推断的并不是你期望的类型。例如，你可能希望初始化变量的类型是超类型（父类的类型），
以便后续可以为变量赋值一些同级别的其它变量：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (inferred-wrong)"?>
<pre class="prettyprint lang-dart good-style">num highScore(List&lt;num&gt; scores) {
  num highest = 0;
  for (var score in scores) {
    if (score &gt; highest) highest = score;
  }
  return highest;
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (inferred-wrong)" replace="/ +\/\/ ignore: .*?\n//g"?>
<pre class="prettyprint lang-dart bad-style">num highScore(List&lt;num&gt; scores) {
  var highest = 0;
  for (var score in scores) {
    if (score &gt; highest) highest = score;
  }
  return highest;
}</pre>

<p>在这里，如果 <code class="highlighter-rouge">scores</code> 中包含双精度数字，如 <code class="highlighter-rouge">[1.2]</code> ，那么 <code class="highlighter-rouge">highest</code> 的赋值会失败，因为 
<code class="highlighter-rouge">highest</code> 的推断类型是 <code class="highlighter-rouge">int</code> ，而不是 <code class="highlighter-rouge">num</code> 。在这些情况下，就需要显式注解了。</p>

<h3 id="推荐-使用-dynamic-注解替换推断失败的情况">
<a id="推荐-使用-dynamic-注解替换推断失败的情况" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-dynamic-%E6%B3%A8%E8%A7%A3%E6%9B%BF%E6%8D%A2%E6%8E%A8%E6%96%AD%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%83%85%E5%86%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用 <code class="highlighter-rouge">dynamic</code> 注解替换推断失败的情况。</h3>

<p>Dart 允许在许多地方省略类型注解，并尝试推断类型。在某些情况下，如果推断失败了，会默认指定为 
<code class="highlighter-rouge">dynamic</code> 类型。如果 <code class="highlighter-rouge">dynamic</code> 类型与期望相同，那么从技术的角度来讲，这是获取类型最简洁
的方式。</p>

<p>但是，这种方式是最不<em>清晰</em>的。任何一个阅读代码的人，当看到一个类型确实的成员时，是没有办法
知道，编写的人是希望它是 <code class="highlighter-rouge">dynamic</code> 类型，还是期望它是其他的什么类型，或者阅读的人就简单的
认为是编写的人忘记了指定类型。</p>

<p>当 <code class="highlighter-rouge">dynamic</code> 是你期望的类型，就应该指明它，这样能让你的意图更清晰。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (prefer-dynamic)"?>
<pre class="prettyprint lang-dart good-style">dynamic mergeJson(dynamic original, dynamic changes) =&gt; ...</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (prefer-dynamic)"?>
<pre class="prettyprint lang-dart bad-style">mergeJson(original, changes) =&gt; ...</pre>

<aside class="alert alert-info">

  <p>在Dart 2之前，本规则恰恰是相反的：<em>不要</em> 为隐性类型的成员指定 <code class="highlighter-rouge">dynamic</code> 注解。基于强类型系统
和类型推断，现在的开发者更希望 Dart 的行为类似于推断的静态类型语言。基于这种心理模型，我们发现
代码区域慢慢地失去了静态类型所具有的安全及性能。</p>

</aside>

<h3 id="推荐-使-function-类型注解的特征更明显">
<a id="推荐-使-function-类型注解的特征更明显" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF-function-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%89%B9%E5%BE%81%E6%9B%B4%E6%98%8E%E6%98%BE" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使 function 类型注解的特征更明显</h3>

<p>成员类型注解标识符只有 <code class="highlighter-rouge">Function</code> ，注解标识符不包括任何返回值类型或参数类型，请参考
专门的 <a href="https://api.dartlang.org/stable/dart-core/Function-class.html">Function</a> 类型说明。使用 <code class="highlighter-rouge">Function</code> 类型要稍微比使用 <code class="highlighter-rouge">dynamic</code> 更好些。
如果要使用 <code class="highlighter-rouge">Function</code> 来进行类型注解，注解类型应该包含函数的所有参数及返回值类型。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-Function)" replace="/(void )?Function(\(.*?\))?/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">bool isValid(String value, bool <span class="highlight">Function(String)</span> test) =&gt; ...</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (avoid-Function)" replace="/Function/[!$&!]/g"?>
<pre class="prettyprint lang-dart bad-style">bool isValid(String value, <span class="highlight">Function</span> test) =&gt; ...</pre>

<p>此条规则有个例外，如果期望一个类型能够表示多种函数类型的集合。例如，我们希望接受的可能是一个参数
的函数，也可能是两个参数的函数。由于 Dart 没有集合类型，所以没有办法为类似成员精确的指定类型，
这个时候通常只能使用 <code class="highlighter-rouge">dynamic</code>。但这里使用 <code class="highlighter-rouge">Function</code> 要稍微比使用 <code class="highlighter-rouge">dynamic</code> 更有帮助些：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (function-arity)" replace="/(void )?Function(\(.*?\))?/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">void handleError(<span class="highlight">void Function()</span> operation, <span class="highlight">Function</span> errorHandler) {
  try {
    operation();
  } catch (err, stack) {
    if (errorHandler is <span class="highlight">Function(Object)</span>) {
      errorHandler(err);
    } else if (errorHandler is <span class="highlight">Function(Object, StackTrace)</span>) {
      errorHandler(err, stack);
    } else {
      throw ArgumentError("errorHandler has wrong signature.");
    }
  }
}</pre>

<h3 id="不要-为-setter-方法指定返回类型">
<a id="不要-为-setter-方法指定返回类型" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%B8%BA-setter-%E6%96%B9%E6%B3%95%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 为 setter 方法指定返回类型。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_return_types_on_setters.html">avoid_return_types_on_setters</a></p>

<p>在 Dart 中，setter 永远返回 <code class="highlighter-rouge">void</code> 。为 setter 指定类型没有意义。</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (avoid_return_types_on_setters)"?>
<pre class="prettyprint lang-dart bad-style">void set foo(Foo value) { ... }</pre>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid_return_types_on_setters)"?>
<pre class="prettyprint lang-dart good-style">set foo(Foo value) { ... }</pre>

<h3 id="不要-使用弃用的-typedef-语法">
<a id="不要-使用弃用的-typedef-语法" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8%E5%BC%83%E7%94%A8%E7%9A%84-typedef-%E8%AF%AD%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用弃用的 typedef 语法。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/prefer_generic_function_type_aliases.html">prefer_generic_function_type_aliases</a></p>

<p>Dart 有两种为函数类型定义命名 typedef 注解语法。 原始语法如下：</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (old-typedef)"?>
<pre class="prettyprint lang-dart bad-style">typedef int Comparison&lt;T&gt;(T a, T b);</pre>

<p>该语法有几个问题：</p>

<ul>
  <li>
    <p>无法为一个<em>泛型</em>函数类型指定名称。在上面的例子中，typedef 自己就是泛型。如果在代码中去
引用 <code class="highlighter-rouge">Comparison</code> 却不指定参数类型，那么你会隐式的得到一个 <code class="highlighter-rouge">int Function(dynamic, dynamic)</code>
类型的函数，<em>而不是</em> <code class="highlighter-rouge">int Function&lt;T&gt;(T, T)</code> 。在实际应用中虽然不常用，但是在极少数
情况下是很重要的。</p>
  </li>
  <li>
    <p>参数中的单个标识符会被认为是参数名称，而不是参数类型。参考下面代码：</p>

    <?code-excerpt "misc/lib/effective_dart/design_bad.dart (typedef-param)"?>
    <pre class="prettyprint lang-dart bad-style">typedef bool TestNumber(num);</pre>

    <p>大多数用户希望这是一个接受 <code class="highlighter-rouge">num</code> 返回 <code class="highlighter-rouge">bool</code> 的函数类型。但它实际上是一个接受<em>任何</em>
对象（<code class="highlighter-rouge">dynamic</code>）返回 <code class="highlighter-rouge">bool</code> 的类型。 “num” 是参数<em>名称</em>（ 它除了被用在 typedef 的
声明代码中，再也没有其他作用）。这个错误在 Dart 中存在了很长时间。</p>
  </li>
</ul>

<p>新语法如下所示：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (new-typedef)"?>
<pre class="prettyprint lang-dart good-style">typedef Comparison&lt;T&gt; = int Function(T, T);</pre>

<p>如果想在方法中包含参数名称，可以这样做：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (new-typedef-param-name)"?>
<pre class="prettyprint lang-dart good-style">typedef Comparison&lt;T&gt; = int Function(T a, T b);</pre>

<p>新语法可以表达旧语法所表达的任何内容，并且避免了单个标识符会被认为是参数类型的常见错误。同一个函数
类型语法（typedef 中 <code class="highlighter-rouge">=</code> 之后的部分）允许出现在任何类型注解可以能出现的地方。这样在程序的任何位置，
我们都可以以一致的方式来书写函数类型。</p>

<p>为了避免对已有代码产生破坏， typedef 的旧语法依旧支持。但已被弃用。</p>

<h3 id="推荐-优先使用内联函数类型而后是-typedef-">
<a id="推荐-优先使用内联函数类型而后是-typedef-" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%80%8C%E5%90%8E%E6%98%AF-typedef-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 优先使用内联函数类型，而后是 typedef 。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_private_typedef_functions.html">avoid_private_typedef_functions</a></p>

<p>在 Dart 1中，如果要在字段，变量或泛型参数中使用函数类型，首选需要使用 typedef 定义这个类型。
Dart 2中任何使用类型注解的地方都可以使用函数类型声明语法：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (function-type)"  replace="/(bool|void) Function\(Event\)/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">class FilteredObservable {
  final <span class="highlight">bool Function(Event)</span> _predicate;
  final List&lt;<span class="highlight">void Function(Event)</span>&gt; _observers;

  FilteredObservable(this._predicate, this._observers);

  <span class="highlight">void Function(Event)</span> notify(Event event) {
    if (!_predicate(event)) return null;

    <span class="highlight">void Function(Event)</span> last;
    for (var observer in _observers) {
      observer(event);
      last = observer;
    }

    return last;
  }
}</pre>

<p>如果函数类型特别长或经常使用，那么还是有必要使用 typedef 进行定义。但在大多数情况下，使用者
更希望知道函数使用时的真实类型，这样函数类型语法使它们清晰。</p>

<h3 id="考虑-在参数上使用函数类型语法">
<a id="考虑-在参数上使用函数类型语法" class="anchor" href="#%E8%80%83%E8%99%91-%E5%9C%A8%E5%8F%82%E6%95%B0%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%AF%AD%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 在参数上使用函数类型语法。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/use_function_type_syntax_for_parameters.html">use_function_type_syntax_for_parameters</a></p>

<p>在定义参数为函数类型时， Dart 具有特殊的语法。与 C 类似，使用参数名称作为函数参数的函数名：</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (function-type-param)"?>
<pre class="prettyprint lang-dart">Iterable&lt;T&gt; where(bool predicate(T element)) =&gt; ...</pre>

<p>在 Dart 2 添加函数类型语法之前，如果希望不通过 typedef 使用函数参数类型，上例是唯一的方法。
如今 Dart 已经可以为函数提供泛型注解，那么也可以将泛型注解用于函数类型参数中：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (function-type-param)"?>
<pre class="prettyprint lang-dart good-style">Iterable&lt;T&gt; where(bool Function(T) predicate) =&gt; ...</pre>

<p>虽然新语法稍微冗长一点，但是你必须使用新语法才能与其他位置的类型注解的语法保持一致。</p>

<h3 id="要-为类型是任何对象的参数使用-object-注解而不是-dynamic-">
<a id="要-为类型是任何对象的参数使用-object-注解而不是-dynamic-" class="anchor" href="#%E8%A6%81-%E4%B8%BA%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%BB%E4%BD%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8-object-%E6%B3%A8%E8%A7%A3%E8%80%8C%E4%B8%8D%E6%98%AF-dynamic-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 为类型是任何对象的参数使用 <code class="highlighter-rouge">Object</code> 注解，而不是 <code class="highlighter-rouge">dynamic</code> 。</h3>

<p>某些操作适用于任何对象。例如，<code class="highlighter-rouge">log()</code> 方法可以接受任何对象，并调用对象上的 <code class="highlighter-rouge">toString()</code> 方法。
在 Dart 中两种类型可以表示所有类型：<code class="highlighter-rouge">Object</code> 和 <code class="highlighter-rouge">dynamic</code> 。但是，他们传达的意义并不相同。
和 Java 或 C# 类似，要表示成员类型为所有对象，使用 <code class="highlighter-rouge">Object</code> 进行注解。</p>

<p>使用 <code class="highlighter-rouge">dynamic</code> 释放出一种复杂的信号。它可能意味着成员的类型集合不足以使用 Dart 类型系统表达，或者
是变量来源于操作过程中，以及其他范围外的静态类型系统，或者是你明确的希望成员类型在 runtime 中动态
确定。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (Object-vs-dynamic)"?>
<pre class="prettyprint lang-dart good-style">void log(Object object) {
  print(object.toString());
}

/// 返回一个表示 [arg] 参数的布尔值，[arg] 
/// 必须是字符串或布尔值。
bool convertToBool(dynamic arg) {
  if (arg is bool) return arg;
  if (arg is String) return arg == 'true';
  throw ArgumentError('Cannot convert $arg to a bool.');
}</pre>

<h3 id="要-使用-futurevoid-作为无法回值异步成员的返回类型">
<a id="要-使用-futurevoid-作为无法回值异步成员的返回类型" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-futurevoid-%E4%BD%9C%E4%B8%BA%E6%97%A0%E6%B3%95%E5%9B%9E%E5%80%BC%E5%BC%82%E6%AD%A5%E6%88%90%E5%91%98%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用 <code class="highlighter-rouge">Future&lt;void&gt;</code> 作为无法回值异步成员的返回类型。</h3>

<p>对于不返回值得同步函数，要使用 <code class="highlighter-rouge">void</code> 作为返回类型。对于需要等待的，但无返回值的异步方法方法，
使用 <code class="highlighter-rouge">Future&lt;void&gt;</code> 作为返回值类型。</p>

<p>你可能会见到使用 <code class="highlighter-rouge">Future</code> 或 <code class="highlighter-rouge">Future&lt;Null&gt;</code> 作为返回值类型，这是因为旧版本的 Dart 不允许
<code class="highlighter-rouge">void</code> 作为类型参数。既然现在允许了，那么就应该使用新的方式。使用新的方式能够更直接地匹配那些
已经指定了类型的同步函数，并在函数体中为调用者提供更好的错误检查。</p>

<p>对于一些异步函数，这些异步函数不会返回有用的值，而且不需要等待异步执行结束或不需要处理错误结果。
那么使用 <code class="highlighter-rouge">void</code> 作为这些异步函数的返回类型。</p>

<h3 id="避免-使用-futureort-作为返回类型">
<a id="避免-使用-futureort-作为返回类型" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%BD%BF%E7%94%A8-futureort-%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 使用 <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> 作为返回类型。</h3>

<p>如果一个方法接受了一个 <code class="highlighter-rouge">FutureOr&lt;int&gt;</code> 参数，那么<a href="https://en.wikipedia.org/wiki/Robustness_principle">参数接受的类型范围就会变大</a> 。使用者
可以使用 <code class="highlighter-rouge">int</code> 或者 <code class="highlighter-rouge">Future&lt;int&gt;</code> 来调用这个方法，所以调用这个方法时就不用把 <code class="highlighter-rouge">int</code> 包装到一个
<code class="highlighter-rouge">Future</code> 中再传到方法中。而在方法中这个参数一定会进行被解包处理。</p>

<p>如果是<em>返回</em>一个 <code class="highlighter-rouge">FutureOr&lt;int&gt;</code> 类型的值，那么方法调用者在做任何有意义的操作之前，需要检查
返回值是一个 <code class="highlighter-rouge">int</code> 还是 <code class="highlighter-rouge">Future&lt;int&gt;</code> （或者调用者仅 <code class="highlighter-rouge">await</code> 得到一个值，却把它当做了 
<code class="highlighter-rouge">Future</code> ）。返回值使用 <code class="highlighter-rouge">Future&lt;int&gt;</code> ，类型就清晰了。一个函数要么一直异步，要么一直是同步，
这样才能够让调用者更容易理解，否则这个函数很难被正确的使用。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (future-or)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;int&gt; triple(FutureOr&lt;int&gt; value) async =&gt; (await value) * 3;</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (future-or)"?>
<pre class="prettyprint lang-dart bad-style">FutureOr&lt;int&gt; triple(FutureOr&lt;int&gt; value) {
  if (value is int) return value * 3;
  return (value as Future&lt;int&gt;).then((v) =&gt; v * 3);
}</pre>

<p>对这条规则更准确的描述是，*仅在<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">逆变</a>位置使用 <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> *。参数是逆变（contravariant），
返回类型是协变（covariant）。在嵌套函数类型中，描述是相反的—如果一个参数自身就是函数参数类型，那么此时
回调函数的返回类型处于逆变位置，回调函数的参数是协变。这意味着回调中的函数类型可以返回 <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> ：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (future-or-contra)" replace="/FutureOr.S./[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">Stream&lt;S&gt; asyncMap&lt;T, S&gt;(
    Iterable&lt;T&gt; iterable, <span class="highlight">FutureOr&lt;S&gt;</span> Function(T) callback) async* {
  for (var element in iterable) {
    yield await callback(element);
  }
}</pre>

<h2 id="参数">
<a id="参数" class="anchor" href="#%E5%8F%82%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数</h2>

<p>在 Dart 中，可选参数可以是位置参数，也可以是命名参数，但不能两者都是。</p>

<h3 id="避免-布尔类型的位置参数">
<a id="避免-布尔类型的位置参数" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 布尔类型的位置参数。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_positional_boolean_parameters.html">avoid_positional_boolean_parameters</a></p>

<p>与其他类型不同，布尔值通常以字面量方式使用。数字值的通常可以包含在命名的常量里，但对于布尔值通常
喜欢直接传 <code class="highlighter-rouge">true</code> 和 <code class="highlighter-rouge">false</code> 。如果不清楚布尔值的含义，这样会造成调用者的代码不可读：</p>

<pre class="prettyprint lang-dart bad-style">new Task(true);
new Task(false);
new ListBox(false, true, true);
new Button(false);</pre>

<p>这里，应该考虑使用命名参数，命名构造函数或命名常量来阐明调用所执行的操作。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-positional-bool-param)"?>
<pre class="prettyprint lang-dart good-style">Task.oneShot();
Task.repeating();
ListBox(scroll: true, showScrollbars: true);
Button(ButtonState.enabled);</pre>

<p>请注意，这并不适用于 setter ，因为 setter 的名称能够清楚的阐明值得含义：</p>

<pre class="prettyprint lang-dart good-style">listBox.canScroll = true;
button.isEnabled = false;</pre>

<h3 id="避免-在调用者需要省略前面参数的方法中使用位置可选参数">
<a id="避免-在调用者需要省略前面参数的方法中使用位置可选参数" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E8%B0%83%E7%94%A8%E8%80%85%E9%9C%80%E8%A6%81%E7%9C%81%E7%95%A5%E5%89%8D%E9%9D%A2%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在调用者需要省略前面参数的方法中，使用位置可选参数。</h3>

<p>可选的位置参数应该具有逻辑性，前面参数应该比后面的参数使用更频繁。调用者不需要刻意的跳过或省略前面
的一个参数而为后面的参数赋值。如果需要省略前面参数，这种情况最好使用命名可选参数。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (omit-optional-positional)"?>
<pre class="prettyprint lang-dart good-style">String.fromCharCodes(Iterable&lt;int&gt; charCodes, [int start = 0, int end]);

DateTime(int year,
    [int month = 1,
    int day = 1,
    int hour = 0,
    int minute = 0,
    int second = 0,
    int millisecond = 0,
    int microsecond = 0]);

Duration(
    {int days = 0,
    int hours = 0,
    int minutes = 0,
    int seconds = 0,
    int milliseconds = 0,
    int microseconds = 0});</pre>

<h3 id="避免-强制参数去接受一个特定表示空参数的值">
<a id="避免-强制参数去接受一个特定表示空参数的值" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%BC%BA%E5%88%B6%E5%8F%82%E6%95%B0%E5%8E%BB%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E8%A1%A8%E7%A4%BA%E7%A9%BA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 强制参数去接受一个特定表示”空参数”的值。</h3>

<p>如果调用者在逻辑上省略了参数，那么建议使用可选参数的方式让这些参数能够实际性的被省略，而不是
强制让调用者去为他们传入 <code class="highlighter-rouge">null</code>，或者空字符串，或者是一些其他特殊的值来表示该参数”不需要传值”。</p>

<p>省略参数更加简洁，也有助于防止在调用者偶然地将 <code class="highlighter-rouge">null</code> 作为实际值传递到方法中而引起 bug。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-mandatory-param)"?>
<pre class="prettyprint lang-dart good-style">var rest = string.substring(start);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (avoid-mandatory-param)"?>
<pre class="prettyprint lang-dart bad-style">var rest = string.substring(start, null);</pre>

<h3 id="要-使用开始为闭区间结束为开区间的半开半闭区间作为接受范围">
<a id="要-使用开始为闭区间结束为开区间的半开半闭区间作为接受范围" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E5%BC%80%E5%A7%8B%E4%B8%BA%E9%97%AD%E5%8C%BA%E9%97%B4%E7%BB%93%E6%9D%9F%E4%B8%BA%E5%BC%80%E5%8C%BA%E9%97%B4%E7%9A%84%E5%8D%8A%E5%BC%80%E5%8D%8A%E9%97%AD%E5%8C%BA%E9%97%B4%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%97%E8%8C%83%E5%9B%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用开始为闭区间，结束为开区间的半开半闭区间作为接受范围。</h3>

<p>如果定义一个方法或函数来让调用者能够从某个整数索引序列中选择一系列元素或项，开始索引指向的元素
为选取的第一个元素，结束索引（可以为可选参数）指向元素的上一个元素为获取的最后一个元素。</p>

<p>这种方式与核心库一致。</p>

<?code-excerpt "misc/test/effective_dart_test.dart (param-range)" replace="/expect\(//g; /, \/\*\*\// \/\//g; /\);//g"?>
<pre class="prettyprint lang-dart good-style">[0, 1, 2, 3].sublist(1, 3) // [1, 2]
'abcd'.substring(1, 3) // 'bc'</pre>

<p>在这里保持一致尤为重要，因为这些参数通常是未命名参数。如果你的 API 中第二个参数使用了长度值，
而不是结束索引，那么在调用端是无法区分两者之间的差异的。</p>

<h2 id="相等">
<a id="相等" class="anchor" href="#%E7%9B%B8%E7%AD%89" aria-hidden="true"><span class="octicon octicon-link"></span></a>相等</h2>

<p>可能为类实现自定义相等的判定是比较棘手事情。用户对于对象的判等情况有着很深的直觉，同时像哈希表这样
的集合类型拥有一些细微的规则，包含在这些集合中的元素需要遵循这些规则。</p>

<h3 id="要-对重写--操作符的类重写-hashcode-方法">
<a id="要-对重写--操作符的类重写-hashcode-方法" class="anchor" href="#%E8%A6%81-%E5%AF%B9%E9%87%8D%E5%86%99--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E7%B1%BB%E9%87%8D%E5%86%99-hashcode-%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 对重写 <code class="highlighter-rouge">==</code> 操作符的类，重写 <code class="highlighter-rouge">hashCode</code> 方法。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/hash_and_equals.html">hash_and_equals</a></p>

<p>默认的哈希实现为对象提供了一个<em>身份</em>哈希—如果两个对象是完全相同的，那么它们通常具有
相同的哈希值。同样，<code class="highlighter-rouge">==</code> 的默认行为是比较两个对象的身份哈希。</p>

<p>如果你重写 <code class="highlighter-rouge">==</code> ，就意味着你可能有不同的对象要让你的类认为是”相等的”。<strong>任何两个对象要相等就
必须必须具有相同的哈希值。</strong> 否则，这两个对象就无法被 map 和其他基于哈希的集合识别为等效对象。</p>

<h3 id="要-让--操作符的相等遵守数学规则">
<a id="要-让--操作符的相等遵守数学规则" class="anchor" href="#%E8%A6%81-%E8%AE%A9--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E7%9B%B8%E7%AD%89%E9%81%B5%E5%AE%88%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 让 <code class="highlighter-rouge">==</code> 操作符的相等遵守数学规则。</h3>

<p>等价关系应该是：</p>

<ul>
  <li>
    <p><strong>自反性</strong>: <code class="highlighter-rouge">a == a</code> 应该始终返回 <code class="highlighter-rouge">true</code>。</p>
  </li>
  <li>
    <p><strong>对称性</strong>: <code class="highlighter-rouge">a == b</code> 应该与 <code class="highlighter-rouge">b == a</code> 的返回值相同。</p>
  </li>
  <li>
    <p><strong>传递性</strong>: If <code class="highlighter-rouge">a == b</code> 和 <code class="highlighter-rouge">b == c</code> 都返回 <code class="highlighter-rouge">true</code>，那么 <code class="highlighter-rouge">a == c</code>
也应该返回 <code class="highlighter-rouge">true</code> 。</p>
  </li>
</ul>

<h3 id="避免-为可变类自定义相等">
<a id="避免-为可变类自定义相等" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%B8%BA%E5%8F%AF%E5%8F%98%E7%B1%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E7%AD%89" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 为可变类自定义相等。</h3>

<p>定义 <code class="highlighter-rouge">==</code> 时，必须要定义 <code class="highlighter-rouge">hashCode</code> 。两者都需要考虑对象的字段。如果这些字段发生了变化，
则意味着对象的哈希值可能会改变。</p>

<p>大多数基于哈希的集合是无法预料元素哈希值的改变—他们假设元素对象的哈希值是永远不变的，
如果元素哈希值发生了改变，可能会出现不可预测的结果。</p>

<h3 id="不要-在自定义--操作符中检查-null-">
<a id="不要-在自定义--操作符中检查-null-" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89--%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%AD%E6%A3%80%E6%9F%A5-null-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 在自定义 <code class="highlighter-rouge">==</code> 操作符中检查 <code class="highlighter-rouge">null</code> 。</h3>

<p class="linter-rule">Linter rule: <a href="https://dart-lang.github.io/linter/lints/avoid_null_checks_in_equality_operators.html">avoid_null_checks_in_equality_operators</a></p>

<p>Dart 指定此检查是自动完成的，只有当右侧不是 <code class="highlighter-rouge">null</code> 时才调用 <code class="highlighter-rouge">==</code> 方法。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (eq-dont-check-for-null)" replace="/operator ==/[!$&!]/g" plaster?>
<pre class="prettyprint lang-dart good-style">class Person {
  final String name;
  // ···
  bool <span class="highlight">operator ==</span>(other) =&gt; other is Person &amp;&amp; name == other.name;

  int get hashCode =&gt; name.hashCode;
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (eq-dont-check-for-null)" replace="/\w+ != null/[!$&!]/g" plaster?>
<pre class="prettyprint lang-dart bad-style">class Person {
  final String name;
  // ···
  bool operator ==(other) =&gt; <span class="highlight">other != null</span> &amp;&amp; ...
}</pre>


          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/usage">&lang;&nbsp;&nbsp;使用</a>
      
    </li>
    <li class="next">
      
    </li>
  </ul>
</nav>


        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="container">
    <div class="content">
      <div class="text-center" martdown="1">
        <style>.menu .material-icons { font-size: 14px; }</style><ul class="menu">
          <li><a href="/terms">Terms</a></li>
          <li><a href="/security">Security</a></li>
          <li><a href="http://www.google.com/intl/en/policies/privacy/" class="no-automatic-external">Privacy</a></li>
          <li>Site&nbsp;<a href="http://creativecommons.org/licenses/by/3.0/" class="no-automatic-external">CC&nbsp;BY&nbsp;3.0</a></li>
          <li><a href="/about_zh_CN">关于 dart.dev 中文版</a></li>
          <li>
            <a href="https://github.com/dartchina/site-www-cn"
               title="该站在 GitHub 开源"
               class="no-automatic-external"><i class="fab fa-github fa-sm"></i></a>
            &nbsp;
            <a href="https://github.com/dartchina/site-www-cn/issues"
               title="为该站提交 issue"
               class="no-automatic-external"><i class="fas fa-bug fa-sm"></i></a>
            &nbsp;
            <a 
               title="Site built on 2019/05/13 04:12 PDT"
               
               class="no-automatic-external"><i class="fas fa-wrench fa-sm"></i></a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
