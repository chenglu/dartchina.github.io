<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="en_US" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Choose the kind of stream that's best for your application: single-subscription or broadcast.">
  <title>Single-Subscription vs. Broadcast Streams | Dart</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/touch-icon-iphone.png" rel="apple-touch-icon">
  <link href="/assets/touch-icon-ipad.png" rel="apple-touch-icon" sizes="76x76">
  <link href="/assets/touch-icon-iphone-retina.png" rel="apple-touch-icon" sizes="120x120">
  <link href="/assets/touch-icon-ipad-retina.png" rel="apple-touch-icon" sizes="152x152">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Single-Subscription vs. Broadcast Streams" />
  <meta name="twitter:description" content="Choose the kind of stream that's best for your application: single-subscription or broadcast." />

  <!-- Open Graph -->
  <meta property="og:title" content="Single-Subscription vs. Broadcast Streams" />
  <meta property="og:description" content="Choose the kind of stream that's best for your application: single-subscription or broadcast." />
  <meta property="og:url" content="https://www.dartlang.org/articles/libraries/broadcast-streams" />
  <meta property="og:image" content="https://www.dartlang.org/assets/shared/dart-logo-for-shares.png?2" />

  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,700' rel='stylesheet' type='text/css'>
  <link type="text/css" rel="stylesheet" href="/assets/style.css">
  
  <!--
    Why don't we use Dart here?

    The only scripting we use here is stuff like the on-click footnotes on the
    front page or resizing of the left nav. These happen to be use cases where
    JavaScript and jQuery are doing just fine. Dart is here for application
    programming, not page scripting.
   -->
  <script type="text/javascript" src="/assets/main.js"></script>
  
  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


</head>

  <body class="default obsolete">
    <header id="page-header">
  <nav id="mainnav">
  <div id="menu-toggle"><i class="icon icon-menu"></i></div>
  <a href="/" class="brand" title="Dart">
    <img src="/assets/shared/dart/logo+text/horizontal/default.svg" alt="Dart">
  </a>
  <ul>
    <li class="mainnav__get-started"><a href="/guides/get-started"><span>入门</span></a></li>
    <li><a href="/guides/language">语言</a></li>
    <li><a href="/guides/libraries">库</a></li>
    <li><a href="/tools">工具</a></li>
    
    
    <li class="dropdown">
      <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dart 2 <span class="caret"></span></a>
      <ul class="dropdown-menu">
        

<li><a href="https://v1-dartlang-org.firebaseapp.com/articles/libraries/broadcast-streams" class="no-automatic-external">1.24.3&nbsp;&nbsp;(archive)</a></li><li><a class="active">2.0.0&nbsp;&nbsp;(beta)</a></li>

        <li role="separator" class="divider"></li>
        <li><a href="/dart-2#migration">迁移指南</a></li>
      </ul>
    </li>
    
    <li class="searchfield">
      <form class="navbar-search" action="/search" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input type="search" name="q" id="q" autocomplete="off" placeholder="Search">
        <button type="submit"><i class="icon icon-search"></i></button>
      </form>
    </li>
  </ul>
</nav>

  
  <div class="alert alert-warning">
    <h4 class="text-center">
      Some of the content of this page might be out of date.
    </h4>
  </div>
  
</header>

    <main id="page-content">
      <div id="sidenav" class="">
  <div class="content">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/shared/dart/logo+text/horizontal/default.svg" alt="Dart">
    </a>

    <div class="sidenav__search">
      <p>
        <a href="/search">Search <i class="icon icon-search"></i></a>
      </p>
    </div>

    <ul>
      <li>
        <a class="btn btn-default" href="/guides/get-started">入门</a>
      </li>
    </ul>
    <h4 ><a href="/guides/language" title="语言">语言</a></h4>
  <ul><li >
          <a href="/guides/language/language-tour" title="概览">概览</a>
        </li>
        
        <li >
          <a href="/guides/language/effective-dart" title="Effective Dart">Effective Dart</a>
          <i class="icon icon-arrow"></i>
          <ul><li >
                <a href="/guides/language/effective-dart/style" title="风格">风格</a>
              </li><li >
                <a href="/guides/language/effective-dart/documentation" title="文档">文档</a>
              </li><li >
                <a href="/guides/language/effective-dart/usage" title="使用">使用</a>
              </li><li >
                <a href="/guides/language/effective-dart/design" title="设计">设计</a>
              </li>
          </ul><li >
          <a href="/samples" title="示例代码">示例代码</a>
        </li>
  </ul><h4 ><a href="/guides/libraries" title="库">库</a></h4>
  <ul><li >
          <a href="/guides/libraries/library-tour" title="概览">概览</a>
        </li>
  </ul><h4 ><a href="/guides/platforms" title="平台">平台</a></h4>
  <ul><li >
          <a href="https://flutter.io" title="移动端 (Flutter)">移动端 (Flutter)</a>
        </li><li >
          <a href="https://webdev.dartlang.org" title="web">web</a>
        </li><li >
          <a href="/dart-vm" title="服务器">服务器</a>
        </li>
  </ul><h4 ><a href="/guides/testing" title="测试">测试</a></h4>
  <ul>
  </ul><h4 >资源</h4>
  <ul><li >
          <a href="/install" title="安装">安装</a>
        </li><li >
          <a href="/codelabs" title="Codelabs">Codelabs</a>
        </li><li >
          <a href="/tutorials" title="学习指南">学习指南</a>
        </li><li class="active">
          <a href="/articles" title="文章">文章</a>
        </li><li >
          <a href="/tools" title="工具">工具</a>
        </li><li >
          <a href="/community" title="社区支持">社区支持</a>
        </li>
  </ul>
  </div>
</div>

      
<div id="toc">
  <div class="content">
    <h4>目录
      <a href="#page-content" title="Back to top" class="pull-right"><i class="icon icon-caret-up"></i></a>
    </h4>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#introduction">Introduction</a></li>
<li class="toc-entry toc-h2"><a href="#subscriptions">Subscriptions</a></li>
<li class="toc-entry toc-h2"><a href="#single-subscription-streams">Single-subscription streams</a>
<ul>
<li class="toc-entry toc-h3"><a href="#creating-single-subscription-streams">Creating single-subscription streams</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#broadcast-streams">Broadcast streams</a>
<ul>
<li class="toc-entry toc-h3"><a href="#creating-broadcast-streams">Creating broadcast streams</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#alternatives-to-asbroadcaststream">Alternatives to asBroadcastStream</a>
<ul>
<li class="toc-entry toc-h3"><a href="#listener-swapping">Listener swapping</a></li>
<li class="toc-entry toc-h3"><a href="#streamiterator">StreamIterator</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#conclusion">Conclusion</a></li>
</ul>
  </div>
</div>


      <article>
        <div class="content">
          <div class="banner alert alert-info">
  <p class="banner__text">
    <a href="https://medium.com/dartlang/dart-2-stable-and-the-dart-web-platform-3775d5f8eac7" target="_blank" rel="noopener"><b>Dart 2</b> 稳定版发布！</a>
    <a href="/dart-2#migration">迁移代码</a> 或
    <a href="/install">安装 Dart</a>.
  </p>
</div>

          

          
          <div>
            <ul class="page-github-links-menu" role="group">
  <li>
    <a href="https://github.com/dart-lang/site-www/tree/master/src_zh_CN/_articles/libraries/broadcast-streams.md"
      class="no-automatic-external"
      title="View page source"
      target="_blank" rel="noopener">
      <i class="fab fa-github fa-sm"></i>
    </a>
  </li>
  <li>
    <a href="https://github.com/dart-lang/site-www/issues/new?title='Single-Subscription vs. Broadcast Streams' page issue&body=From URL: https://www.dartlang.org/articles/libraries/broadcast-streams"
      class="no-automatic-external"
      title="Report a bug on this page" target="_blank" rel="noopener">
      <i class="fas fa-bug fa-sm"></i>
    </a>
  </li>
</ul>

            <h1>Single-Subscription vs. Broadcast Streams</h1>
          </div>
          <p><em>Written by Florian Loitsch <br>
January 2014</em></p>

<p>Dart features two different flavors of Streams:
<em>single-subscription streams</em> and <em>broadcast streams.</em>
This article discusses the differences between the two
and provides recommendations on when to use which.</p>

<p>If you aren’t already familiar with Dart streams,
you can learn the basics from the tutorial
<a href="/tutorials/language/streams">Asynchronous Programming: Streams</a>.</p>

<h2 id="introduction">
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>Single-subscription and broadcast streams are intended to be used in
different contexts and have different requirements.
In many aspects they’re similar to TCP and UDP:
single-subscription streams are stable with
guaranteed properties (like TCP),
whereas broadcast streams can lose events and
listeners don’t have a tight connection to the source
(like UDP).</p>

<p>The following list summarizes the main differences between the two:</p>

<table class="table">
<tr>
<th></th>
<th>Single subscription</th>
<th>Broadcast</th>
</tr>
<tr>
<td>Number of listeners</td>
<td>1</td>
<td>∞</td>
</tr>
<tr>
<td>Can lose events</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Well-defined life cycle</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Ease of use</td>
<td>Hard</td>
<td>Easy</td>
</tr>
</table>

<p>Let’s look at each difference in detail.</p>

<dl>
  <dt>Number of listeners</dt>
  <dd>Single-subscription streams allow
listening only once to the stream.
This includes internal listen calls (such as calls to <code class="highlighter-rouge">isNotEmpty</code>).
Broadcast streams don’t have this limitation.</dd>
  <dt>Can lose events</dt>
  <dd>Single-subscription streams do not lose events.
If necessary they buffer their data until a listener appears.
Broadcast streams are free to drop events if they don’t have any listeners.</dd>
  <dt>Well-defined life cycle</dt>
  <dd>Single-subscription streams have a well-defined life cycle:
they start when a user starts listening,
and they end when the user cancels or
when the stream sends a close event.
Broadcast streams generally don’t give the listener any means to
influence the lifetime from the listener’s end.

    <p>Getting the lifetime of streams right is very important:
in dart:io the lifetime of the stream determines how long
the Dart program holds on to
the system resource it uses to deliver its data.
The wrong choice of stream type can lead to resource leaks.</p>
  </dd>
  <dt>Ease of use</dt>
  <dd>Internally, many Stream members (for example <code class="highlighter-rouge">first</code>)
start listening to the stream.
Because single-subscription streams allow only one listener,
invoking getters and methods on them can automatically use up the stream.
As such, single-subscription streams are less convenient to use than
broadcast streams,
which do not have this restriction.

    <p>Broadcast streams have their own pitfalls, though.
For instance, <code class="highlighter-rouge">isEmpty</code> returns false only after
<em>consuming</em> an element.
The user can then continue listening to the stream,
but the first event is lost.</p>
  </dd>
</dl>

<p>Before discussing the stream types in detail,
let’s take a closer look at subscriptions,
which are fundamental to understanding how both kinds of streams work.</p>

<h2 id="subscriptions">
<a id="subscriptions" class="anchor" href="#subscriptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subscriptions</h2>

<p>The easiest way to receive events from a stream
(single-subscription and broadcast) is to
invoke its <code class="highlighter-rouge">listen</code> method:
<code class="highlighter-rouge">stream.listen(onDataCallback)</code>.
In fact, <code class="highlighter-rouge">listen</code> really is the only method
where the implementation is different for different streams.
It connects a stream’s listener to its event source.
All other methods can be (and usually are) implemented
on top of the <code class="highlighter-rouge">listen</code> method.</p>

<p>The <code class="highlighter-rouge">listen</code> method creates a new <em>stream subscription</em>,
connects it to the stream’s event source, and
installs the callbacks (if given) in the subscription.
This stream subscription is then returned from the <code class="highlighter-rouge">listen</code> call.
The installation of the callbacks is just for convenience.
The handlers on the subscription can be changed at a later time.
It is not uncommon to see a <code class="highlighter-rouge">stream.listen(null)</code> just
to receive the stream subscription.</p>

<p>Once a stream creates a stream subscription, it hands off the
event generation and propagation to the subscription.
Most implementations of Stream
don’t even keep track of their listeners.
As soon as a stream creates the subscription,
the stream doesn’t need to know anything about the listener anymore.</p>

<p>The following diagram explains the <code class="highlighter-rouge">listen</code> call:</p>

<p><img src="images/listen.png" alt="Before listen, Stream points to Event Source; after listen, StreamSubscription and Event Source point to each other"></p>

<p>Note that a single-subscription stream
does not need to keep a reference to the event source,
once its <code class="highlighter-rouge">listen</code> method has been invoked.
That’s why the arrow from the Stream to the event source is dashed
in the “after” picture.
Also note that the event source never sees
(or needs to see) the stream.
The event source only needs a reference to its subscription(s).
In return, a stream subscription needs a pointer to its event source,
so that it can cancel its subscription and thus shut down the event source.</p>

<p>Another consequence of this setup is that Stream instances are
unaware of the state of the event source.
In particular, they do not know if the event source is paused or not.
The StreamSubscription instance takes over this task.
In fact, the stream subscription ensures
that pause requests are respected.
If the actual event source can not be paused (for whatever reason)
the stream subscription must buffer the events.
In general, streams should inform their users if
the created subscriptions are able to pause their event source, or not.
Not knowing could easily lead to excessive memory use.</p>

<h2 id="single-subscription-streams">
<a id="single-subscription-streams" class="anchor" href="#single-subscription-streams" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single-subscription streams</h2>

<p>A single-subscription stream allows only one subscriber.
Use a single-subscription stream when the consumer can trigger
the generation (“production”) of events
and when losing events would be an error.
The best example for such a stream is File.openRead():
the user starts the stream by listening to it,
and the user generally doesn’t want to lose events.</p>

<p>The fact that single-subscription streams can be listened to only once
has some important implications.
First, and most importantly, with a single-subscription stream
it’s extremely obvious
when the stream should produce events,
and when it should stop doing so.
Second, and more annoyingly, many Stream
getters and methods are less useful
for single-subscription streams.
For example, just using the <code class="highlighter-rouge">isNotEmpty</code> getter
internally listens to the stream and cancels its subscription
after it gets data.
At this point a single-subscription stream is finished:
the stream has already had a listener (the <code class="highlighter-rouge">isNotEmpty</code> getter),
and no other listener is allowed.
Similarly, the <code class="highlighter-rouge">first</code> getter can be invoked only once.</p>

<h3 id="creating-single-subscription-streams">
<a id="creating-single-subscription-streams" class="anchor" href="#creating-single-subscription-streams" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating single-subscription streams</h3>

<p>The easiest way to create a stream is to use a StreamController
where the default constructor instantiates a controller
with a single-subscription stream.</p>

<p>A controller implements the StreamSink interface with methods like
<code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">addError</code>, and <code class="highlighter-rouge">close</code>.
Event sources, such as native I/O extensions, simply
invoke the corresponding functions when they have new data.
StreamControllers provide an easy abstraction for implementers of streams,
but fundamentally the concept explained in the Subscription section is
still valid, as the following figure shows.</p>

<p><img src="images/listen-with-controller.png" alt="Before listen, Stream points to StreamController (and vice versa); after listen, StreamController and StreamSubscription point to each other"></p>

<p>Because controllers exist before a user listens to its stream,
the event source can add data to the controller
before the user starts listening to it.
To avoid data loss, the controller buffers the data until
a subscriber starts listening.</p>

<p><strong>This safeguard is one of the most abused features of a stream controller</strong>.
When instantiating a controller,
you can register an <code class="highlighter-rouge">onListen</code> callback
to be notified when a listener is present.
Only after this callback is invoked
should the event source add events to the controller.
Similarly you should register an <code class="highlighter-rouge">onCancel</code> callback
that shuts down the stream.
The <code class="highlighter-rouge">onCancel</code> callback is invoked
when the user cancels the subscription,
or when the controller is shut down with <code class="highlighter-rouge">close()</code>.</p>

<p>Note that generating events only when the stream has a listener
is not a strict rule, but a good guideline.
Some perfectly valid use cases exist for adding data to a
controller before any subscribers are listening.
Be aware, however, that StreamSubscription’s
buffering approach is optimized for just a few events,
and don’t abuse it.</p>

<p>Frequently, a good way to avoid data generation is to
delay computations until a listener exists.
For example, <code class="highlighter-rouge">File.openRead()</code> doesn’t touch the file system until
a listener exists.
A strange implication of this fact is that <code class="highlighter-rouge">File.openRead()</code> doesn’t throw
if it’s invoked on a nonexistent file.
Only when a user starts listening for the file contents does
the stream open the file on the hard drive.
If the file is created (through some other means)
in the time before the listener subscribes,
the stream works normally.
A direct corollary is that calling <code class="highlighter-rouge">File.openRead()</code>
doesn’t lock the file on the hard drive.</p>

<p>As a good guideline, assume that a stream is never listened to.
Exceptions to this rule are small, local code snippets,
such as tests, where the subscription is guaranteed to happen.
<strong>If a stream must be listened to (to avoid memory leaks)
clearly state this fact in the comments of
the function that creates the stream.</strong></p>

<h2 id="broadcast-streams">
<a id="broadcast-streams" class="anchor" href="#broadcast-streams" aria-hidden="true"><span class="octicon octicon-link"></span></a>Broadcast streams</h2>

<p>As a counterpart to single-subscription streams,
Dart also comes with broadcast streams.
Their intended use is for event sources that
produce output independently of listeners,
and where missing some events is not a problem.
Typically all DOM event sources are broadcast streams.</p>

<p>We can extend our subscription diagram for broadcast streams after
multiple listen calls:</p>

<p><img src="images/broadcast-listen.png" alt="Before listen, Stream points to Event Source; after listen, Event Source and multiple StreamSubscriptions point to each other"></p>

<p>The StreamSubscription instances have, again,
the responsibility to ensure that pause requests are respected.
Since stream subscriptions generally don’t know of each other,
the easiest solution is to buffer all incoming events at
the subscription level.
This can lead to memory leaks if the subscription is not
resumed or canceled.</p>

<p>Being able to listen multiple times to a stream has some nice implications.
One of them is that <code class="highlighter-rouge">first</code>, <code class="highlighter-rouge">isEmpty</code>, and so on
don’t make the stream unusable.
In return, determining the life cycle of a stream is more difficult.
Should the stream ever shut down?
If yes, should it shut down after it lost all its subscriptions
(making the stream multi-subscription only as long as
it has at least one subscriber),
or should it allow subscribers only as long as
a specific, crucial data event hasn’t been emitted?
All of these proposals are valid,
so broadcast streams should document their closing behavior.
Generally we assume that no documentation means that
the stream has an infinite lifetime.</p>

<h3 id="creating-broadcast-streams">
<a id="creating-broadcast-streams" class="anchor" href="#creating-broadcast-streams" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating broadcast streams</h3>

<p>The StreamController class comes with a factory constructor
<code class="highlighter-rouge">StreamController.broadcast</code> that has been designed for broadcast streams.
Contrary to single-subscription streams, it does not buffer events.
It either sends events directly to subscribers or,
if none is present, discards events.</p>

<aside class="alert alert-info">
  <p><strong>Note:</strong>
Without buffering, broadcast controllers seemingly have a
simpler and thus faster implementation.
However they need to deal with events that are
added to the controller
while the previous event hasn’t been distributed yet.
The current broadcast implementation is therefore
more complicated than the one for single-subscription streams.</p>
</aside>

<p>The StreamController.broadcast constructor also has two callbacks:
onListen and onCancel.
They are invoked whenever the controller switches
from unsubscribed to subscribed and
from subscribed to unsubscribed, respectively
(including when the stream is closed from the event-source side).</p>

<p>A more dangerous way of creating a stream controller is to
view a single-subscription controller through <code class="highlighter-rouge">asBroadcastStream()</code>.
Invoking <code class="highlighter-rouge">asBroadcastStream</code> basically tells the single-subscription stream
that the user wants to take over the lifetime management of the stream.
In combination with cancelOnError subscribers,
this can easily lead to single-stream subscriptions
that are never closed and thus leak memory or resources.</p>

<p>The following example demonstrates such a case:</p>

<!--- BEGIN(src/tests/site/articles/broadcast-streams/example1.dart) -->
<pre class="prettyprint lang-dart">import 'dart:io';
import 'dart:async';

main() {
  ServerSocket.bind("localhost", 4999).then((socket) {
    socket.asBroadcastStream()  // &lt;== asBroadcastStream.
       .map((x) { throw "oops, my mistake"; })
       .listen(print)
       .asFuture()  // Automatically cancels on error.
       .catchError((_) { print("caught error"); });
  });
}</pre>
<!--- END(PENDING TEST FILE) -->

<p>In this example, the single-subscription stream <code class="highlighter-rouge">socket</code> is
viewed as a broadcast stream.
The <code class="highlighter-rouge">asBroadcastStream</code> does not shut down after
its only listener cancels, and the socket remains open.
This is a typical case of resource leakage.
If the <code class="highlighter-rouge">asBroadcastStream()</code> call was left out,
the single-subscription stream would get notified that
its subscriber has disappeared and would close the socket.</p>

<p>Remember: <code class="highlighter-rouge">asBroadcastStream</code> is dangerous.
Use it only in rare circumstances.
We have seen <code class="highlighter-rouge">asBroadcastStream</code> used in circumstances where
listener changes and StreamIterators are the better choices.
See the next section for examples.</p>

<p>Alternatively, use the callbacks that can be given to <code class="highlighter-rouge">asBroadcastStream</code>.
They allow managing subscription changes
(similar to the StreamController.broadcast constructor)
and provide means to cancel
the subscription to the single-subscription stream.</p>

<h2 id="alternatives-to-asbroadcaststream">
<a id="alternatives-to-asbroadcaststream" class="anchor" href="#alternatives-to-asbroadcaststream" aria-hidden="true"><span class="octicon octicon-link"></span></a>Alternatives to asBroadcastStream</h2>

<p>Commonly <code class="highlighter-rouge">asBroadcastStream</code> is (ab)used so that Stream getters and methods,
such as <code class="highlighter-rouge">first</code> and <code class="highlighter-rouge">take</code>, can be invoked multiple times.
As shown above this is a dangerous trade-off.
This section shows some safer alternatives.</p>

<h3 id="listener-swapping">
<a id="listener-swapping" class="anchor" href="#listener-swapping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Listener swapping</h3>

<p>Stream subscriptions allow exchanging their listeners.
Instead of calling <code class="highlighter-rouge">first</code> multiple times on the stream,
you can often just exchange the listener callback
on the subscription.
For example:</p>

<!--- BEGIN(src/tests/site/articles/broadcast-streams/example2.dart) -->
<pre class="prettyprint lang-dart">var bstream = stream.asBroadcastStream();
bstream.first.then((x) {
  handleFirstMessage();
  return bstream.first;
}).then((x) {
  handleSecondMessage();
  bstream.listen(handleAllOtherMessages);
});</pre>
<!--- END(PENDING TEST FILE) -->

<p>could be written as:</p>

<!--- BEGIN(src/tests/site/articles/broadcast-streams/example3.dart) -->
<pre class="prettyprint lang-dart">StreamSubscription subscription = stream.listen(null);
subscription.onData((x) {
  handleFirstMessage();
  subscription.onData((x) {
    handleSecondMessage();
    subscription.onData(handleAllOtherMessages);
  });
});</pre>
<!--- END(PENDING TEST FILE) -->

<p>This introduces some nesting,
but some abstractions
(or using methods instead of anonymous closures)
can easily get rid of them.
A popular abstraction is, for example, a state machine.
Another one is the StreamIterator class.</p>

<h3 id="streamiterator">
<a id="streamiterator" class="anchor" href="#streamiterator" aria-hidden="true"><span class="octicon octicon-link"></span></a>StreamIterator</h3>

<p>Frequently, different events of an asynchronous stream
are destined for different parts of a system.
In such a case, a StreamIterator is often convenient.
Events of StreamIterators are pulled one by one,
and each part can pull the event it needs separately.
The operation is still asynchronous, though:
contrary to synchronous Iterators, moving to the next event can take time,
and the <code class="highlighter-rouge">moveNext</code> function therefore returns a future.</p>

<!--- BEGIN(src/tests/site/articles/broadcast-streams/example4.dart) -->
<pre class="prettyprint lang-dart">Future moveNextAssert(iterator) {
  var future = iterator.moveNext();
  return future.then((hasNext) {
    if (!hasNext) throw new StateError("missing element");
    return iterator.current;
  });
}

var lines = new File(...).openRead()
    .transform(utf8.decoder)
    .transform(new LineSplitter());
var iterator = new StreamIterator(lines);
moveNextAssert(iterator)
  .then((line) {
    print("First line: $line");
    return moveNextAssert(iterator);
  })
  .then((fileName) {  // Assume second line is a file.
    return handleFile(fileName)  // Wait for it to finish.
      .then((_) =&gt; moveNextAssert(iterator));
  })
  .then((line) {
    print("Last line: $line");
    return iterator.moveNext();
  })
  .then((hasNext) {
    if (hasNext) throw "More lines than expected";
  });</pre>
<!--- END(PENDING TEST FILE) -->

<h2 id="conclusion">
<a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h2>

<p>Despite their similarities, single-subscription and broadcast streams
have important differences.
You need to understand these differences,
so you can avoid
resource leaks and unnecessary memory consumption.</p>

<p>Single-subscription streams are designed for use cases where
events must not be lost,
and/or where the stream must have a well-defined lifetime.
Broadcast streams are tuned for event sources that are
not necessarily controlled by the listeners and
where some events can be lost or ignored.</p>

<p>Using <code class="highlighter-rouge">asBroadcastStream</code> on single-subscription streams
can lead to resource leaks.
Consider safer alternatives such as
listener swapping and StreamIterators.</p>

<p>For more information, see the API documentation:</p>

<ul>
  <li><a href="https://api.dartlang.org/stable/dart-async/Stream-class.html">Stream</a></li>
  <li><a href="https://api.dartlang.org/stable/dart-async/StreamSubscription-class.html">StreamSubscription</a></li>
  <li><a href="https://api.dartlang.org/stable/dart-async/StreamIterator-class.html">StreamIterator</a></li>
</ul>

<p><em>Thanks to Lasse Reichstein Holst Nielsen, Anders Johnsen,
and Kathy Walrath for their suggestions and help to improve this article.</em></p>


          

        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-3">
        <div class="content">
          <div class="brand">
            <img src="/assets/shared/dart/logo+text/horizontal/mono.svg" alt="Dart logo" class="brand"/>
          </div>
          <h4><a href="/terms">Terms</a> | <a href="https://policies.google.com/privacy">Privacy</a></h4>
          <style>.menu .material-icons { font-size: 14px; }</style><ul class="menu">
            <li>Site&nbsp;<a href="http://creativecommons.org/licenses/by/3.0/" class="no-automatic-external">CC&nbsp;BY&nbsp;3.0</a></li>
            <li>
              <a href="https://github.com/dart-lang/site-www"
                 title="This site's source is on GitHub."
                 class="no-automatic-external"><i class="fab fa-github fa-sm"></i></a>
              &nbsp;
              <a href="https://github.com/dart-lang/site-www/issues"
                 title="File an issue about this site."
                 class="no-automatic-external"><i class="fas fa-bug fa-sm"></i></a>
              &nbsp;
              <a 
                 title="Site built on 2018/08/18 12:44 CST"
                 
                 class="no-automatic-external"><i class="material-icons">build</i></a>
            </li>
          </ul>
        </div>
      </div>
      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>技术</h4>
          <ul>
            <li><a href="https://flutter.io">Dart 移动开发 (Flutter)</a></li>
            <li><a href="https://webdev.dartlang.org">Dart web 开发</a></li>
            <li><a href="/dart-vm">Dart 服务器开发</a></li>
            <li><a href="https://dart-lang.github.io/observatory/">Observatory 工具</a></li>
            <li><a href="/guides/libraries">Dart 库</a></li>
            <li><a href="/guides/language">Dart 编程语言</a></li>
          </ul>
        </div>
      </div>

      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>资源</h4>
          <ul>
            <li><a href="https://api.dartlang.org/stable">API 参考</a></li>
            <li><a href="https://dartpad.dartlang.org/">DartPad</a></li>
            <li><a href="https://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="http://news.dartlang.org/">Dart 新闻</a></li>
            <li><a href="https://github.com/dart-lang/sdk/issues">Dart bugs 和 <br> 新需求</a></li>
          </ul>
        </div>
      </div>

      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>社区</h4>
          <ul>
            <li><a href="/community">支持和邮件列表</a></li>
            <li><a href="/community/who-uses-dart">谁在用Dart</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
            <li>G+ <a href="https://plus.google.com/communities/114566943291919232850">社区</a> &
                <a href="https://plus.google.com/b/109866369054280216564/+dartlang">公告组</a></li>
            <li><a href="https://gitter.im/dart-lang/home">Gitter聊天室</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
