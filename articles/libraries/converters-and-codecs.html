<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="en_US" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Learn how to write efficient conversions.">
  <title>Converters and Codecs | Dart</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/touch-icon-iphone.png" rel="apple-touch-icon">
  <link href="/assets/touch-icon-ipad.png" rel="apple-touch-icon" sizes="76x76">
  <link href="/assets/touch-icon-iphone-retina.png" rel="apple-touch-icon" sizes="120x120">
  <link href="/assets/touch-icon-ipad-retina.png" rel="apple-touch-icon" sizes="152x152">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Converters and Codecs" />
  <meta name="twitter:description" content="Learn how to write efficient conversions." />

  <!-- Open Graph -->
  <meta property="og:title" content="Converters and Codecs" />
  <meta property="og:description" content="Learn how to write efficient conversions." />
  <meta property="og:url" content="https://www.dartlang.org/articles/libraries/converters-and-codecs" />
  <meta property="og:image" content="https://www.dartlang.org/assets/shared/dart-logo-for-shares.png?2" />

  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,700' rel='stylesheet' type='text/css'>
  <link type="text/css" rel="stylesheet" href="/assets/style.css">
  
  <!--
    Why don't we use Dart here?

    The only scripting we use here is stuff like the on-click footnotes on the
    front page or resizing of the left nav. These happen to be use cases where
    JavaScript and jQuery are doing just fine. Dart is here for application
    programming, not page scripting.
   -->
  <script type="text/javascript" src="/assets/main.js"></script>
  
  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


</head>

  <body class="default obsolete">
    <header id="page-header">
  <nav id="mainnav">
  <div id="menu-toggle"><i class="icon icon-menu"></i></div>
  <a href="/" class="brand" title="Dart">
    <img src="/assets/shared/dart/logo+text/horizontal/default.svg" alt="Dart">
  </a>
  <ul>
    <li class="mainnav__get-started"><a href="/guides/get-started"><span>入门</span></a></li>
    <li><a href="/guides/language">语言</a></li>
    <li><a href="/guides/libraries">库</a></li>
    <li><a href="/tools">工具</a></li>
    
    
    <li class="dropdown">
      <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dart 2 <span class="caret"></span></a>
      <ul class="dropdown-menu">
        

<li><a href="https://v1-dartlang-org.firebaseapp.com/articles/libraries/converters-and-codecs" class="no-automatic-external">1.24.3&nbsp;&nbsp;(archive)</a></li><li><a class="active">2.0.0-dev.66.0&nbsp;&nbsp;(beta)</a></li>

        <li role="separator" class="divider"></li>
        <li><a href="/dart-2#migration">迁移指南</a></li>
      </ul>
    </li>
    
    <li class="searchfield">
      <form class="navbar-search" action="/search" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input type="search" name="q" id="q" autocomplete="off" placeholder="Search">
        <button type="submit"><i class="icon icon-search"></i></button>
      </form>
    </li>
  </ul>
</nav>

  
  <div class="alert alert-danger">
    <h4 class="text-center">Content of this page might be obsolete.</h4>
  </div>
  
</header>

    <main id="page-content">
      <div id="sidenav" class="">
  <div class="content">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/shared/dart/logo+text/horizontal/default.svg" alt="Dart">
    </a>

    <div class="sidenav__search">
      <p>
        <a href="/search">Search <i class="icon icon-search"></i></a>
      </p>
    </div>

    <ul>
      <li>
        <a class="btn btn-default" href="/guides/get-started">入门</a>
      </li>
    </ul>
    <h4 ><a href="/guides/language" title="语言">语言</a></h4>
  <ul><li >
          <a href="/guides/language/language-tour" title="概览">概览</a>
        </li>
        
        <li >
          <a href="/guides/language/effective-dart" title="Effective Dart">Effective Dart</a>
          <i class="icon icon-arrow"></i>
          <ul><li >
                <a href="/guides/language/effective-dart/style" title="样式">样式</a>
              </li><li >
                <a href="/guides/language/effective-dart/documentation" title="文档">文档</a>
              </li><li >
                <a href="/guides/language/effective-dart/usage" title="使用">使用</a>
              </li><li >
                <a href="/guides/language/effective-dart/design" title="设计">设计</a>
              </li>
          </ul><li >
          <a href="/samples" title="示例代码">示例代码</a>
        </li>
  </ul><h4 ><a href="/guides/libraries" title="库">库</a></h4>
  <ul><li >
          <a href="/guides/libraries/library-tour" title="概览">概览</a>
        </li>
  </ul><h4 ><a href="/guides/platforms" title="平台">平台</a></h4>
  <ul><li >
          <a href="https://flutter.io" title="移动端 (Flutter)">移动端 (Flutter)</a>
        </li><li >
          <a href="https://webdev.dartlang.org" title="web">web</a>
        </li><li >
          <a href="/dart-vm" title="服务器">服务器</a>
        </li>
  </ul><h4 ><a href="/guides/testing" title="测试">测试</a></h4>
  <ul>
  </ul><h4 >资源</h4>
  <ul><li >
          <a href="/install" title="安装">安装</a>
        </li><li >
          <a href="/codelabs" title="Codelabs">Codelabs</a>
        </li><li >
          <a href="/tutorials" title="学习指南">学习指南</a>
        </li><li class="active">
          <a href="/articles" title="文章">文章</a>
        </li><li >
          <a href="/tools" title="工具">工具</a>
        </li><li >
          <a href="/community" title="社区支持">社区支持</a>
        </li>
  </ul>
  </div>
</div>

      
<div id="toc">
  <div class="content">
    <h4>On this page
      <a href="#page-content" title="Back to top" class="pull-right"><i class="icon icon-caret-up"></i></a>
    </h4>
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#how-to-write-efficient-conversions">How to write efficient conversions</a></li>
<li class="toc-entry toc-h2"><a href="#big-picture">Big picture</a></li>
<li class="toc-entry toc-h2"><a href="#codec">Codec</a></li>
<li class="toc-entry toc-h2"><a href="#converter">Converter</a></li>
<li class="toc-entry toc-h2"><a href="#chunked-conversion">Chunked conversion</a>
<ul>
<li class="toc-entry toc-h3"><a href="#chunkedconversionsink">ChunkedConversionSink</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#example">Example</a>
<ul>
<li class="toc-entry toc-h3"><a href="#specialized-chunkedconversionsinks">Specialized ChunkedConversionSinks</a></li>
</ul>
</li>
</ul>
  </div>
</div>


      <article>
        <div class="content">
          
<div class="banner alert alert-info">
  <p class="banner__text">
    欢迎来到 <a href="/dart-2"><b>Dart 2</b></a>!
    如果您仍在使用 Dart 1.x? 可访问查阅
    <a href="https://v1-dartlang-org.firebaseapp.com" class="no-automatic-external" target="_blank" rel="noopener">存档站点</a>
    或 <a href="/dart-2#migration">迁移指南</a>.
  </p>
</div>


          

          
          <div>
            <ul class="page-github-links-menu" role="group">
  <li>
    <a href="https://github.com/dart-lang/site-www/tree/master/src_zh_CN/_articles/libraries/converters-and-codecs.md"
      class="no-automatic-external"
      title="View page source"
      target="_blank" rel="noopener">
      <i class="fab fa-github fa-sm"></i>
    </a>
  </li>
  <li>
    <a href="https://github.com/dart-lang/site-www/issues/new?title='Converters and Codecs' page issue&body=From URL: https://www.dartlang.org/articles/libraries/converters-and-codecs"
      class="no-automatic-external"
      title="Report a bug on this page" target="_blank" rel="noopener">
      <i class="fas fa-bug fa-sm"></i>
    </a>
  </li>
</ul>

            <h1>Converters and Codecs</h1>
          </div>
          <h3 id="how-to-write-efficient-conversions">
<a id="how-to-write-efficient-conversions" class="anchor" href="#how-to-write-efficient-conversions" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong><em>How to write efficient conversions</em></strong>
</h3>

<p><em>Written by Florian Loitsch <br>
February 2014 (updated March 2015)</em></p>

<p>Converting data between different representations is a common task in computer
engineering. Dart is no exception and comes with
<a href="https://api.dartlang.org/dev/dart-convert/dart-convert-library.html">dart:convert</a>, a
core library that provides a set of converters
and useful tools to build new converters.
Examples of converters provided by the library include those
for commonly used encodings such as JSON and UTF-8.
In this document, we show how Dart’s
converters work and how you can create your own efficient converters
that fit into the Dart world.</p>

<h2 id="big-picture">
<a id="big-picture" class="anchor" href="#big-picture" aria-hidden="true"><span class="octicon octicon-link"></span></a>Big picture</h2>

<p>Dart’s conversion architecture is
based on <em>converters</em>, which translate from one representation to another.
When conversions are reversible, two converters are grouped together into a
<em>codec</em> (coder-decoder). The term codec is frequently used for audio and
video processing but also applies to string encodings such as UTF-8 or JSON.</p>

<p>By convention, all converters in Dart use the abstractions provided in the
dart:convert library. This provides a consistent API for developers and ensures
that converters can work together.
For instance, converters (or codecs) can be fused together if their
type matches, and the resulting converter can then be used as a single unit.
Furthermore, these fused converters frequently work more efficiently than if
they had been used separately.</p>

<h2 id="codec">
<a id="codec" class="anchor" href="#codec" aria-hidden="true"><span class="octicon octicon-link"></span></a>Codec</h2>

<p>A codec is a combination of two converters where one encodes
and the other one decodes:</p>

<pre class="prettyprint lang-dart">
abstract class Codec&lt;S, T&gt; {
  const Codec();

  T encode(S input) =&gt; encoder.convert(input);
  S decode(T encoded) =&gt; decoder.convert(encoded);

  Converter&lt;S, T&gt; get encoder;
  Converter&lt;T, S&gt; get decoder;

  Codec&lt;S, dynamic&gt; fuse(Codec&lt;T, dynamic&gt; other) { .. }
  Codec&lt;T, S&gt; get inverted =&gt; ...;
}
</pre>

<p>As can be seen, codecs provide convenience methods such as <code class="highlighter-rouge">encode()</code> and
<code class="highlighter-rouge">decode()</code> that are expressed in terms of the encoder and decoder. The <code class="highlighter-rouge">fuse()</code>
method and <code class="highlighter-rouge">inverted</code> getter allow you to fuse converters and
change the direction of a codec, respectively.
The base implementation of
<a href="https://api.dartlang.org/dev/dart-convert/Codec-class.html">Codec</a>
for these two members
provides a solid default implementation
and implementers usually don’t need to worry about them.</p>

<p>The <code class="highlighter-rouge">encode()</code> and <code class="highlighter-rouge">decode()</code>
methods, too, may be left untouched, but they can be extended for additional
arguments. For example, the
<a href="https://api.dartlang.org/dev/dart-convert/JsonCodec-class.html">JsonCodec</a>
adds named arguments to <code class="highlighter-rouge">encode()</code> and <code class="highlighter-rouge">decode()</code>
to make these methods more useful:</p>

<pre class="prettyprint lang-dart">
dynamic decode(String source, {reviver(var key, var value)}) { … }
String encode(Object value, {toEncodable(var object)}) { … }
</pre>

<p>The codec can be instantiated with arguments that are used as default
values, unless they are overridden by the named arguments during the
<code class="highlighter-rouge">encode()</code>/<code class="highlighter-rouge">decode()</code> call.</p>

<pre class="prettyprint lang-dart">
const JsonCodec({reviver(var key, var value), toEncodable(var object)})
  ...
</pre>

<p>As a general rule: if a codec can be configured, it should add named arguments
to the <code class="highlighter-rouge">encode()</code>/<code class="highlighter-rouge">decode()</code> methods and allow their defaults to be
set in constructors.
When possible, codec constructors should be <code class="highlighter-rouge">const</code> constructors.</p>

<h2 id="converter">
<a id="converter" class="anchor" href="#converter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Converter</h2>

<p>Converters, and in particular their <code class="highlighter-rouge">convert()</code> methods, are
where the real conversions happen:</p>

<pre class="prettyprint lang-dart">
T convert(S input);  // where T is the target and S the source type.
</pre>

<p>A minimal converter implementation only needs to extend the
<a href="https://api.dartlang.org/dev/dart-convert/Converter-class.html">Converter</a> class and
implement the <code class="highlighter-rouge">convert()</code> method. Similar to the Codec class, converters can be
made configurable by extending the constructors and adding named arguments to
the <code class="highlighter-rouge">convert()</code> method.</p>

<p>Such a minimal converter works in synchronous settings, but
does not work when used with chunks (either synchronously or asynchronously). In
particular, such a simple converter doesn’t work as a transformer (one of the
nicer features of Converters). A fully implemented converter implements the
<a href="https://api.dartlang.org/dev/dart-async/StreamTransformer-class.html">StreamTransformer</a>
interface and can thus be given to the <code class="highlighter-rouge">Stream.transform()</code> method.</p>

<p>Probably the most common use case is the decoding of UTF-8 with
<a href="https://api.dartlang.org/dev/dart-convert/Utf8Codec-class.html">utf8.decoder</a>:</p>

<pre class="prettyprint lang-dart">
File.openRead().transform(utf8.decoder).
</pre>

<h2 id="chunked-conversion">
<a id="chunked-conversion" class="anchor" href="#chunked-conversion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chunked conversion</h2>

<p>The concept of chunked conversions can be confusing, but at its core, it is
relatively simple. When a chunked conversion (including a stream
transformation) is started, the converter’s
<a href="https://api.dartlang.org/dev/dart-convert/Converter/startChunkedConversion.html">startChunkedConversion</a>
method is invoked with an output-
sink as argument. The method then returns an input sink into which the caller
puts data.</p>

<p><img src="/articles/libraries/images/chunked-conversion.png" alt="Chunked converstion"></p>

<p><strong>Note</strong>: An asterisk (<code class="highlighter-rouge">*</code>) in the diagram represents optional multiple calls.</p>

<p>In the diagram, the first step consists of creating an <code class="highlighter-rouge">outputSink</code> that should
be filled with the converted data. Then, the user invokes the
<code class="highlighter-rouge">startChunkedConversion()</code> method of the converter with the output sink.
The result is an input sink with methods <code class="highlighter-rouge">add()</code> and <code class="highlighter-rouge">close()</code>.</p>

<p>At a later point, the code that started the chunked conversion invokes,
possibly multiple times, the <code class="highlighter-rouge">add()</code> method with
some data. The data is converted by the input sink. If the converted data is
ready the input sink sends it to the output sink, possibly with multiple
<code class="highlighter-rouge">add()</code> calls. Eventually the user finishes the conversion by invoking
<code class="highlighter-rouge">close()</code>. At this point any remaining converted data is sent from the input
sink to the output sink and the output sink is closed.</p>

<p>Depending on the converter the input sink may need to buffer parts of the
incoming data. For example, a line-splitter that receives <code class="highlighter-rouge">ab\ncd</code> as the first
chunk can safely invoke its output sink with <code class="highlighter-rouge">ab</code>, but needs to wait for the
next data (or the <code class="highlighter-rouge">close()</code> call) before it can handle <code class="highlighter-rouge">cd</code>. If the next data is
<code class="highlighter-rouge">e\nf</code>, the input sink must concatenate <code class="highlighter-rouge">cd</code> and <code class="highlighter-rouge">e</code> and invoke the output sink
with the string <code class="highlighter-rouge">cde</code>, while buffering <code class="highlighter-rouge">f</code> for the next data event (or the
<code class="highlighter-rouge">close()</code> call).</p>

<p>The complexity of the input sink (in combination with the converter) varies.
Some chunked conversions are trivially mapped to the non-chunked versions (like
a String→String converter that removes the character <code class="highlighter-rouge">a</code>), while others are
more complicated. A safe, although inefficient (and usually unrecommended)
way to implement the chunked conversion is to buffer and concatenate all the
incoming data and to do the conversion in one go. This is, how the JSON decoder
is currently (January 2014) implemented.</p>

<p>Interestingly, the type of chunked conversion cannot be extrapolated from its
synchronous conversion. For example, the
<a href="https://api.dartlang.org/dev/dart-convert/HtmlEscape-class.html">HtmlEscape</a>
converter synchronously
converts Strings to Strings, and asynchronously converts chunks of Strings to
chunks of Strings (String→String). The
<a href="https://api.dartlang.org/dev/dart-convert/LineSplitter-class.html">LineSplitter</a>
converter synchronously
converts Strings to List<string> (the individual lines). Despite the difference
in the synchronous signature, the chunked version of the LineSplitter converter
has the same signature as
HtmlEscape: String→String. In this case each individual output chunk
represents one line.</string></p>

<pre class="prettyprint lang-dart">
import 'dart:convert';
import 'dart:async';

main() async {
  // HtmlEscape synchronously converts Strings to Strings.
  print(const HtmlEscape().convert("foo")); // "foo".
  // When used in a chunked way it converts from Strings
  // to Strings.
  var stream = new Stream.fromIterable(["f", "o", "o"]);
  print(await (stream.transform(const HtmlEscape())
                     .toList()));    // ["f", "o", "o"].

  // LineSplitter synchronously converts Strings to Lists of String.
  print(const LineSplitter().convert("foo\nbar")); // ["foo", "bar"]
  // However, asynchronously it converts from Strings to Strings (and
  // not Lists of Strings).
  var stream2 = new Stream.fromIterable(["fo", "o\nb", "ar"]);
  print("${await (stream2.transform(const LineSplitter())
                          .toList())}");
}
</pre>

<p>In general, the type of the chunked conversion is determined by the most
useful case when used as a StreamTransformer.</p>

<h3 id="chunkedconversionsink">
<a id="chunkedconversionsink" class="anchor" href="#chunkedconversionsink" aria-hidden="true"><span class="octicon octicon-link"></span></a>ChunkedConversionSink</h3>

<p><a href="https://api.dartlang.org/dev/dart-convert/ChunkedConversionSink-class.html">ChunkedConversionSinks</a>
are used to add new data to a
converter or as output from converters. The basic ChunkedConversionSink comes
with two methods: <code class="highlighter-rouge">add()</code> and <code class="highlighter-rouge">close()</code>. These have the same functionality as in
all other sinks of the system such as
<a href="https://api.dartlang.org/dev/dart-core/StringSink-class.html">StringSinks</a>
or
<a href="https://api.dartlang.org/dev/dart-async/StreamSink-class.html">StreamSinks</a>.</p>

<p>The ChunkedConversionSinks semantics are similar to that of
<a href="https://api.dartlang.org/dev/dart-io/IOSink-class.html">IOSinks</a>:
data added to the
sink must not be modified unless it can be guaranteed that the data has been
handled. For Strings this is not a problem (since they are immutable), but for
lists of bytes it frequently means allocating a fresh copy of the list. This
can be inefficient and the dart:convert library thus comes with subclasses of
ChunkedConversionSink that support more efficient ways of passing data.</p>

<p>For instance, the
<a href="https://api.dartlang.org/dev/dart-convert/ByteConversionSink-class.html">ByteConversionSink</a>,
has the additional method</p>

<p><code class="highlighter-rouge">addSlice(List&lt;int&gt; chunk, int start, int end, bool isLast)</code></p>

<p>Semantically, it
accepts a list (which may not be held onto), the sub-range that the converter
operates on, and a boolean <code class="highlighter-rouge">isLast</code>, which can be set instead of calling
<code class="highlighter-rouge">close()</code>.</p>

<pre class="prettyprint lang-dart">
import 'dart:convert';

main() {
  var outSink = new ChunkedConversionSink.withCallback((chunks) {
    print(chunks.single); // 𝅘𝅥𝅯
  });

  var inSink = utf8.decoder.startChunkedConversion(outSink);
  var list = [0xF0, 0x9D];
  inSink.addSlice(list, 0, 2, false);
  // Since we used `addSlice` we are allowed to reuse the list.
  list[0] = 0x85;
  list[1] = 0xA1;
  inSink.addSlice(list, 0, 2, true);
}
</pre>

<p>As a user of the chunked conversion sink (which is used both as input and output
of converters), this simply provides more choice. The fact that the list is not
held onto, means that you can use a cache and reuse that one for every call.
Combining <code class="highlighter-rouge">add()</code> with <code class="highlighter-rouge">close()</code> may help the receiver in that it can avoid
buffering data. Accepting sub-lists avoids expensive calls to <code class="highlighter-rouge">subList()</code>
(to copy the data).</p>

<p>The drawback of this interface is that it is more complicated to implement. To
ease the pain for developers, every improved chunked conversion sink of
dart:convert also comes with a base class that implements all methods except one
(which is abstract). The implementor of the conversion sink can then decide
whether to take advantage of the additional methods.</p>

<p><strong>Note</strong>: <em>Chunked conversion sinks *must* extend the corresponding base class.
This assures that adding functionality to the existing sink interfaces does
not break the extended sinks.</em></p>

<h2 id="example">
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h2>

<p>This section shows all the steps needed to create a simple encryption
converter and how a custom ChunkedConversionSink can improve performance.</p>

<p>Let’s start with the simple synchronous converter,
whose encryption routine simply rotates bytes by the given key:</p>

<pre class="prettyprint lang-dart">
import 'dart:convert';

/// A simple extension of Rot13 to bytes and a key.
class RotConverter extends Converter&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  final _key;
  const RotConverter(this._key);

  List&lt;int&gt; convert(List&lt;int&gt; data, { int key }) {
    if (key == null) key = this._key;
    var result = new List&lt;int&gt;(data.length);
    for (int i = 0; i &lt; data.length; i++) {
      result[i] = (data[i] + key) % 256;
    }
    return result;
  }
}
</pre>

<p>The corresponding Codec class is also simple:</p>

<pre class="prettyprint lang-dart">
class Rot extends Codec&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  final _key;
  const Rot(this._key);

  List&lt;int&gt; encode(List&lt;int&gt; data, { int key }) {
    if (key == null) key = this._key;
    return new RotConverter(key).convert(data);
  }

  List&lt;int&gt; decode(List&lt;int&gt; data, { int key }) {
    if (key == null) key = this._key;
    return new RotConverter(-key).convert(data);
  }

  RotConverter get encoder =&gt; new RotConverter(_key);
  RotConverter get decoder =&gt; new RotConverter(-_key);
}
</pre>

<p>We can (and should) avoid some of the <code class="highlighter-rouge">new</code> allocations, but for simplicity we
allocate a new instance of RotConverter every time one is needed.</p>

<p>This is how we use the Rot codec:</p>

<pre class="prettyprint lang-dart">
const Rot ROT128 = const Rot(128);
const Rot ROT1 = const Rot(1);
main() {

  print(const RotConverter(128).convert([0, 128, 255, 1]));   // [128, 0, 127, 129]
  print(const RotConverter(128).convert([128, 0, 127, 129])); // [0, 128, 255, 1]
  print(const RotConverter(-128).convert([128, 0, 127, 129]));// [0, 128, 255, 1]

  print(ROT1.decode(ROT1.encode([0, 128, 255, 1])));          // [0, 128, 255, 1]
  print(ROT128.decode(ROT128.encode([0, 128, 255, 1])));      // [0, 128, 255, 1]
}
</pre>

<p>We are on the right track. The codec works, but it is still missing the chunked
encoding part. Because each byte is encoded separately we can fall back to
the synchronous conversion method:</p>

<pre class="prettyprint lang-dart">
class RotConverter {
  ...
  RotSink startChunkedConversion(sink) {
    return new RotSink(_key, sink);
  }
}

class RotSink extends ChunkedConversionSink&lt;List&lt;int&gt;&gt; {
  final _converter;
  final ChunkedConversionSink&lt;List&lt;int&gt;&gt; _outSink;
  RotSink(key, this._outSink) : _converter = new RotConverter(key);

  void add(List&lt;int&gt; data) {
    _outSink.add(_converter.convert(data));
  }

  void close() {
    _outSink.close();
  }
}

</pre>

<p>Now, we can use the converter with chunked conversions or even for stream
transformations:</p>

<pre class="prettyprint lang-dart">
// Requires to import dart:io.
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  new File(inFile)
    .openRead()
    .transform(new RotConverter(key))
    .pipe(new File(outFile).openWrite());
}
</pre>

<h3 id="specialized-chunkedconversionsinks">
<a id="specialized-chunkedconversionsinks" class="anchor" href="#specialized-chunkedconversionsinks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Specialized ChunkedConversionSinks</h3>

<p>For many purposes, the current version of Rot is sufficient. That is, the
benefit of improvements would be outweighed by the cost of more complex code
and test requirements. Let’s assume, however,
that the performance of the converter is critical
(it’s on the hot path and up on the profile).
We furthermore assume that
the cost of allocating a new list for every chunk is killing performance
(a reasonable assumption).</p>

<p>We start by making the allocation cost cheaper: by using a
<a href="https://api.dartlang.org/dev/dart-typed_data/Uint8List-class.html">typed byte-list</a>
we can reduce the size of the allocated list by a factor of 8 (on 64-bit
machines). This one line change doesn’t remove the allocation, but makes it much
cheaper.</p>

<p>We can also avoid the allocation altogether if we overwrite the input. In
the following version of RotSink, we add a new method <code class="highlighter-rouge">addModifiable()</code> that
does exactly that:</p>

<pre class="prettyprint lang-dart">
class RotSink extends ChunkedConversionSink&lt;List&lt;int&gt;&gt; {
  final _key;
  final ChunkedConversionSink&lt;List&lt;int&gt;&gt; _outSink;
  RotSink(this._key, this._outSink);

  void add(List&lt;int&gt; data) {
    addModifiable(new Uint8List.fromList(data));
  }

  void addModifiable(List&lt;int&gt; data) {
    for (int i = 0; i &lt; data.length; i++) {
      data[i] = (data[i] + _key) % 256;
    }
    _outSink.add(data);
  }

  void close() {
    _outSink.close();
  }
}
</pre>

<p>For simplicity we propose a new method that consumes a complete list. A more
advanced method (for example <code class="highlighter-rouge">addModifiableSlice()</code>) would take range arguments
(<code class="highlighter-rouge">from</code>, <code class="highlighter-rouge">to</code>) and an <code class="highlighter-rouge">isLast</code> boolean as arguments.</p>

<p>This new method is not yet used by transformers, but we can already use it when
invoking <code class="highlighter-rouge">startChunkedConversion</code> explicitly.</p>

<pre class="prettyprint lang-dart">

main() {
  var outSink = new ChunkedConversionSink.withCallback((chunks) {
    print(chunks); // [[31, 32, 33], [24, 25, 26]]
  });
  var inSink = new RotConverter(30).startChunkedConversion(outSink);
  inSink.addModifiable([1, 2, 3]);
  inSink.addModifiable([250, 251, 252]);
  inSink.close();
}
</pre>

<p>In this small example, performance isn’t visibly different,
but internally the
chunked conversion avoids allocating new lists for the individual chunks.
For two small chunks, it doesn’t make a difference, but
if we implement this for the stream transformer,
encrypting a bigger file can be noticeably faster.</p>

<p>To do this,
we can make use of the undocumented feature that IOStreams provide modifiable lists.
We could now simply rewrite <code class="highlighter-rouge">add()</code> and
point it directly to <code class="highlighter-rouge">addModifiable()</code>. In general, this is not safe,
and
such a converter would be the potential source of hard-to-track bugs. Instead,
we write a converter that does the unmodifiable-to-modifiable conversion
explicitly, and then fuse the two converters.</p>

<pre class="prettyprint lang-dart">
class ToModifiableConverter extends Converter&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  List&lt;int&gt; convert(List&lt;int&gt; data) =&gt; data;
  ToModifiableSink startChunkedConversion(RotSink sink) {
    return new ToModifiableSink(sink);
  }
}

class ToModifiableSink
    extends ChunkedConversionSink&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  final RotSink sink;
  ToModifiableSink(this.sink);

  void add(List&lt;int&gt; data) { sink.addModifiable(data); }
  void close() { sink.close(); }
}
</pre>

<p>ToModifiableSink just signals the next sink that the incoming chunk
is modifiable. We can use this to make our pipeline more efficient:</p>

<pre class="prettyprint lang-dart">
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  new File(inFile)
      .openRead()
      .transform(
          new ToModifiableConverter().fuse(new RotConverter(key)))
      .pipe(new File(outFile).openWrite());
}
</pre>

<p>On my machine, this small modification brought the encryption time of an 11MB
file from 450ms down to 260ms. We achieved this speed up without losing
compatibility with existing codecs (with regard to the <code class="highlighter-rouge">fuse()</code> method)
and the converter still functions as a stream transformer.</p>

<p>Reusing the input works nicely with other
converters and not just with our Rot cipher. We should therefore make an
interface that generalizes the concept. For simplicity, we named it
<code class="highlighter-rouge">CipherSink</code>, although it has, of course, uses outside the encryption world.</p>

<pre class="prettyprint lang-dart">
abstract class CipherSink
    extends ChunkedConversionSink&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  void addModifiable(List&lt;int&gt; data) { add(data); }
}
</pre>

<p>We can then make our RotSink private and expose the CipherSink instead.
Other developers can now reuse our work (CipherSink and ToModifiableConverter)
and benefit from it.</p>

<p>But we are not done yet.</p>

<p>Although we won’t make the cipher faster anymore,
we can improve the output side of our Rot converter.
Take, for instance, the fusion of two encryptions:</p>

<pre class="prettyprint lang-dart">
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  // Double-strength cipher running the Rot-cipher twice.
  var transformer = new ToModifiableConverter()
       .fuse(new RotConverter(key))  // &lt;= fused RotConverters.
       .fuse(new RotConverter(key));
  new File(inFile)
      .openRead()
      .transform(transformer)
      .pipe(new File(outFile).openWrite());
}
</pre>

<p>Since the first RotConverter invokes <code class="highlighter-rouge">outSink.add()</code>, the second RotConverter
assumes that input cannot be modified and allocates a copy. We can work around
this by sandwiching a ToModifiableConverter in between the two ciphers:</p>

<pre class="prettyprint lang-dart">var transformer = new ToModifiableConverter()
     .fuse(new RotConverter(key))
     .fuse(new ToModifiableConverter())
     .fuse(new RotConverter(key));</pre>

<p>This works, but is hackish. We want the RotConverters to work without
intermediate converters. The first cipher should look at the outSink and
determines if it is a CipherSink or not. We can do this either,
whenever we want to add a new chunk,
or at the beginning when we start a chunked
conversion. We prefer the latter approach:</p>

<pre class="prettyprint lang-dart">/// Works more efficiently if given a CipherSink as argument.
CipherSink startChunkedConversion(
    ChunkedConversionSink&lt;List&lt;int&gt;&gt; sink) {
  if (sink is! CipherSink) sink = new _CipherSinkAdapter(sink);
  return new _RotSink(_key, sink);
}</pre>

<p>_CipherSinkAdapter is simply:</p>

<pre class="prettyprint lang-dart">
class _CipherSinkAdapter implements CipherSink {
  ChunkedConversionSink&lt;List&lt;int&gt;, List&lt;int&gt;&gt; sink;
  _CipherSinkAdapter(this.sink);

  void add(data) { sink.add(data); }
  void addModifiable(data) { sink.add(data); }
  void close() { sink.close(); }
}
</pre>

<p>We now only need to change the _RotSink to take advantage of the fact that it
always receives a CipherSink as an argument to its constructor:</p>

<pre class="prettyprint lang-dart">
class _RotSink extends CipherSink {
  final _key;
  final CipherSink _outSink;  // &lt;= always a CipherSink.
  _RotSink(this._key, this._outSink);

  void add(List&lt;int&gt; data) {
    addModifiable(data.toList());
  }

  void addModifiable(List&lt;int&gt; data) {
    for (int i = 0; i &lt; data.length; i++) {
      data[i] = (data[i] + _key) % 256;
    }
    _outSink.addModifiable(data);  // &lt;= safe to call addModifiable.
  }

  void close() {
    _outSink.close();
  }
}
</pre>

<p>With these changes our super secure, double cipher won’t allocate any new lists
and our work is done.</p>

<p>Thanks to Lasse Reichstein Holst Nielsen, Anders Johnsen, and Matias Meno who
were a great help in writing this article.</p>

          

        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-3">
        <div class="content">
          <div class="brand">
            <img src="/assets/shared/dart/logo+text/horizontal/mono.svg" alt="Dart logo" class="brand"/>
          </div>
          <h4><a href="/terms">Terms</a> | <a href="https://policies.google.com/privacy">Privacy</a></h4>
          <style>.menu .material-icons { font-size: 14px; }</style><ul class="menu">
            <li>Site&nbsp;<a href="http://creativecommons.org/licenses/by/3.0/" class="no-automatic-external">CC&nbsp;BY&nbsp;3.0</a></li>
            <li>
              <a href="https://github.com/dart-lang/site-www"
                 title="This site's source is on GitHub."
                 class="no-automatic-external"><i class="fab fa-github fa-sm"></i></a>
              &nbsp;
              <a href="https://github.com/dart-lang/site-www/issues"
                 title="File an issue about this site."
                 class="no-automatic-external"><i class="fas fa-bug fa-sm"></i></a>
              &nbsp;
              <a 
                 title="Site built on 2018/07/10 15:52 CST"
                 
                 class="no-automatic-external"><i class="material-icons">build</i></a>
            </li>
          </ul>
        </div>
      </div>
      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>技术</h4>
          <ul>
            <li><a href="https://flutter.io">Dart 移动开发 (Flutter)</a></li>
            <li><a href="https://webdev.dartlang.org">Dart web 开发</a></li>
            <li><a href="/dart-vm">Dart 服务器开发</a></li>
            <li><a href="https://dart-lang.github.io/observatory/">Observatory 工具</a></li>
            <li><a href="/guides/libraries">Dart 库</a></li>
            <li><a href="/guides/language">Dart 编程语言</a></li>
          </ul>
        </div>
      </div>

      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>资源</h4>
          <ul>
            <li><a href="https://api.dartlang.org/dev">API 参考</a></li>
            <li><a href="https://dartpad.dartlang.org/">DartPad</a></li>
            <li><a href="https://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="http://news.dartlang.org/">Dart 新闻</a></li>
            <li><a href="https://github.com/dart-lang/sdk/issues">Dart bugs 和 <br> 新需求</a></li>
          </ul>
        </div>
      </div>

      <div class="col-sm-4 col-md-3">
        <div class="content">
          <h4>社区</h4>
          <ul>
            <li><a href="/community">支持和邮件列表</a></li>
            <li><a href="/community/who-uses-dart">谁在用Dart</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
            <li>G+ <a href="https://plus.google.com/communities/114566943291919232850">社区</a> &
                <a href="https://plus.google.com/b/109866369054280216564/+dartlang">公告组</a></li>
            <li><a href="https://gitter.im/dart-lang/home">Gitter聊天室</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
