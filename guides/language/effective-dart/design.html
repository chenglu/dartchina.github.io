<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="en_US" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Design consistent, usable libraries.">
  <title>Effective Dart: 设计 | Dart</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/touch-icon-iphone-a46c306c4fbfae0b28d63f512b01d7cb2ccf1e4ca9d7f3aab15ba1170beed4a0.png" rel="apple-touch-icon">
  <link href="/assets/touch-icon-ipad-d0181720760b3912858b6d40da1d5586b1e92c7c8656a485ea41005674401e6b.png" rel="apple-touch-icon" sizes="76x76">
  <link href="/assets/touch-icon-iphone-retina-3d9821a631425376ac6203dea3c23c1940ab7b5c506a25406662fab76cee2e0b.png" rel="apple-touch-icon" sizes="120x120">
  <link href="/assets/touch-icon-ipad-retina-b9715401952522f1daee2b4a4064a1bbfb5ffab78d0a47a7226dc87444d51c32.png" rel="apple-touch-icon" sizes="152x152">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Effective Dart: 设计" />
  <meta name="twitter:description" content="Design consistent, usable libraries." />

  <!-- Open Graph -->
  <meta property="og:title" content="Effective Dart: 设计" />
  <meta property="og:description" content="Design consistent, usable libraries." />
  <meta property="og:url" content="https://www.dartlang.org/guides/language/effective-dart/design" />
  <meta property="og:image" content="https://www.dartlang.org/assets/shared/dart-logo-for-shares.png?2" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="/assets/main-743789fa2eea1d0b842284e7e29077de7c7f755aa88e291b7b8bf324a4a2a14b.css">
  <script src="/assets/main-3e89b739cc750412e013252d8b4ced20af281589ffe69a156e6c279177f81069.js" type="text/javascript"></script>
  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


</head>

  <body class="default">
    <header id="page-header">
  <nav id="mainnav">
  <div id="menu-toggle"><i class="icon icon-menu"></i></div>
  <a href="/" class="brand" title="Dart">
    <img src="/assets/shared/dart/logo+text/horizontal/default-363c9c133ffb7780463d3d638632b64cc8221d74d93cd1002fb1efbbe9983bc9.svg" alt="Dart">
  </a>
  <ul>
    <li class="mainnav__get-started"><a href="/guides/get-started"><span>入门</span></a></li>
    <li><a href="/guides/language">语言</a></li>
    <li><a href="/guides/libraries">库</a></li>
    <li><a href="/tools">工具</a></li>
    
    
    <li class="dropdown">
      <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dart 2</a>
      <ul class="dropdown-menu">
        

<li><a href="https://v1-dartlang-org.firebaseapp.com/guides/language/effective-dart/design" class="dropdown-item no-automatic-external">1.24.3&nbsp;&nbsp;(archive)</a></li><li><a class="active dropdown-item">2.0.0&nbsp;&nbsp;(stable)</a></li>

        <li role="separator" class="dropdown-divider"></li>
        <li><a class="dropdown-item" href="/dart-2#migration">迁移指南</a></li>
      </ul>
    </li>
    
    <li class="searchfield">
      <form class="navbar-search" action="/search" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input type="search" name="q" id="q" autocomplete="off" placeholder="Search">
        <button type="submit"><i class="icon icon-search"></i></button>
      </form>
    </li>
  </ul>
</nav>

  
</header>

    <main id="page-content">
      <div id="sidenav" class="">
  <div class="content">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/shared/dart/logo+text/horizontal/default-363c9c133ffb7780463d3d638632b64cc8221d74d93cd1002fb1efbbe9983bc9.svg" alt="Dart">
    </a>

    <div class="sidenav__search">
      <p>
        <a href="/search">Search <i class="icon icon-search"></i></a>
      </p>
    </div>

    <ul>
      <li>
        <a class="btn btn-light" href="/guides/get-started">入门</a>
      </li>
    </ul>
    <h4 ><a href="/guides/language" title="语言">语言</a></h4>
  <ul><li >
          <a href="/guides/language/language-tour" title="概览">概览</a>
        </li>
        
        <li class="active">
          <a href="/guides/language/effective-dart" title="Effective Dart">Effective Dart</a>
          <i class="icon icon-arrow"></i>
          <ul><li >
                <a href="/guides/language/effective-dart/style" title="风格">风格</a>
              </li><li >
                <a href="/guides/language/effective-dart/documentation" title="文档">文档</a>
              </li><li >
                <a href="/guides/language/effective-dart/usage" title="使用">使用</a>
              </li><li class="active">
                <a href="/guides/language/effective-dart/design" title="设计">设计</a>
              </li>
          </ul><li >
          <a href="/samples" title="示例代码">示例代码</a>
        </li>
  </ul><h4 ><a href="/guides/libraries" title="库">库</a></h4>
  <ul><li >
          <a href="/guides/libraries/library-tour" title="概览">概览</a>
        </li>
  </ul><h4 ><a href="/guides/platforms" title="平台">平台</a></h4>
  <ul><li >
          <a href="https://flutter.io" title="移动端 (Flutter)">移动端 (Flutter)</a>
        </li><li >
          <a href="https://webdev.dartlang.org" title="web">web</a>
        </li><li >
          <a href="/dart-vm" title="服务器">服务器</a>
        </li>
  </ul><h4 ><a href="/guides/testing" title="测试">测试</a></h4>
  <ul>
  </ul><h4 >资源</h4>
  <ul><li >
          <a href="/install" title="安装">安装</a>
        </li><li >
          <a href="/codelabs" title="Codelabs">Codelabs</a>
        </li><li >
          <a href="/tutorials" title="学习指南">学习指南</a>
        </li><li >
          <a href="/articles" title="文章">文章</a>
        </li><li >
          <a href="/tools" title="工具">工具</a>
        </li><li >
          <a href="/community" title="社区支持">社区支持</a>
        </li>
  </ul>
  </div>
</div>

      
<div id="toc">
  <div class="content">
    <header class="h4 text-uppercase">
      目录
      <a title="Back to top" class="back-to-top float-right mr-3">
        <i class="fas fa-angle-up"></i>
      </a>
    </header>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#命名">命名</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-使用一致的术语">要 使用一致的术语。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-缩写">避免 缩写。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-把最具描述性的名词放到最后">推荐 把最具描述性的名词放到最后。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-尽量让代码看起来像普通的句子">考虑 尽量让代码看起来像普通的句子。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用名词短语来命名不是布尔类型的变量和属性">推荐 使用名词短语来命名不是布尔类型的变量和属性。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用非命令式动词短语命名布尔类型的变量和属性">推荐 使用非命令式动词短语命名布尔类型的变量和属性。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-省略命名布尔参数的动词">考虑 省略命名布尔参数的动词。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-为布尔属性或变量取肯定含义的名字">考虑 为布尔属性或变量取“肯定”含义的名字。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用命令式动词短语来命名带有副作用的函数或者方法">推荐 使用命令式动词短语来命名带有副作用的函数或者方法。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数">考虑 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视">考虑 使用命令式动词短语命名一个函数或方法，若果你希望它的执行能被重视。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在方法命名中使用-get-开头">避免 在方法命名中使用 get 开头。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数">推荐 使用 to___() 来命名把对象的状态转换到一个新的对象的函数。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数">推荐 使用 as___() 来命名把原来对象转换为另外一种表现形式的函数。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在方法或者函数名称中描述参数">避免 在方法或者函数名称中描述参数。</a></li>
<li class="toc-entry toc-h3"><a href="#要-在命名参数时遵循现有的助记符约定">要 在命名参数时，遵循现有的助记符约定。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#库">库</a>
<ul>
<li class="toc-entry toc-h3"><a href="#推荐-使用私有声明">推荐 使用私有声明。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-声明多个类在一个库中">考虑 声明多个类在一个库中。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#类">类</a>
<ul>
<li class="toc-entry toc-h3"><a href="#避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类">避免 避免为了使用一个简单的函数而去定义一个单一成员的抽象类</a></li>
<li class="toc-entry toc-h3"><a href="#避免-定义仅包含静态成员的类">避免 定义仅包含静态成员的类。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-集成一个不期望被集成的类">避免 集成一个不期望被集成的类。</a></li>
<li class="toc-entry toc-h3"><a href="#要-把能够继承的说明添加到文档中如果这个类可以继承">要 把能够继承的说明添加到文档中，如果这个类可以继承。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-去实现一个不期望成为接口的类该类不想作为接口被实现">避免 去实现一个不期望成为接口的类（该类不想作为接口被实现）。</a></li>
<li class="toc-entry toc-h3"><a href="#要-对支持接口的类在文档注明">要 对支持接口的类在文档注明</a></li>
<li class="toc-entry toc-h3"><a href="#避免-去-mixin-一个不期望被-mixin-的类">避免 去 mixin 一个不期望被 mixin 的类</a></li>
<li class="toc-entry toc-h3"><a href="#要-对支持-mixin-的类在文档注明">要 对支持 mixin 的类在文档注明</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#constructors">Constructors</a>
<ul>
<li class="toc-entry toc-h3"><a href="#prefer-defining-constructors-instead-of-static-methods-to-create-instances">PREFER defining constructors instead of static methods to create instances.</a></li>
<li class="toc-entry toc-h3"><a href="#consider-making-your-constructor-const-if-the-class-supports-it">CONSIDER making your constructor const if the class supports it.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#members">Members</a>
<ul>
<li class="toc-entry toc-h3"><a href="#prefer-making-fields-and-top-level-variables-final">PREFER making fields and top-level variables final.</a></li>
<li class="toc-entry toc-h3"><a href="#do-use-getters-for-operations-that-conceptually-access-properties">DO use getters for operations that conceptually access properties.</a></li>
<li class="toc-entry toc-h3"><a href="#do-use-setters-for-operations-that-conceptually-change-properties">DO use setters for operations that conceptually change properties.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-define-a-setter-without-a-corresponding-getter">DON’T define a setter without a corresponding getter.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-returning-null-from-members-whose-return-type-is-bool-double-int-or-num">AVOID returning null from members whose return type is bool, double, int, or num.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-returning-this-from-methods-just-to-enable-a-fluent-interface">AVOID returning this from methods just to enable a fluent interface.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#types">Types</a>
<ul>
<li class="toc-entry toc-h3"><a href="#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious">PREFER type annotating public fields and top-level variables if the type isn’t obvious.</a></li>
<li class="toc-entry toc-h3"><a href="#consider-type-annotating-private-fields-and-top-level-variables-if-the-type-isnt-obvious">CONSIDER type annotating private fields and top-level variables if the type isn’t obvious.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-type-annotating-initialized-local-variables">AVOID type annotating initialized local variables.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-annotating-inferred-parameter-types-on-function-expressions">AVOID annotating inferred parameter types on function expressions.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-redundant-type-arguments-on-generic-invocations">AVOID redundant type arguments on generic invocations.</a></li>
<li class="toc-entry toc-h3"><a href="#do-annotate-when-dart-infers-the-wrong-type">DO annotate when Dart infers the wrong type.</a></li>
<li class="toc-entry toc-h3"><a href="#prefer-annotating-with-dynamic-instead-of-letting-inference-fail">PREFER annotating with dynamic instead of letting inference fail.</a></li>
<li class="toc-entry toc-h3"><a href="#prefer-signatures-in-function-type-annotations">PREFER signatures in function type annotations.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-specify-a-return-type-for-a-setter">DON’T specify a return type for a setter.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-use-the-legacy-typedef-syntax">DON’T use the legacy typedef syntax.</a></li>
<li class="toc-entry toc-h3"><a href="#prefer-inline-function-types-over-typedefs">PREFER inline function types over typedefs.</a></li>
<li class="toc-entry toc-h3"><a href="#consider-using-function-type-syntax-for-parameters">CONSIDER using function type syntax for parameters.</a></li>
<li class="toc-entry toc-h3"><a href="#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed">DO annotate with Object instead of dynamic to indicate any object is allowed.</a></li>
<li class="toc-entry toc-h3"><a href="#do-use-futurevoid-as-the-return-type-of-asynchronous-members-that-do-not-produce-values">DO use Future&lt;void&gt; as the return type of asynchronous members that do not produce values.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-using-futureort-as-a-return-type">AVOID using FutureOr&lt;T&gt; as a return type.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#parameters">Parameters</a>
<ul>
<li class="toc-entry toc-h3"><a href="#avoid-positional-boolean-parameters">AVOID positional boolean parameters.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters">AVOID optional positional parameters if the user may want to omit earlier parameters.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-mandatory-parameters-that-accept-a-special-no-argument-value">AVOID mandatory parameters that accept a special “no argument” value.</a></li>
<li class="toc-entry toc-h3"><a href="#do-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range">DO use inclusive start and exclusive end parameters to accept a range.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#equality">Equality</a>
<ul>
<li class="toc-entry toc-h3"><a href="#do-override-hashcode-if-you-override-">DO override hashCode if you override ==.</a></li>
<li class="toc-entry toc-h3"><a href="#do-make-your--operator-obey-the-mathematical-rules-of-equality">DO make your == operator obey the mathematical rules of equality.</a></li>
<li class="toc-entry toc-h3"><a href="#avoid-defining-custom-equality-for-mutable-classes">AVOID defining custom equality for mutable classes.</a></li>
<li class="toc-entry toc-h3"><a href="#dont-check-for-null-in-custom--operators">DON’T check for null in custom == operators.</a></li>
</ul>
</li>
</ul>
  </div>
</div>


      <article>
        <div class="content">
          
          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/usage">&lang;&nbsp;&nbsp;使用</a>
      
    </li>
    <li class="next">
      
    </li>
  </ul>
</nav>


          <div>
            <div id="page-github-links" class="btn-group" aria-label="Page GitHub links" role="group">
  <a href="https://github.com/dart-lang/site-www/tree/master/src_zh_CN/_guides/language/effective-dart/design.md" class="btn no-automatic-external" title="View page source" target="_blank" rel="noopener">
    <i class="fas fa-file-alt fa-sm"></i>
  </a>
  <a href="https://github.com/dart-lang/site-www/issues/new?title='Effective Dart: 设计' page issue&body=
Page URL: https://www.dartlang.org/guides/language/effective-dart/design%0D%0A
Page source: https://github.com/dart-lang/site-www/tree/master/src_zh_CN/_guides/language/effective-dart/design.md%0D%0A
%0D%0A
<!-- ADD YOUR DESCRIPTION OF THE PAGE ISSUE HERE: -->" class="btn no-automatic-external" title="Report a issue with this page"
    target="_blank" rel="noopener">
    <i class="fas fa-bug fa-sm"></i>
  </a>
</div>

            <h1>Effective Dart: 设计</h1>
          </div>
          <?code-excerpt replace="/([A-Z]\w*)\d\b/$1/g"?>
<?code-excerpt plaster="none"?>

<p>下面给出的准则用于指导为库编写一致的、可用的 API。</p>

<ul id="markdown-toc">
  <li>
<a href="#%E5%91%BD%E5%90%8D" id="markdown-toc-命名">命名</a>    <ul>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E7%9A%84%E6%9C%AF%E8%AF%AD" id="markdown-toc-要-使用一致的术语"><strong>要</strong> 使用一致的术语。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E7%BC%A9%E5%86%99" id="markdown-toc-避免-缩写"><strong>避免</strong> 缩写。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E6%8A%8A%E6%9C%80%E5%85%B7%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%9A%84%E5%90%8D%E8%AF%8D%E6%94%BE%E5%88%B0%E6%9C%80%E5%90%8E" id="markdown-toc-推荐-把最具描述性的名词放到最后"><strong>推荐</strong> 把最具描述性的名词放到最后。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E5%B0%BD%E9%87%8F%E8%AE%A9%E4%BB%A3%E7%A0%81%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%83%8F%E6%99%AE%E9%80%9A%E7%9A%84%E5%8F%A5%E5%AD%90" id="markdown-toc-考虑-尽量让代码看起来像普通的句子"><strong>考虑</strong> 尽量让代码看起来像普通的句子。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E4%B8%8D%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" id="markdown-toc-推荐-使用名词短语来命名不是布尔类型的变量和属性"><strong>推荐</strong> 使用名词短语来命名不是布尔类型的变量和属性。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" id="markdown-toc-推荐-使用非命令式动词短语命名布尔类型的变量和属性"><strong>推荐</strong> 使用非命令式动词短语命名布尔类型的变量和属性。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E7%9C%81%E7%95%A5%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E8%AF%8D" id="markdown-toc-考虑-省略命名布尔参数的动词"><strong>考虑</strong> 省略命名布尔<em>参数</em>的动词。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%B8%BA%E5%B8%83%E5%B0%94%E5%B1%9E%E6%80%A7%E6%88%96%E5%8F%98%E9%87%8F%E5%8F%96%E8%82%AF%E5%AE%9A%E5%90%AB%E4%B9%89%E7%9A%84%E5%90%8D%E5%AD%97" id="markdown-toc-考虑-为布尔属性或变量取肯定含义的名字"><strong>考虑</strong> 为布尔属性或变量取“肯定”含义的名字。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95" id="markdown-toc-推荐-使用命令式动词短语来命名带有副作用的函数或者方法"><strong>推荐</strong> 使用命令式动词短语来命名带有副作用的函数或者方法。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%88%96%E8%80%85%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0" id="markdown-toc-考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数"><strong>考虑</strong> 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95%E8%8B%A5%E6%9E%9C%E4%BD%A0%E5%B8%8C%E6%9C%9B%E5%AE%83%E7%9A%84%E6%89%A7%E8%A1%8C%E8%83%BD%E8%A2%AB%E9%87%8D%E8%A7%86" id="markdown-toc-考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视"><strong>考虑</strong> 使用命令式动词短语命名一个函数或方法，若果你希望它的执行能被重视。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E4%B8%AD%E4%BD%BF%E7%94%A8-get-%E5%BC%80%E5%A4%B4" id="markdown-toc-避免-在方法命名中使用-get-开头"><strong>避免</strong> 在方法命名中使用 <code class="highlighter-rouge">get</code> 开头。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-to___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0" id="markdown-toc-推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数"><strong>推荐</strong> 使用 <code class="highlighter-rouge">to___()</code> 来命名把对象的状态转换到一个新的对象的函数。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-as___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%8E%9F%E6%9D%A5%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0" id="markdown-toc-推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数"><strong>推荐</strong> 使用 <code class="highlighter-rouge">as___()</code> 来命名把原来对象转换为另外一种表现形式的函数。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E4%B8%AD%E6%8F%8F%E8%BF%B0%E5%8F%82%E6%95%B0" id="markdown-toc-避免-在方法或者函数名称中描述参数"><strong>避免</strong> 在方法或者函数名称中描述参数。</a></li>
      <li><a href="#%E8%A6%81-%E5%9C%A8%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E6%97%B6%E9%81%B5%E5%BE%AA%E7%8E%B0%E6%9C%89%E7%9A%84%E5%8A%A9%E8%AE%B0%E7%AC%A6%E7%BA%A6%E5%AE%9A" id="markdown-toc-要-在命名参数时遵循现有的助记符约定"><strong>要</strong> 在命名参数时，遵循现有的助记符约定。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%BA%93" id="markdown-toc-库">库</a>    <ul>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E5%A3%B0%E6%98%8E" id="markdown-toc-推荐-使用私有声明"><strong>推荐</strong> 使用私有声明。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E4%B8%AD" id="markdown-toc-考虑-声明多个类在一个库中"><strong>考虑</strong> 声明多个类在一个库中。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E7%B1%BB" id="markdown-toc-类">类</a>    <ul>
      <li><a href="#%E9%81%BF%E5%85%8D-%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BA%86%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E8%80%8C%E5%8E%BB%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8D%95%E4%B8%80%E6%88%90%E5%91%98%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB" id="markdown-toc-避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类"><strong>避免</strong> 避免为了使用一个简单的函数而去定义一个单一成员的抽象类</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%AE%9A%E4%B9%89%E4%BB%85%E5%8C%85%E5%90%AB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB" id="markdown-toc-避免-定义仅包含静态成员的类"><strong>避免</strong> 定义仅包含静态成员的类。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E9%9B%86%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB%E9%9B%86%E6%88%90%E7%9A%84%E7%B1%BB" id="markdown-toc-避免-集成一个不期望被集成的类"><strong>避免</strong> 集成一个不期望被集成的类。</a></li>
      <li><a href="#%E8%A6%81-%E6%8A%8A%E8%83%BD%E5%A4%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%B4%E6%98%8E%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%96%87%E6%A1%A3%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF" id="markdown-toc-要-把能够继承的说明添加到文档中如果这个类可以继承"><strong>要</strong> 把能够继承的说明添加到文档中，如果这个类可以继承。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E6%88%90%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E8%AF%A5%E7%B1%BB%E4%B8%8D%E6%83%B3%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E8%A2%AB%E5%AE%9E%E7%8E%B0" id="markdown-toc-避免-去实现一个不期望成为接口的类该类不想作为接口被实现"><strong>避免</strong> 去实现一个不期望成为接口的类（该类不想作为接口被实现）。</a></li>
      <li><a href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" id="markdown-toc-要-对支持接口的类在文档注明"><strong>要</strong> 对支持接口的类在文档注明</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%8E%BB-mixin-%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB-mixin-%E7%9A%84%E7%B1%BB" id="markdown-toc-避免-去-mixin-一个不期望被-mixin-的类"><strong>避免</strong> 去 mixin 一个不期望被 mixin 的类</a></li>
      <li><a href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81-mixin-%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" id="markdown-toc-要-对支持-mixin-的类在文档注明"><strong>要</strong> 对支持 mixin 的类在文档注明</a></li>
    </ul>
  </li>
  <li>
<a href="#constructors" id="markdown-toc-constructors">Constructors</a>    <ul>
      <li><a href="#prefer-defining-constructors-instead-of-static-methods-to-create-instances" id="markdown-toc-prefer-defining-constructors-instead-of-static-methods-to-create-instances">PREFER defining constructors instead of static methods to create instances.</a></li>
      <li><a href="#consider-making-your-constructor-const-if-the-class-supports-it" id="markdown-toc-consider-making-your-constructor-const-if-the-class-supports-it">CONSIDER making your constructor <code class="highlighter-rouge">const</code> if the class supports it.</a></li>
    </ul>
  </li>
  <li>
<a href="#members" id="markdown-toc-members">Members</a>    <ul>
      <li><a href="#prefer-making-fields-and-top-level-variables-final" id="markdown-toc-prefer-making-fields-and-top-level-variables-final">PREFER making fields and top-level variables <code class="highlighter-rouge">final</code>.</a></li>
      <li><a href="#do-use-getters-for-operations-that-conceptually-access-properties" id="markdown-toc-do-use-getters-for-operations-that-conceptually-access-properties">DO use getters for operations that conceptually access properties.</a></li>
      <li><a href="#do-use-setters-for-operations-that-conceptually-change-properties" id="markdown-toc-do-use-setters-for-operations-that-conceptually-change-properties">DO use setters for operations that conceptually change properties.</a></li>
      <li><a href="#dont-define-a-setter-without-a-corresponding-getter" id="markdown-toc-dont-define-a-setter-without-a-corresponding-getter">DON’T define a setter without a corresponding getter.</a></li>
      <li><a href="#avoid-returning-null-from-members-whose-return-type-is-bool-double-int-or-num" id="markdown-toc-avoid-returning-null-from-members-whose-return-type-is-bool-double-int-or-num">AVOID returning <code class="highlighter-rouge">null</code> from members whose return type is <code class="highlighter-rouge">bool</code>, <code class="highlighter-rouge">double</code>, <code class="highlighter-rouge">int</code>, or <code class="highlighter-rouge">num</code>.</a></li>
      <li><a href="#avoid-returning-this-from-methods-just-to-enable-a-fluent-interface" id="markdown-toc-avoid-returning-this-from-methods-just-to-enable-a-fluent-interface">AVOID returning <code class="highlighter-rouge">this</code> from methods just to enable a fluent interface.</a></li>
    </ul>
  </li>
  <li>
<a href="#types" id="markdown-toc-types">Types</a>    <ul>
      <li><a href="#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious" id="markdown-toc-prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious">PREFER type annotating public fields and top-level variables if the type isn’t obvious.</a></li>
      <li><a href="#consider-type-annotating-private-fields-and-top-level-variables-if-the-type-isnt-obvious" id="markdown-toc-consider-type-annotating-private-fields-and-top-level-variables-if-the-type-isnt-obvious">CONSIDER type annotating private fields and top-level variables if the type isn’t obvious.</a></li>
      <li><a href="#avoid-type-annotating-initialized-local-variables" id="markdown-toc-avoid-type-annotating-initialized-local-variables">AVOID type annotating initialized local variables.</a></li>
      <li><a href="#avoid-annotating-inferred-parameter-types-on-function-expressions" id="markdown-toc-avoid-annotating-inferred-parameter-types-on-function-expressions">AVOID annotating inferred parameter types on function expressions.</a></li>
      <li><a href="#avoid-redundant-type-arguments-on-generic-invocations" id="markdown-toc-avoid-redundant-type-arguments-on-generic-invocations">AVOID redundant type arguments on generic invocations.</a></li>
      <li><a href="#do-annotate-when-dart-infers-the-wrong-type" id="markdown-toc-do-annotate-when-dart-infers-the-wrong-type">DO annotate when Dart infers the wrong type.</a></li>
      <li><a href="#prefer-annotating-with-dynamic-instead-of-letting-inference-fail" id="markdown-toc-prefer-annotating-with-dynamic-instead-of-letting-inference-fail">PREFER annotating with <code class="highlighter-rouge">dynamic</code> instead of letting inference fail.</a></li>
      <li><a href="#prefer-signatures-in-function-type-annotations" id="markdown-toc-prefer-signatures-in-function-type-annotations">PREFER signatures in function type annotations.</a></li>
      <li><a href="#dont-specify-a-return-type-for-a-setter" id="markdown-toc-dont-specify-a-return-type-for-a-setter">DON’T specify a return type for a setter.</a></li>
      <li><a href="#dont-use-the-legacy-typedef-syntax" id="markdown-toc-dont-use-the-legacy-typedef-syntax">DON’T use the legacy typedef syntax.</a></li>
      <li><a href="#prefer-inline-function-types-over-typedefs" id="markdown-toc-prefer-inline-function-types-over-typedefs">PREFER inline function types over typedefs.</a></li>
      <li><a href="#consider-using-function-type-syntax-for-parameters" id="markdown-toc-consider-using-function-type-syntax-for-parameters">CONSIDER using function type syntax for parameters.</a></li>
      <li><a href="#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" id="markdown-toc-do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed">DO annotate with <code class="highlighter-rouge">Object</code> instead of <code class="highlighter-rouge">dynamic</code> to indicate any object is allowed.</a></li>
      <li><a href="#do-use-futurevoid-as-the-return-type-of-asynchronous-members-that-do-not-produce-values" id="markdown-toc-do-use-futurevoid-as-the-return-type-of-asynchronous-members-that-do-not-produce-values">DO use <code class="highlighter-rouge">Future&lt;void&gt;</code> as the return type of asynchronous members that do not produce values.</a></li>
      <li><a href="#avoid-using-futureort-as-a-return-type" id="markdown-toc-avoid-using-futureort-as-a-return-type">AVOID using <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> as a return type.</a></li>
    </ul>
  </li>
  <li>
<a href="#parameters" id="markdown-toc-parameters">Parameters</a>    <ul>
      <li><a href="#avoid-positional-boolean-parameters" id="markdown-toc-avoid-positional-boolean-parameters">AVOID positional boolean parameters.</a></li>
      <li><a href="#avoid-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters" id="markdown-toc-avoid-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters">AVOID optional positional parameters if the user may want to omit earlier parameters.</a></li>
      <li><a href="#avoid-mandatory-parameters-that-accept-a-special-no-argument-value" id="markdown-toc-avoid-mandatory-parameters-that-accept-a-special-no-argument-value">AVOID mandatory parameters that accept a special “no argument” value.</a></li>
      <li><a href="#do-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range" id="markdown-toc-do-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range">DO use inclusive start and exclusive end parameters to accept a range.</a></li>
    </ul>
  </li>
  <li>
<a href="#equality" id="markdown-toc-equality">Equality</a>    <ul>
      <li><a href="#do-override-hashcode-if-you-override-" id="markdown-toc-do-override-hashcode-if-you-override-">DO override <code class="highlighter-rouge">hashCode</code> if you override <code class="highlighter-rouge">==</code>.</a></li>
      <li><a href="#do-make-your--operator-obey-the-mathematical-rules-of-equality" id="markdown-toc-do-make-your--operator-obey-the-mathematical-rules-of-equality">DO make your <code class="highlighter-rouge">==</code> operator obey the mathematical rules of equality.</a></li>
      <li><a href="#avoid-defining-custom-equality-for-mutable-classes" id="markdown-toc-avoid-defining-custom-equality-for-mutable-classes">AVOID defining custom equality for mutable classes.</a></li>
      <li><a href="#dont-check-for-null-in-custom--operators" id="markdown-toc-dont-check-for-null-in-custom--operators">DON’T check for <code class="highlighter-rouge">null</code> in custom <code class="highlighter-rouge">==</code> operators.</a></li>
    </ul>
  </li>
</ul>

<h2 id="命名">
<a id="命名" class="anchor" href="#%E5%91%BD%E5%90%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a>命名</h2>

<p>命名是编写可读，可维护代码的重要部分。
以下最佳实践可帮助你实现这个目标。</p>

<h3 id="要-使用一致的术语">
<a id="要-使用一致的术语" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E7%9A%84%E6%9C%AF%E8%AF%AD" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用一致的术语。</h3>

<p>在你的代码中，同样的东西要使用同样的名字。
如果之前已经存在的 API 之外命名，并且用户已经熟知，
那么请继续使用这个命名。</p>

<pre class="prettyprint lang-dart good-style">pageCount         // A field.
updatePageCount() // Consistent with pageCount.
toSomething()     // Consistent with Iterable's toList().
asSomething()     // Consistent with List's asMap().
Point             // A familiar concept.</pre>

<pre class="prettyprint lang-dart bad-style">renumberPages()      // Confusingly different from pageCount.
convertToSomething() // Inconsistent with toX() precedent.
wrappedAsSomething() // Inconsistent with asX() precedent.
Cartesian            // Unfamiliar to most users.</pre>

<p>总的目的是充分利用用户已经知道的内容。
这里包括他们所了解的问题领域，所熟悉的核心库，以及你自己 API 那部分。
基于以上这些内容，他们在使用之前，不需要学习大量的新知识。</p>

<h3 id="避免-缩写">
<a id="避免-缩写" class="anchor" href="#%E9%81%BF%E5%85%8D-%E7%BC%A9%E5%86%99" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 缩写。</h3>

<p>只使用广为人知的缩写，对于特有领域的缩写，请避免使用。
如果要使用，请 <a href="/guides/language/effective-dart/style#identifiers">正确的指定首字母大小写</a>。</p>

<pre class="prettyprint lang-dart good-style">pageCount
buildRectangles
IOStream
HttpRequest</pre>

<pre class="prettyprint lang-dart bad-style">numPages    // "num" is an abbreviation of number(of)
buildRects
InputOutputStream
HypertextTransferProtocolRequest</pre>

<h3 id="推荐-把最具描述性的名词放到最后">
<a id="推荐-把最具描述性的名词放到最后" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E6%8A%8A%E6%9C%80%E5%85%B7%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%9A%84%E5%90%8D%E8%AF%8D%E6%94%BE%E5%88%B0%E6%9C%80%E5%90%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 把最具描述性的名词放到最后。</h3>

<p>最后一个词应该是最具描述性的东西。
你可以在其前面添加其他单词，例如形容词，以进一步描述该事物。</p>

<pre class="prettyprint lang-dart good-style">pageCount             // A count (of pages).
ConversionSink        // A sink for doing conversions.
ChunkedConversionSink // A ConversionSink that's chunked.
CssFontFaceRule       // A rule for font faces in CSS.</pre>

<pre class="prettyprint lang-dart bad-style">numPages                  // Not a collection of pages.
CanvasRenderingContext2D  // Not a "2D".
RuleFontFaceCss           // Not a CSS.</pre>

<h3 id="考虑-尽量让代码看起来像普通的句子">
<a id="考虑-尽量让代码看起来像普通的句子" class="anchor" href="#%E8%80%83%E8%99%91-%E5%B0%BD%E9%87%8F%E8%AE%A9%E4%BB%A3%E7%A0%81%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%83%8F%E6%99%AE%E9%80%9A%E7%9A%84%E5%8F%A5%E5%AD%90" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 尽量让代码看起来像普通的句子。</h3>

<p>当你不知道如何命名 API 的时候，
使用你的 API 编写些代码，试着让代码看起来像普通的句子。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (code-like-prose)"?>
<pre class="prettyprint lang-dart good-style">// "If errors is empty..."
if (errors.isEmpty) ...

// "Hey, subscription, cancel!"
subscription.cancel();

// "Get the monsters where the monster has claws."
monsters.where((monster) =&gt; monster.hasClaws);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (code-like-prose)" replace="/ as bool//g"?>
<pre class="prettyprint lang-dart bad-style">// Telling errors to empty itself, or asking if it is?
if (errors.empty) ...

// Toggle what? To what?
subscription.toggle();

// Filter the monsters with claws *out* or include *only* those?
monsters.filter((monster) =&gt; monster.hasClaws);</pre>

<p>尝试着使用你自己的 API，并且阅读写出来的代码，可以帮助你为 API 命名，但是不要过于冗余。
添加文章和其他词性以强制名字读起来就像语法正确的句子一样，是没用的。</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (code-like-prose-overdone)"?>
<pre class="prettyprint lang-dart bad-style">if (theCollectionOfErrors.isEmpty) ...

monsters.producesANewSequenceWhereEach((monster) =&gt; monster.hasClaws);</pre>

<h3 id="推荐-使用名词短语来命名不是布尔类型的变量和属性">
<a id="推荐-使用名词短语来命名不是布尔类型的变量和属性" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E4%B8%8D%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用名词短语来命名不是布尔类型的变量和属性。</h3>

<p>读者关注属性是<em>什么</em>。
如果用户更关心<em>如何</em>确定一个属性，则很可能应该是一个使用动词短语命名函数。</p>

<pre class="prettyprint lang-dart good-style">list.length
context.lineWidth
quest.rampagingSwampBeast</pre>

<pre class="prettyprint lang-dart bad-style">list.deleteItems</pre>

<h3 id="推荐-使用非命令式动词短语命名布尔类型的变量和属性">
<a id="推荐-使用非命令式动词短语命名布尔类型的变量和属性" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用非命令式动词短语命名布尔类型的变量和属性。</h3>

<p>布尔名称通常用在控制语句中当做条件，
因此你要应该让这个名字在控制语句中读起来语感很好。比较下面的两个：</p>

<pre class="prettyprint lang-dart">if (window.closeable) ...  // Adjective.
if (window.canClose) ...   // Verb.</pre>

<p>好的名字往往以某一种动词作为开头：</p>

<ul>
  <li>
    <p>“to be” 形式： <code class="highlighter-rouge">isEnabled</code>， <code class="highlighter-rouge">wasShown</code>， <code class="highlighter-rouge">willFire</code>。 
    就目前来看，这些时做常见的。</p>
  </li>
  <li>
    <p>一个 [辅助动词][]: <code class="highlighter-rouge">hasElements</code>， <code class="highlighter-rouge">canClose</code>，
<code class="highlighter-rouge">shouldConsume</code>， <code class="highlighter-rouge">mustSave</code>。</p>
  </li>
  <li>
    <p>一个主动动词： <code class="highlighter-rouge">ignoresInput</code>， <code class="highlighter-rouge">wroteFile</code>。
因为经常引起歧义，所以这种形式比较少见。
<code class="highlighter-rouge">loggedResult</code> 是一个不好的命名，因为它的意思可能是：
“whether or not a result was logged” 或者 “the result that was logged”。
<code class="highlighter-rouge">closingConnection</code> 的意思可能是：
“whether the connection is closing” 或者 “the connection that is closing”。
<em>只有</em> 当名字可以预期的时候才使用主动动词。</p>
  </li>
</ul>

<p>可以使用命令式动词来区分布尔变量名字和函数名字。
一个布尔变量的名字不应该看起来像一个命令，告诉这个对象做什么事情。
原因在于访问一个变量的属性并没有修改对象的状态。
（如果这个属性<em>确实</em>修改了对象的状态，则它应该是一个函数。）</p>

<pre class="prettyprint lang-dart good-style">isEmpty
hasElements
canClose
closesWindow
canShowPopup
hasShownPopup</pre>

<pre class="prettyprint lang-dart bad-style">empty         // Adjective or verb?
withElements  // Sounds like it might hold elements.
closeable     // Sounds like an interface.
              // "canClose" reads better as a sentence.
closingWindow // Returns a bool or a window?
showPopup     // Sounds like it shows the popup.</pre>

<aside class="alert alert-info">
  <p>这条规则有一个例外。 Angular组件中的输入属性有时会使用命令式动词来表示布尔设置器，
因为这些 setter 是在模板中调用的，而不是从其它 Dart 代码中调用的。</p>

</aside>

<h3 id="考虑-省略命名布尔参数的动词">
<a id="考虑-省略命名布尔参数的动词" class="anchor" href="#%E8%80%83%E8%99%91-%E7%9C%81%E7%95%A5%E5%91%BD%E5%90%8D%E5%B8%83%E5%B0%94%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E8%AF%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 省略命名布尔<em>参数</em>的动词。</h3>

<p>提炼于上一条规则。对于命名布尔参数，
没有动词的名称通常看起来更加舒服。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (omit-verb-for-bool-param)"?>
<pre class="prettyprint lang-dart good-style">Isolate.spawn(entryPoint, message, paused: false);
var copy = List.from(elements, growable: true);
var regExp = RegExp(pattern, caseSensitive: false);</pre>

<h3 id="考虑-为布尔属性或变量取肯定含义的名字">
<a id="考虑-为布尔属性或变量取肯定含义的名字" class="anchor" href="#%E8%80%83%E8%99%91-%E4%B8%BA%E5%B8%83%E5%B0%94%E5%B1%9E%E6%80%A7%E6%88%96%E5%8F%98%E9%87%8F%E5%8F%96%E8%82%AF%E5%AE%9A%E5%90%AB%E4%B9%89%E7%9A%84%E5%90%8D%E5%AD%97" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 为布尔属性或变量取“肯定”含义的名字。</h3>

<p>大多数布尔值名称具有概念形式上的“肯定”和“否定”，
前者感觉更现实基本描述，后者是对基本描述的否定，例如：
“open” 和 “closed”， “enabled” 和 “disabled”，等等。
通常后者的名称字面上有个前缀，用来否定前者：
“visible” 和 “<em>in</em>-visible”，
“connected” 和 “<em>dis</em>-connected”，
“zero” 和 “<em>non</em>-zero”。</p>

<p>当选择 <code class="highlighter-rouge">true</code> 代表两种情况中的其中一种情况
在布尔的两种情况中，当选择 <code class="highlighter-rouge">true</code> 代表其中一种情况，
或使用这种情况作为属性名称时，更倾向使用“肯定”或基本描述的方式。
布尔成员通常嵌套在逻辑表达式中，包括否定运算符。
如果属性本身读起来想是个“否定”的，
这将让读者耗费更多精力去阅读双重否定及理解代码的含义。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (positive)"?>
<pre class="prettyprint lang-dart good-style">if (socket.isConnected &amp;&amp; database.hasData) {
  socket.write(database.read());
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (positive)"?>
<pre class="prettyprint lang-dart bad-style">if (!socket.isDisconnected &amp;&amp; !database.isEmpty) {
  socket.write(database.read());
}</pre>

<p>上面规则中有一个例外，就是“否定”用户绝大多数用到的形式是。
选择“肯定”方式，将会迫使在他们到处使用 <code class="highlighter-rouge">!</code> 对属性进行取反操作。
这样相反，属性应该使用“否定”形式进行命名。</p>

<p>对于一些属性，没有明显的“肯定”形式。
文档已经刷新 “saved” 到磁盘，或者 “<em>un</em>-changed”？
文档还未属性 “<em>un</em>-saved” 到磁盘，或者 “changed”？
在模棱两可的情况下，倾向于选择不太可能被用户否定或较短的名字。</p>

<h3 id="推荐-使用命令式动词短语来命名带有副作用的函数或者方法">
<a id="推荐-使用命令式动词短语来命名带有副作用的函数或者方法" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%9D%A5%E5%91%BD%E5%90%8D%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用命令式动词短语来命名带有副作用的函数或者方法。</h3>

<p>函数通常返回一个结果给调用者，并且执行一些任务或者带有副作用。
在像 Dart 这种命令式语言中，调用函数通常为了实现其副作用：
可能改变了对象的内部状态、
产生一些输出内容、或者和外部世界沟通等。</p>

<p>这种类型的成员应该使用命令式动词短语来命名，强调
该成员所执行的任务。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (verb-for-func-with-side-effect)"?>
<pre class="prettyprint lang-dart good-style">list.add("element");
queue.removeFirst();
window.refresh();</pre>

<p>这样调用的代码看起来就像是要执行某个任务的命令。</p>

<h3 id="考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数">
<a id="考虑-使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数" class="anchor" href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD%E6%88%96%E8%80%85%E9%9D%9E%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数。</h3>

<p>虽然这些函数可能也有副作用，但是其主要目的是返回一个数据给调用者。
如果该函数无需参数通常应该是一个 getter 。
有时候获取一个属性则需要一些参数，比如，
<code class="highlighter-rouge">elementAt()</code> 从集合中返回一个数据，但是需要一个指定返回那个数据的参数。</p>

<p>在<em>语法</em>上看这是一个函数，其实<em>严格来说</em>其返回的是集合中的一个属性，
应该使用一个能够表示该函数返回的是<em>什么</em>的词语来命名。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (noun-for-func-returning-value)"?>
<pre class="prettyprint lang-dart good-style">var element = list.elementAt(3);
var first = list.firstWhere(test);
var char = string.codeUnitAt(4);</pre>

<p>这条规则比前一条要宽松一些。有时候一些
函数没有副作用，但仍然使用一个动词短语来命名，例如：
<code class="highlighter-rouge">list.take()</code> 或者 <code class="highlighter-rouge">string.split()</code>。</p>

<h3 id="考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视">
<a id="考虑-使用命令式动词短语命名一个函数或方法若果你希望它的执行能被重视" class="anchor" href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95%E8%8B%A5%E6%9E%9C%E4%BD%A0%E5%B8%8C%E6%9C%9B%E5%AE%83%E7%9A%84%E6%89%A7%E8%A1%8C%E8%83%BD%E8%A2%AB%E9%87%8D%E8%A7%86" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 使用命令式动词短语命名一个函数或方法，若果你希望它的执行能被重视。</h3>

<p>当一个成员产生的结果没有额外的影响，它通常应该使用一个 getter 或者一个名词短语描述来命名，用于描述它返回的结果。
但是，有时候执行产生的结果很重要。
它可能容易导致运行时故障，或者使用重量级的资源（例如，网络或文件 I/O）。
在这种情况下，你希望调用者考虑成员在进行的工作，
这时，为成员提供描述该工作的动词短语。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (verb-for-func-with-work)"?>
<pre class="prettyprint lang-dart good-style">var table = database.downloadData();
var packageVersions = packageGraph.solveConstraints();</pre>

<p>但请注意，此准则比前两个更宽松。操作执行工作的实现细节通常与调用这无关，
并且性能和健壮性是随时间经常改变的。
大多数情况下，根据成员为调用者做了“什么”来命名，而不是“如何”做。</p>

<h3 id="避免-在方法命名中使用-get-开头">
<a id="避免-在方法命名中使用-get-开头" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E4%B8%AD%E4%BD%BF%E7%94%A8-get-%E5%BC%80%E5%A4%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在方法命名中使用 <code class="highlighter-rouge">get</code> 开头。</h3>

<p>在大多数情况下，getter 方法名称中应该移除 <code class="highlighter-rouge">get</code> 。
例如，定义一个名为 <code class="highlighter-rouge">breakfastOrder</code> 的 getter 方法，
来替代名为 <code class="highlighter-rouge">getBreakfastOrder()</code> 的方法。</p>

<p>即使成员因为需要传入参数或者 getter 不适用，
而需要通过方法来实现，也应该避免使用 <code class="highlighter-rouge">get</code> 开头。
与之前的准则一样：</p>

<ul>
  <li>
    <p>如果调用者主要关心的是方法的返回值，只需删除 <code class="highlighter-rouge">get</code> 并使用<a href="#prefer-a-noun-phrase-or-non-imperative-verb-phrase-for-a-function-or-method-if-returning-a-value-is-its-primary-purpose">名词短语</a>命名，
如 <code class="highlighter-rouge">breakfastOrder()</code> 。</p>
  </li>
  <li>
    <p>如果调用者关心的是正在完成的工作，请使用<a href="#consider-an-imperative-verb-phrase-for-a-function-or-method-if-you-want-to-draw-attention-to-the-work-it-performs">动名词短语</a>命名，
这种情况下应该选择一个更能准确描述工作的动名词，而不是使用 <code class="highlighter-rouge">get</code> 命名，
如 <code class="highlighter-rouge">create</code>， <code class="highlighter-rouge">download</code>， <code class="highlighter-rouge">fetch</code>， <code class="highlighter-rouge">calculate</code>， <code class="highlighter-rouge">request</code>， <code class="highlighter-rouge">aggregate</code>，等等。</p>
  </li>
</ul>

<h3 id="推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数">
<a id="推荐-使用-to___-来命名把对象的状态转换到一个新的对象的函数" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-to___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用 <code class="highlighter-rouge">to___()</code> 来命名把对象的状态转换到一个新的对象的函数。</h3>

<p>一个转换函数返回一个新的对象，里面包含一些原对象的状态，但通常新对象的形式或表现方式与原对象不同。
核心库有一个约定，这些类型结果的方法名应该以 <code class="highlighter-rouge">to</code> 作为开头。</p>

<p>如果要定义一个转换函数，遵循该约定是非常有益的。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (to___)"?>
<pre class="prettyprint lang-dart good-style">list.toSet();
stackTrace.toString();
dateTime.toLocal();</pre>

<h3 id="推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数">
<a id="推荐-使用-as___-来命名把原来对象转换为另外一种表现形式的函数" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-as___-%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8A%8A%E5%8E%9F%E6%9D%A5%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用 <code class="highlighter-rouge">as___()</code> 来命名把原来对象转换为另外一种表现形式的函数。</h3>

<p>转换函数提供的是“快照功能”。返回的对象有自己的数据副本，
修改原来对象的数据不会改变返回的对象中的数据。
另外一种函数返回的是同一份数据的另外一种表现形式，返回的是一个新的对象，
但是其内部引用的数据和原来对象引用的数据一样。
修改原来对象中的数据，新返回的对象中的数据也一起被修改。</p>

<p>这种函数在核心库中被命名为 <code class="highlighter-rouge">as___()</code>。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (as___)"?>
<pre class="prettyprint lang-dart good-style">var map = table.asMap();
var list = bytes.asFloat32List();
var future = subscription.asFuture();</pre>

<h3 id="避免-在方法或者函数名称中描述参数">
<a id="避免-在方法或者函数名称中描述参数" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E4%B8%AD%E6%8F%8F%E8%BF%B0%E5%8F%82%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在方法或者函数名称中描述参数。</h3>

<p>在调用代码的时候可以看到参数，所以无需再次显示参数了。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-desc-param-in-func)"?>
<pre class="prettyprint lang-dart good-style">list.add(element);
map.remove(key);</pre>

<pre class="prettyprint lang-dart bad-style">list.addElement(element)
map.removeKey(key)</pre>

<p>但是，对于具有多个类似的函数的时候，使用参数名字可以消除歧义，
这个时候应该带有参数名字。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (desc-param-in-func-ok)"?>
<pre class="prettyprint lang-dart good-style">map.containsKey(key);
map.containsValue(value);</pre>

<h3 id="要-在命名参数时遵循现有的助记符约定">
<a id="要-在命名参数时遵循现有的助记符约定" class="anchor" href="#%E8%A6%81-%E5%9C%A8%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E6%97%B6%E9%81%B5%E5%BE%AA%E7%8E%B0%E6%9C%89%E7%9A%84%E5%8A%A9%E8%AE%B0%E7%AC%A6%E7%BA%A6%E5%AE%9A" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 在命名参数时，遵循现有的助记符约定。</h3>

<p>单字母命名没有直接的启发性，但是几乎所有通用类型都使用时情况就不一样了。
幸运的是，它们大多数以一致的助记方式在使用，这些约定如下：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">E</code> 用于集合中的 <strong>元素</strong> 类型:</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-e)" replace="/\n\n/\n/g"?>
    <pre class="prettyprint lang-dart good-style">class IterableBase&lt;E&gt; {}
class List&lt;E&gt; {}
class HashSet&lt;E&gt; {}
class RedBlackTree&lt;E&gt; {}</pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">K</code> 和 <code class="highlighter-rouge">V</code> 分别用于关联集合中的 <strong>key</strong> 和 <strong>value</strong> 类型：</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-k-v)" replace="/\n\n/\n/g"?>
    <pre class="prettyprint lang-dart good-style">class Map&lt;K, V&gt; {}
class Multimap&lt;K, V&gt; {}
class MapEntry&lt;K, V&gt; {}</pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">R</code> 用于函数或类方法的 <strong>返回值</strong> 类型。 这种情况并不常见，
但有时会出现在typedef中，或实现访问者模式的类中：</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-r)"?>
    <pre class="prettyprint lang-dart good-style">abstract class ExpressionVisitor&lt;R&gt; {
  R visitBinary(BinaryExpression node);
  R visitLiteral(LiteralExpression node);
  R visitUnary(UnaryExpression node);
}</pre>
  </li>
  <li>
    <p>除此以外，对于具有单个类型参数的泛型，如果助记符能在周围类型中明显表达泛型含义，
请使用<code class="highlighter-rouge">T</code>，<code class="highlighter-rouge">S</code> 和 <code class="highlighter-rouge">U</code> 。
这里允许多个字母嵌套且不会与周围命名产生歧义。例如：</p>

    <?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-t)"?>
    <pre class="prettyprint lang-dart good-style">class Future&lt;T&gt; {
  Future&lt;S&gt; then&lt;S&gt;(FutureOr&lt;S&gt; onValue(T value)) =&gt; ...
}</pre>

    <p>这里，通常 <code class="highlighter-rouge">then&lt;S&gt;()</code> 方法使用 <code class="highlighter-rouge">S</code> 避免 <code class="highlighter-rouge">Future&lt;T&gt;</code> 中的 <code class="highlighter-rouge">T</code> 产生歧义。</p>
  </li>
</ul>

<p>如果上述情况都不合适，则可以使用另一个单字母助记符名称或描述性的名称：</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (type-parameter-graph)"?>
<pre class="prettyprint lang-dart good-style">class Graph&lt;N, E&gt; {
  final List&lt;N&gt; nodes = [];
  final List&lt;E&gt; edges = [];
}

class Graph&lt;Node, Edge&gt; {
  final List&lt;Node&gt; nodes = [];
  final List&lt;Edge&gt; edges = [];
}</pre>

<p>在实践中，以上的约定涵盖了大多数参数类型。</p>

<h2 id="库">
<a id="库" class="anchor" href="#%E5%BA%93" aria-hidden="true"><span class="octicon octicon-link"></span></a>库</h2>

<p>以 ( <code class="highlighter-rouge">_</code> ) 开头的成员只能在其库的内部被访问，是库的私有成员。
这是 Dart 语言的内置特性，不仅仅是惯例。</p>

<h3 id="推荐-使用私有声明">
<a id="推荐-使用私有声明" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E5%A3%B0%E6%98%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用私有声明。</h3>

<p>库中的公开声明—顶级定义或者在类中定义—是一种信号，
表示其他库可以并应该访问这些成员。
同时公开声明也是一种你的库需要实现的契约，
当使用这些成员的时候，应该实现其宣称的功能。</p>

<p>如果某个成员你不希望公开，则在成员名字之前添加一个 <code class="highlighter-rouge">_</code> 即可。
减少公开的接口让你的库更容易维护，也让用户更加容易掌握你的库如何使用。</p>

<p>另外，分析工具还可以分析出没有用到的私有成员定义，然后告诉你可以删除这些无用的代码。
私有成员第三方代码无法调用而你自己在库中也没有使用，所以是无用的代码。</p>

<h3 id="考虑-声明多个类在一个库中">
<a id="考虑-声明多个类在一个库中" class="anchor" href="#%E8%80%83%E8%99%91-%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E4%B8%AD" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 声明多个类在一个库中。</h3>

<p>一些其他语言，比如 Java。将文件结构和类结构进行捆绑&amp;mdash：每个文件仅能定义一个顶级类。
Dart 没有这样的限制。库与类是相互独立的。如果多个类，顶级变量，以及函数，他们再逻辑上
归为同一类，那么将他们包含到单一的库中，这样做是非常棒的。</p>

<p>将多个类组织到一个库中，就可以使用一些有用的模式。因为在 Dart 中私有特性是在库级别上有效，
而不是在类级别，基于这个模式你可以定义类似于 C++ 中的 “friend” 类。所有定义在同一个库中
的类可以互相访问彼此的私有成员，但库以外的代码无法发访问。</p>

<p>当然，该规则并不意味着你<em>应该</em>将你所有的类组织到一个庞大单一的库中，规则只是说允许你将多
个类组织到一个库中。</p>

<h2 id="类">
<a id="类" class="anchor" href="#%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>类</h2>

<p>Dart是一种 “纯粹的” 面向对象语言，因为所有对象都是类的实例。但是 Dart 并没有要求所有代码都
定义到类中— 类似在面向过程或函数的语言，你可以在 Dart 中定义顶级变量，常量，以及函数。</p>

<h3 id="避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类">
<a id="避免-避免为了使用一个简单的函数而去定义一个单一成员的抽象类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BA%86%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E8%80%8C%E5%8E%BB%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8D%95%E4%B8%80%E6%88%90%E5%91%98%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 避免为了使用一个简单的函数而去定义一个单一成员的抽象类</h3>

<p>和 Java 不同，Dart 拥有一等公民的函数，闭包，以及它们简洁的使用语法。如果你仅仅是需要一个
类似于回调的功能，那么使用函数即可。 例如如果你正在定义一个类，并且它仅拥有一个毫无意义名称的
抽象成员，如 <code class="highlighter-rouge">call</code> 或 <code class="highlighter-rouge">invoke</code> ，那么这时你很可能只是需要一个函数。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (one-member-abstract-class)"?>
<pre class="prettyprint lang-dart good-style">typedef Predicate&lt;E&gt; = bool Function(E element);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (one-member-abstract-class)"?>
<pre class="prettyprint lang-dart bad-style">abstract class Predicate&lt;E&gt; {
  bool test(E element);
}</pre>

<h3 id="避免-定义仅包含静态成员的类">
<a id="避免-定义仅包含静态成员的类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%AE%9A%E4%B9%89%E4%BB%85%E5%8C%85%E5%90%AB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 定义仅包含静态成员的类。</h3>

<p>在 Java 和 C# 中，所有的定义<em>必须</em>要在类中。所有常常会看到一些这样的类，这些
类中仅仅放置了些静态成员。其他类仅用于命名空间—一种为一堆成员提供共享
前缀将它们相互关联或避免名称冲突的方法。</p>

<p>Dart 拥有一等公民的函数，变量，以及常量，所以你不<em>需要</em>通过类来定义这些东西。
如果你想要的是一个命名空间，那么使用库即可。库支持导入前缀和显示/隐藏组合器。
这些功能强大的工具可让代码的开发者以最适合他们的方式处理名称冲突。</p>

<p>如果函数或变量在逻辑上与类无关，那么应该将其置于顶层。如果担心名称冲突，
那么请为其指定更精确的名称，或将其移动到可以使用前缀导入的单独库中。</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (class-only-static)"?>
<pre class="prettyprint lang-dart good-style">DateTime mostRecent(List&lt;DateTime&gt; dates) {
  return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);
}

const _favoriteMammal = 'weasel';</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (class-only-static)"?>
<pre class="prettyprint lang-dart bad-style">class DateUtils {
  static DateTime mostRecent(List&lt;DateTime&gt; dates) {
    return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);
  }
}

class _Favorites {
  static const mammal = 'weasel';
}</pre>

<p>通常在 Dart 中，类定义了<em>一类对象</em>。一个类型，如果类型从来没有被初始化，
那么这是另一种的代码气息。</p>

<p>当然，这并不是一条硬性规则。对于常量和类似枚举的类型，将它们组合在一个类
中看起来也是很自然。</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (class-only-static-exception)"?>
<pre class="prettyprint lang-dart good-style">class Color {
  static const red = '#f00';
  static const green = '#0f0';
  static const blue = '#00f';
  static const black = '#000';
  static const white = '#fff';
}</pre>

<h3 id="避免-集成一个不期望被集成的类">
<a id="避免-集成一个不期望被集成的类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E9%9B%86%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB%E9%9B%86%E6%88%90%E7%9A%84%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 集成一个不期望被集成的类。</h3>

<p>如果一个类的构造函数从生成构造函数被更改为工厂构造函数，则调用该构造函数的任何子类构造函数都
将失败。 此外，如果一个类改变了它在 <code class="highlighter-rouge">this</code> 上调用的自己的方法，那么覆盖这些方法并期望他们在
某些点被调用的子类再调用时会失败。</p>

<p>以上两种情况都意味着一个类需要考虑是否要允许被子类化。这种情况可以通过文档注释来沟通，或者为类
提供一个显示命名，如 <code class="highlighter-rouge">IterableBase</code>。如果该类的作者不这样做，最好假设你<em>不</em>能够继承这个类。
否则，后续对它的修改可能会破坏你的代码。</p>

<h3 id="要-把能够继承的说明添加到文档中如果这个类可以继承">
<a id="要-把能够继承的说明添加到文档中如果这个类可以继承" class="anchor" href="#%E8%A6%81-%E6%8A%8A%E8%83%BD%E5%A4%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%B4%E6%98%8E%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%96%87%E6%A1%A3%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 把能够继承的说明添加到文档中，如果这个类可以继承。</h3>

<p>该规则是上条规则的结果。如果允许你的类被子类化，请在文档中说明情况。使用 <code class="highlighter-rouge">Base</code> 作为类名的后缀，
或者在类的注释文档中注明。</p>

<h3 id="避免-去实现一个不期望成为接口的类该类不想作为接口被实现">
<a id="避免-去实现一个不期望成为接口的类该类不想作为接口被实现" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E6%88%90%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E8%AF%A5%E7%B1%BB%E4%B8%8D%E6%83%B3%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E8%A2%AB%E5%AE%9E%E7%8E%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 去实现一个不期望成为接口的类（该类不想作为接口被实现）。</h3>

<p>隐式接口是Dart中的一个强大工具，当一个类中可以很容易的推断出一些已经约定的有特征的实现时，
隐式接口可以避免重复定义这个类的约定。</p>

<p>但是通过类的隐式接口实现的新类，新类会与这个类产生非常紧密的耦合。也就是说，对于接口类的
<em>任何</em>修改，你实现的新类都会被破坏。例如，向类中添加新成员通常是安全，不会产生破坏性的改变。
但是如果你实现了这个类的接口，那么现在你的类会产生一个静态错误，因为它缺少了新方法的实现。</p>

<p>库的维护人员需要能够在不破坏用户代码的情况下迭代现有的累。如果把每个类都看待成是暴露给用户
的接口，用户可以自由的实现，这时修改这些类将变得非常困难。反过来，这个困难将导致你的库
迭代缓慢，从而无法适应新的需求。</p>

<p>为了给你的类的开发人员提供更多的余地，避免实现隐式接口，除非那些类明确需要实现。否则，
你可能会引入开发者没有预料到的耦合情况，这样可能会在没有意识到的情况下破坏你的代码。</p>

<h3 id="要-对支持接口的类在文档注明">
<a id="要-对支持接口的类在文档注明" class="anchor" href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 对支持接口的类在文档注明</h3>

<p>如果你的类可以被用作接口，那么将这个情况注明到类的文档中。</p>

<h3 id="避免-去-mixin-一个不期望被-mixin-的类">
<a id="避免-去-mixin-一个不期望被-mixin-的类" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%8E%BB-mixin-%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9C%9F%E6%9C%9B%E8%A2%AB-mixin-%E7%9A%84%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 去 mixin 一个不期望被 mixin 的类</h3>

<p>如果在一个类中定义了一个之前从来没有被定义过的构造函数，那么这会破坏已被混入的其他类。
在类中，这样看似无害的变化，并且对 mixin 的限制和并不为其他人说知。作者可能会添加一
个构造函数但并没有意识到它会破坏你 mixin 到它里的类。</p>

<p>与子类化一样，这意味着需要考虑一个类是否允许用于 mixin。如果该类没有文档注释或明显的名称，
如 <code class="highlighter-rouge">IterableMixin</code> ，你应该假设你不能 mix 这个类。</p>

<h3 id="要-对支持-mixin-的类在文档注明">
<a id="要-对支持-mixin-的类在文档注明" class="anchor" href="#%E8%A6%81-%E5%AF%B9%E6%94%AF%E6%8C%81-mixin-%E7%9A%84%E7%B1%BB%E5%9C%A8%E6%96%87%E6%A1%A3%E6%B3%A8%E6%98%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 对支持 mixin 的类在文档注明</h3>

<p>在类的文档中要提到，这个类是否可以或必须用于 mixin 。如果你的类被设计只作为 mixin 使用，
那么考虑在类名以 <code class="highlighter-rouge">Mixin</code> 结尾。</p>

<h2 id="constructors">
<a id="constructors" class="anchor" href="#constructors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructors</h2>

<p>Dart constructors are created by declaring a function with the same name as the
class and, optionally, an additional identifier. The latter are called <em>named
constructors</em>.</p>

<h3 id="prefer-defining-constructors-instead-of-static-methods-to-create-instances">
<a id="prefer-defining-constructors-instead-of-static-methods-to-create-instances" class="anchor" href="#prefer-defining-constructors-instead-of-static-methods-to-create-instances" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER defining constructors instead of static methods to create instances.</h3>

<p>Constructors are invoked using <code class="highlighter-rouge">new</code> or <code class="highlighter-rouge">const</code>, which communicates
that the main purpose of the call is to return an instance of the class
(or at least something that implements its interface).</p>

<p>You never <em>need</em> to use a static method to create an instance. Named
constructors let you clarify how the object is created, and factory
constructors let you construct instances of subclasses or
subinterfaces when appropriate.</p>

<p>Still, some methods that technically create a new object don’t feel
“constructor-like”. For example, <a href="https://api.dartlang.org/stable/dart-core/Uri/parse.html"><code class="highlighter-rouge">Uri.parse()</code></a> is a static method
even though it creates a new URI from the given arguments. Likewise, classes
implementing the <a href="http://en.wikipedia.org/wiki/Builder_pattern">Builder pattern</a> may read better using static methods.</p>

<p>But, in most cases, you should use a constructor even though it’s more verbose.
When users want a new instance of your class, they expect a constructor to be
the normal way to create one.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (named-ctr)"?>
<pre class="prettyprint lang-dart good-style">class Point {
  num x, y;
  Point(this.x, this.y);
  Point.polar(num theta, num radius)
      : x = radius * cos(theta),
        y = radius * sin(theta);
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (named-ctr)"?>
<pre class="prettyprint lang-dart bad-style">class Point {
  num x, y;
  Point(this.x, this.y);
  static Point polar(num theta, num radius) =&gt;
      Point(radius * cos(theta), radius * sin(theta));
}</pre>

<h3 id="consider-making-your-constructor-const-if-the-class-supports-it">
<a id="consider-making-your-constructor-const-if-the-class-supports-it" class="anchor" href="#consider-making-your-constructor-const-if-the-class-supports-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>CONSIDER making your constructor <code class="highlighter-rouge">const</code> if the class supports it.</h3>

<p>If you have a class where all the fields are final, and the constructor does
nothing but initialize them, you can make that constructor <code class="highlighter-rouge">const</code>. That lets
users create instances of your class in places where constants are
required—inside other larger constants, switch cases, default parameter
values, etc.</p>

<p>If you don’t explicitly make it <code class="highlighter-rouge">const</code>, they aren’t able to do that.</p>

<p>Note, however, that a <code class="highlighter-rouge">const</code> constructor is a commitment in your public API. If
you later change the constructor to non-<code class="highlighter-rouge">const</code>, it will break users that are
calling it in constant expressions. If you don’t want to commit to that, don’t
make it <code class="highlighter-rouge">const</code>. In practice, <code class="highlighter-rouge">const</code> constructors are most useful for simple,
immutable data record sorts of classes.</p>

<h2 id="members">
<a id="members" class="anchor" href="#members" aria-hidden="true"><span class="octicon octicon-link"></span></a>Members</h2>

<p>A member belongs to an object and can be either methods or instance variables.</p>

<h3 id="prefer-making-fields-and-top-level-variables-final">
<a id="prefer-making-fields-and-top-level-variables-final" class="anchor" href="#prefer-making-fields-and-top-level-variables-final" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER making fields and top-level variables <code class="highlighter-rouge">final</code>.</h3>

<p>State that is not <em>mutable</em>—that does not change over time—is
easier for programmers to reason about. Classes and libraries that minimize the
amount of mutable state they work with tend to be easier to maintain.</p>

<p>Of course, it is often useful to have mutable data. But, if you don’t need it,
your default should be to make fields and top-level variables <code class="highlighter-rouge">final</code> when you
can.</p>

<h3 id="do-use-getters-for-operations-that-conceptually-access-properties">
<a id="do-use-getters-for-operations-that-conceptually-access-properties" class="anchor" href="#do-use-getters-for-operations-that-conceptually-access-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use getters for operations that conceptually access properties.</h3>

<p>Deciding when a member should be a getter versus a method is a challenging,
subtle, but important part of good API design, hence this very long guideline.
Some other language’s cultures shy away from getters. They only use them when
the operation is almost exactly like a field—it does a miniscule amount of
calculation on state that lives entirely on the object. Anything more complex or
heavyweight than that gets <code class="highlighter-rouge">()</code> after the name to signal “computation goin’ on
here!” because a bare name after a <code class="highlighter-rouge">.</code> means “field”.</p>

<p>Dart is <em>not</em> like that. In Dart, <em>all</em> dotted names are member invocations that
may do computation. Fields are special—they’re getters whose
implementation is provided by the language. In other words, getters are not
“particularly slow fields” in Dart; fields are “particularly fast getters”.</p>

<p>Even so, choosing a getter over a method sends an important signal to the
caller. The signal, roughly, is that the operation is “field-like”. The
operation, at least in principle, <em>could</em> be implemented using a field, as far
as the caller knows. That implies:</p>

<ul>
  <li>
    <p><strong>The operation does not take any arguments and returns a result.</strong></p>
  </li>
  <li>
    <p><strong>The caller cares mostly about the result.</strong> If you want the caller to
worry about <em>how</em> the operation produces its result more than they do the
result being produced, then give the operation a verb name that describes
the work and make it a method.</p>

    <p>This does <em>not</em> mean the operation has to be particularly fast in order to
be a getter. <code class="highlighter-rouge">IterableBase.length</code> is <code class="highlighter-rouge">O(n)</code>, and that’s OK. It’s fine for a
getter to do significant calculation. But if it does a <em>surprising</em> amount
of work, you may want to draw their attention to that by making it a method
whose name is a verb describing what it does.</p>

    <pre class="prettyprint lang-dart bad-style">connection.nextIncomingMessage; // Does network I/O.
expression.normalForm; // Could be exponential to calculate.</pre>
  </li>
  <li>
    <p><strong>The operation does not have user-visible side effects.</strong> Accessing a real
field does not alter the object or any other state in the program. It
doesn’t produce output, write files, etc. A getter shouldn’t do those things
either.</p>

    <p>The “user-visible” part is important. It’s fine for getters to modify hidden
state or produce out of band side effects. Getters can lazily calculate and
store their result, write to a cache, log stuff, etc. As long as the caller
doesn’t <em>care</em> about the side effect, it’s probably fine.</p>

    <pre class="prettyprint lang-dart bad-style">stdout.newline; // Produces output.
list.clear; // Modifies object.</pre>
  </li>
  <li>
    <p><strong>The operation is <em>idempotent</em>.</strong> “Idempotent” is an odd word that, in this
context, basically means that calling the operation multiple times produces
the same result each time, unless some state is explicitly modified between
those calls. (Obviously, <code class="highlighter-rouge">list.length</code> produces different results if you add
an element to the list between calls.)</p>

    <p>“Same result” here does not mean a getter must literally produce an
identical object on successive calls. Requiring that would force many
getters to have brittle caching, which negates the whole point of using a
getter. It’s common, and perfectly fine, for a getter to return a new future
or list each time you call it. The important part is that the future
completes to the same value, and the list contains the same elements.</p>

    <p>In other words, the result value should be the same <em>in the aspects that the
caller cares about.</em></p>

    <pre class="prettyprint lang-dart bad-style">DateTime.now; // New result each time.</pre>
  </li>
  <li>
    <p><strong>The resulting object doesn’t expose all of the original object’s state.</strong>
A field exposes only a piece of an object. If your operation returns a
result that exposes the original object’s entire state, it’s likely better
off as a <a href="#prefer-naming-a-method-to___-if-it-copies-the-objects-state-to-a-new-object"><code class="highlighter-rouge">to___()</code></a> or <a href="#prefer-naming-a-method-as___-if-it-returns-a-different-representation-backed-by-the-original-object"><code class="highlighter-rouge">as___()</code></a> method.</p>
  </li>
</ul>

<p>If all of the above describe your operation, it should be a getter. It seems
like few members would survive that gauntlet, but surprisingly many do. Many
operations just do some computation on some state and most of those can and
should be getters.</p>

<pre class="prettyprint lang-dart good-style">rectangle.area;
collection.isEmpty;
button.canShow;
dataSet.minimumValue;</pre>

<h3 id="do-use-setters-for-operations-that-conceptually-change-properties">
<a id="do-use-setters-for-operations-that-conceptually-change-properties" class="anchor" href="#do-use-setters-for-operations-that-conceptually-change-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use setters for operations that conceptually change properties.</h3>

<p>Deciding between a setter versus a method is similar to deciding between a
getter versus a method. In both cases, the operation should be “field-like”.</p>

<p>For a setter, “field-like” means:</p>

<ul>
  <li>
    <p><strong>The operation takes a single argument and does not produce a result
value.</strong></p>
  </li>
  <li>
    <p><strong>The operation changes some state in the object.</strong></p>
  </li>
  <li>
    <p><strong>The operation is idempotent.</strong> Calling the same setter twice with the same
value should do nothing the second time as far as the caller is concerned.
Internally, maybe you’ve got some cache invalidation or logging going on.
That’s fine. But from the caller’s perspective, it appears that the second
call does nothing.</p>
  </li>
</ul>

<pre class="prettyprint lang-dart good-style">rectangle.width = 3;
button.visible = false;</pre>

<h3 id="dont-define-a-setter-without-a-corresponding-getter">
<a id="dont-define-a-setter-without-a-corresponding-getter" class="anchor" href="#dont-define-a-setter-without-a-corresponding-getter" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T define a setter without a corresponding getter.</h3>

<p>Users think of getters and setters as visible properties of an object. A
“dropbox” property that can be written to but not seen is confusing and
confounds their intuition about how properties work. For example, a setter
without a getter means you can use <code class="highlighter-rouge">=</code> to modify it, but not <code class="highlighter-rouge">+=</code>.</p>

<p>This guideline does <em>not</em> mean you should add a getter just to permit the setter
you want to add. Object’s shouldn’t generally expose more state than they need
to. If you have some piece of an object’s state that can be modified but not
exposed in the same way, use a method instead.</p>

<aside class="alert alert-info">
  <p>There is one exception to this rule. An <a href="https://webdev.dartlang.org/angular">Angular</a> component class may expose
setters that are invoked from a template to initialize the component. Often,
these setters are not intended to be invoked from Dart code and don’t need a
corresponding getter. (If they are used from Dart code, they <em>should</em> have a
getter.)</p>

</aside>

<h3 id="avoid-returning-null-from-members-whose-return-type-is-bool-double-int-or-num">
<a id="avoid-returning-null-from-members-whose-return-type-is-bool-double-int-or-num" class="anchor" href="#avoid-returning-null-from-members-whose-return-type-is-bool-double-int-or-num" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID returning <code class="highlighter-rouge">null</code> from members whose return type is <code class="highlighter-rouge">bool</code>, <code class="highlighter-rouge">double</code>, <code class="highlighter-rouge">int</code>, or <code class="highlighter-rouge">num</code>.</h3>

<p>Even though all types are nullable in Dart, users assume those types almost
never contain <code class="highlighter-rouge">null</code>, and the lowercase names encourage a “Java primitive”
mindset.</p>

<p>It can be occasionally useful to have a “nullable primitive” type in your API,
for example to indicate the absence of a value for some key in a map, but these
should be rare.</p>

<p>If you do have a member of this type that may return <code class="highlighter-rouge">null</code>, document it very
clearly, including the conditions under which <code class="highlighter-rouge">null</code> will be returned.</p>

<h3 id="avoid-returning-this-from-methods-just-to-enable-a-fluent-interface">
<a id="avoid-returning-this-from-methods-just-to-enable-a-fluent-interface" class="anchor" href="#avoid-returning-this-from-methods-just-to-enable-a-fluent-interface" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID returning <code class="highlighter-rouge">this</code> from methods just to enable a fluent interface.</h3>

<p>Method cascades are a better solution for chaining method calls.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (cascades)"?>
<pre class="prettyprint lang-dart good-style">var buffer = StringBuffer()
  ..write('one')
  ..write('two')
  ..write('three');</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (cascades)"?>
<pre class="prettyprint lang-dart bad-style">var buffer = StringBuffer()
    .write('one')
    .write('two')
    .write('three');</pre>

<h2 id="types">
<a id="types" class="anchor" href="#types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Types</h2>

<p>When you write down a type in your program, you constrain the kinds of values
that flow into different parts of your code. Types can appear in two kinds of
places: <em>type annotations</em> on declarations and type arguments to <em>generic
invocations</em>.</p>

<p>Type annotations are what you normally think of when you think of “static
types”. You can type annotate a variable, parameter, field, or return type. In
the following example, <code class="highlighter-rouge">bool</code> and <code class="highlighter-rouge">String</code> are type annotations. They hang off
the static declarative structure of the code and aren’t “executed” at runtime.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (annotate-declaration)"?>
<pre class="prettyprint lang-dart">bool isEmpty(String parameter) {
  bool result = parameter.length == 0;
  return result;
}</pre>

<p>A generic invocation is a collection literal, a call to a generic class’s
constructor, or an invocation of a generic method. In the next example, <code class="highlighter-rouge">num</code>
and <code class="highlighter-rouge">int</code> are type arguments on generic invocations. Even though they are types,
they are first-class entities that get reified and passed to the invocation at
runtime.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (annotate-invocation)"?>
<pre class="prettyprint lang-dart">var lists = &lt;num&gt;[1, 2];
lists.addAll(List&lt;num&gt;.filled(3, 4));
lists.cast&lt;int&gt;();</pre>

<p>We stress the “generic invocation” part here, because type arguments can <em>also</em>
appear in type annotations:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (annotate-type-arg)"?>
<pre class="prettyprint lang-dart">List&lt;int&gt; ints = [1, 2];</pre>

<p>Here, <code class="highlighter-rouge">int</code> is a type argument, but it appears inside a type annotation, not a
generic invocation. You usually don’t need to worry about this distinction, but
in a couple of places, we have different guidance for when a type is used in a
generic invocation as opposed to a type annotation.</p>

<p>In most places, Dart allows you to omit a type annotation and infers a type for
you based on the nearby context, or defaults to the <code class="highlighter-rouge">dynamic</code> type. The fact
that Dart has both type inference and a <code class="highlighter-rouge">dynamic</code> type leads to some confusion
about what it means to say code is “untyped”. Does that mean the code is
dynamically typed, or that you didn’t <em>write</em> the type? To avoid that confusion,
we avoid saying “untyped” and instead use the following terminology:</p>

<ul>
  <li>
    <p>If the code is <em>type annotated</em>, the type was explicitly written in the
code.</p>
  </li>
  <li>
    <p>If the code is <em>inferred</em>, no type annotation was written, and Dart
successfully figured out the type on its own. Inference can fail, in which
case the guidelines don’t consider that inferred. In some places, inference
failure is a static error. In others, Dart uses <code class="highlighter-rouge">dynamic</code> as the fallback
type.</p>
  </li>
  <li>
    <p>If the code is <em>dynamic</em>, then its static type is the special <code class="highlighter-rouge">dynamic</code>
type. Code can be explicitly annotated <code class="highlighter-rouge">dynamic</code> or it can be inferred.</p>
  </li>
</ul>

<p>In other words, whether some code is annotated or inferred is orthogonal to
whether it is <code class="highlighter-rouge">dynamic</code> or some other type.</p>

<p>Inference is a powerful tool to spare you the effort of writing and reading
types that are obvious or uninteresting. Omitting types in obvious cases also
draws the reader’s attention to explicit types when those types are important,
for things like casts.</p>

<p>Explicit types are also a key part of robust, maintainable code. They define the
static shape of an API. They document and enforce what kinds of values are
allowed to reach different parts of the program.</p>

<p>The guidelines here strike the best balance we’ve found between brevity and
explicitness, flexibility and safety. When deciding which types to write, you
need to answer two questions:</p>

<ul>
  <li>Which types should I write because I think it’s best for them to be visible in
the code?</li>
  <li>Which types should I write because inference can’t provide them for me?</li>
</ul>

<p>These guidelines help you answer the first question:</p>

<ul>
  <li><a href="#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious">PREFER type annotating public fields and top-level variables if the type isn’t obvious.</a></li>
  <li><a href="#consider-type-annotating-private-fields-and-top-level-variables-if-the-type-isnt-obvious">CONSIDER type annotating private fields and top-level variables if the type isn’t obvious.</a></li>
  <li><a href="#avoid-type-annotating-initialized-local-variables">AVOID type annotating initialized local variables.</a></li>
  <li><a href="#avoid-annotating-inferred-parameter-types-on-function-expressions">AVOID annotating inferred parameter types on function expressions.</a></li>
  <li><a href="#avoid-redundant-type-arguments-on-generic-invocations">AVOID redundant type arguments on generic invocations.</a></li>
</ul>

<p>These cover the second:</p>

<ul>
  <li><a href="#do-annotate-when-dart-infers-the-wrong-type">DO annotate when Dart infers the wrong type.</a></li>
  <li><a href="#prefer-annotating-with-dynamic-instead-of-letting-inference-fail">PREFER annotating with <code class="highlighter-rouge">dynamic</code> instead of letting inference fail.</a></li>
</ul>

<p>The remaining guidelines cover other more specific questions around types.</p>

<h3 id="prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious">
<a id="prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious" class="anchor" href="#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER type annotating public fields and top-level variables if the type isn’t obvious.</h3>

<p>Type annotations are important documentation for how a library should be used.
They form boundaries between regions of a program to isolate the source of a
type error. Consider:</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (type_annotate_public_apis)"?>
<pre class="prettyprint lang-dart bad-style">install(id, destination) =&gt; ...</pre>

<p>Here, it’s unclear what <code class="highlighter-rouge">id</code> is. A string? And what is <code class="highlighter-rouge">destination</code>? A string
or a <code class="highlighter-rouge">File</code> object? Is this method synchronous or asynchronous? This is clearer:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (type_annotate_public_apis)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;bool&gt; install(PackageId id, String destination) =&gt; ...</pre>

<p>In some cases, though, the type is so obvious that writing it is pointless:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (inferred)"?>
<pre class="prettyprint lang-dart good-style">const screenWidth = 640; // Inferred as int.</pre>

<p>“Obvious” isn’t precisely defined, but these are all good candidates:</p>

<ul>
  <li>Literals.</li>
  <li>Constructor invocations.</li>
  <li>References to other constants that are explicitly typed.</li>
  <li>Simple expressions on numbers and strings.</li>
  <li>Factory methods like <code class="highlighter-rouge">int.parse()</code>, <code class="highlighter-rouge">Future.wait()</code>, etc. that readers are
expected to be familiar with.</li>
</ul>

<p>When in doubt, add a type annotation. Even when a type is obvious, you may still
wish to explicitly annotate. If the inferred type relies on values or
declarations from other libraries, you may want to type annotate <em>your</em>
declaration so that a change to that other library doesn’t silently change the
type of your own API without you realizing.</p>

<h3 id="consider-type-annotating-private-fields-and-top-level-variables-if-the-type-isnt-obvious">
<a id="consider-type-annotating-private-fields-and-top-level-variables-if-the-type-isnt-obvious" class="anchor" href="#consider-type-annotating-private-fields-and-top-level-variables-if-the-type-isnt-obvious" aria-hidden="true"><span class="octicon octicon-link"></span></a>CONSIDER type annotating private fields and top-level variables if the type isn’t obvious.</h3>

<p>Type annotations on your public declarations help <em>users</em> of your code. Types on
private members help <em>maintainers</em>. The scope of a private declaration is
smaller and those who need to know the type of that declaration are also more
likely to be familiar with the surrounding code. That makes it reasonable to
lean more heavily on inference and omit types for private declarations, which is
why this guideline is softer than the previous one.</p>

<p>If you think the initializer expression—whatever it is—is
sufficiently clear, then you may omit the annotation. But if you think
annotating helps make the code clearer, then add one.</p>

<h3 id="avoid-type-annotating-initialized-local-variables">
<a id="avoid-type-annotating-initialized-local-variables" class="anchor" href="#avoid-type-annotating-initialized-local-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID type annotating initialized local variables.</h3>

<p>Local variables, especially in modern code where functions tend to be small,
have very little scope. Omitting the type focuses the reader’s attention on the
more important <em>name</em> of the variable and its initialized value.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (omit-types-on-locals)"?>
<pre class="prettyprint lang-dart good-style">List&lt;List&lt;Ingredient&gt;&gt; possibleDesserts(Set&lt;Ingredient&gt; pantry) {
  var desserts = &lt;List&lt;Ingredient&gt;&gt;[];
  for (var recipe in cookbook) {
    if (pantry.containsAll(recipe)) {
      desserts.add(recipe);
    }
  }

  return desserts;
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (omit-types-on-locals)"?>
<pre class="prettyprint lang-dart bad-style">List&lt;List&lt;Ingredient&gt;&gt; possibleDesserts(Set&lt;Ingredient&gt; pantry) {
  List&lt;List&lt;Ingredient&gt;&gt; desserts = &lt;List&lt;Ingredient&gt;&gt;[];
  for (List&lt;Ingredient&gt; recipe in cookbook) {
    if (pantry.containsAll(recipe)) {
      desserts.add(recipe);
    }
  }

  return desserts;
}</pre>

<p>If the local variable doesn’t have an initializer, then its type can’t be
inferred. In that case, it <em>is</em> a good idea to annotate. Otherwise, you get
<code class="highlighter-rouge">dynamic</code> and lose the benefits of static type checking.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (uninitialized-local)"?>
<pre class="prettyprint lang-dart good-style">List&lt;AstNode&gt; parameters;
if (node is Constructor) {
  parameters = node.signature;
} else if (node is Method) {
  parameters = node.parameters;
}</pre>

<h3 id="avoid-annotating-inferred-parameter-types-on-function-expressions">
<a id="avoid-annotating-inferred-parameter-types-on-function-expressions" class="anchor" href="#avoid-annotating-inferred-parameter-types-on-function-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID annotating inferred parameter types on function expressions.</h3>

<p>Anonymous functions are almost always immediately passed to a method taking a
callback of some type. (If the function isn’t used immediately, it’s usually
worth making it a named declaration.) When a function expression is created in a
typed context, Dart tries to infer the function’s parameter types based on the
expected type.</p>

<p>For example, when you pass a function expression to <code class="highlighter-rouge">Iterable.map()</code>, your
function’s parameter type is inferred based on the type of callback that <code class="highlighter-rouge">map()</code>
expects:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (func-expr-no-param-type)"?>
<pre class="prettyprint lang-dart good-style">var names = people.map((person) =&gt; person.name);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (func-expr-no-param-type)"?>
<pre class="prettyprint lang-dart bad-style">var names = people.map((Person person) =&gt; person.name);</pre>

<p>In rare cases, the surrounding context is not precise enough to provide a type
for one or more of the function’s parameters. In those cases, you may need to
annotate.</p>

<h3 id="avoid-redundant-type-arguments-on-generic-invocations">
<a id="avoid-redundant-type-arguments-on-generic-invocations" class="anchor" href="#avoid-redundant-type-arguments-on-generic-invocations" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID redundant type arguments on generic invocations.</h3>

<p>A type argument is redundant if inference would fill in the same type. If the
invocation is the initializer for a type-annotated variable, or is an argument
to a function, then inference usually fills in the type for you:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (redundant)"?>
<pre class="prettyprint lang-dart good-style">Set&lt;String&gt; things = Set();</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (redundant)"?>
<pre class="prettyprint lang-dart bad-style">Set&lt;String&gt; things = Set&lt;String&gt;();</pre>

<p>Here, the type annotation on the variable is used to infer the type argument of
constructor call in the initializer.</p>

<p>In other contexts, there isn’t enough information to infer the type and then you
should write the type argument:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (explicit)"?>
<pre class="prettyprint lang-dart good-style">var things = Set&lt;String&gt;();</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (explicit)"?>
<pre class="prettyprint lang-dart bad-style">var things = Set();</pre>

<p>Here, since the variable has no type annotation, there isn’t enough context to
determine what kind of <code class="highlighter-rouge">Set</code> to create, so the type argument should be provided
explicitly.</p>

<h3 id="do-annotate-when-dart-infers-the-wrong-type">
<a id="do-annotate-when-dart-infers-the-wrong-type" class="anchor" href="#do-annotate-when-dart-infers-the-wrong-type" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO annotate when Dart infers the wrong type.</h3>

<p>Sometimes, Dart infers a type, but not the type you want. For example, you may
want a variable’s type to be a supertype of the initializer’s type so that you
can later assign some other sibling type to the variable:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (inferred-wrong)"?>
<pre class="prettyprint lang-dart good-style">num highScore(List&lt;num&gt; scores) {
  num highest = 0;
  for (var score in scores) {
    if (score &gt; highest) highest = score;
  }
  return highest;
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (inferred-wrong)" replace="/ +\/\/ ignore: .*?\n//g"?>
<pre class="prettyprint lang-dart bad-style">num highScore(List&lt;num&gt; scores) {
  var highest = 0;
  for (var score in scores) {
    if (score &gt; highest) highest = score;
  }
  return highest;
}</pre>

<p>Here, if <code class="highlighter-rouge">scores</code> contains doubles, like <code class="highlighter-rouge">[1.2]</code>, then the assignment to
<code class="highlighter-rouge">highest</code> will fail since its inferred type is <code class="highlighter-rouge">int</code>, not <code class="highlighter-rouge">num</code>. In these cases,
explicit annotations make sense.</p>

<h3 id="prefer-annotating-with-dynamic-instead-of-letting-inference-fail">
<a id="prefer-annotating-with-dynamic-instead-of-letting-inference-fail" class="anchor" href="#prefer-annotating-with-dynamic-instead-of-letting-inference-fail" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER annotating with <code class="highlighter-rouge">dynamic</code> instead of letting inference fail.</h3>

<p>Dart allows you to omit type annotations in many places and will try to infer a
type for you. In some cases, if inference fails, it silently gives you
<code class="highlighter-rouge">dynamic</code>. If <code class="highlighter-rouge">dynamic</code> is the type you want, this is technically the most terse
way to get it.</p>

<p>However, it’s not the most <em>clear</em> way. A casual reader of your code who sees an
annotation is missing has no way of knowing if you intended it to be <code class="highlighter-rouge">dynamic</code>,
expected inference to fill in some other type, or simply forgot to write the
annotation.</p>

<p>When <code class="highlighter-rouge">dynamic</code> is the type you want, writing it explicitly makes your intent
clear.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (prefer-dynamic)"?>
<pre class="prettyprint lang-dart good-style">dynamic mergeJson(dynamic original, dynamic changes) =&gt; ...</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (prefer-dynamic)"?>
<pre class="prettyprint lang-dart bad-style">mergeJson(original, changes) =&gt; ...</pre>

<aside class="alert alert-info">

  <p>Before Dart 2, this guideline stated the exact opposite: <em>don’t</em> annotate with
<code class="highlighter-rouge">dynamic</code> when it is implicit. With the new stronger type system and type
inference, users now expect Dart to behave like an inferred statically-typed
language. With that mental model, it is an unpleasant surprise to discover that
a region of code has silently lost all of the safety and performance of static
types.</p>

</aside>

<h3 id="prefer-signatures-in-function-type-annotations">
<a id="prefer-signatures-in-function-type-annotations" class="anchor" href="#prefer-signatures-in-function-type-annotations" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER signatures in function type annotations.</h3>

<p>The identifier <code class="highlighter-rouge">Function</code> by itself without any return type or parameter
signature refers to the special <a href="https://api.dartlang.org/stable/dart-core/Function-class.html">Function</a> type. This type is only
marginally more useful than using <code class="highlighter-rouge">dynamic</code>. If you’re going to annotate, prefer
a full function type that includes the parameters and return type of the
function.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-Function)" replace="/(void )?Function(\(.*?\))?/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">bool isValid(String value, bool <span class="highlight">Function(String)</span> test) =&gt; ...</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (avoid-Function)" replace="/Function/[!$&!]/g"?>
<pre class="prettyprint lang-dart bad-style">bool isValid(String value, <span class="highlight">Function</span> test) =&gt; ...</pre>

<p>One exception to this guideline is if you want a type that represents the union
of multiple different function types. For example, you may accept a function
that takes one parameter or a function that takes two. Since we don’t have union
types, there’s no way to precisely type that and you’d normally have to use
<code class="highlighter-rouge">dynamic</code>. <code class="highlighter-rouge">Function</code> is at least a little more helpful than that:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (function-arity)" replace="/(void )?Function(\(.*?\))?/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">void handleError(<span class="highlight">void Function()</span> operation, <span class="highlight">Function</span> errorHandler) {
  try {
    operation();
  } catch (err, stack) {
    if (errorHandler is <span class="highlight">Function(Object)</span>) {
      errorHandler(err);
    } else if (errorHandler is <span class="highlight">Function(Object, StackTrace)</span>) {
      errorHandler(err, stack);
    } else {
      throw ArgumentError("errorHandler has wrong signature.");
    }
  }
}</pre>

<h3 id="dont-specify-a-return-type-for-a-setter">
<a id="dont-specify-a-return-type-for-a-setter" class="anchor" href="#dont-specify-a-return-type-for-a-setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T specify a return type for a setter.</h3>

<p>Setters always return <code class="highlighter-rouge">void</code> in Dart. Writing the word is pointless.</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (avoid_return_types_on_setters)"?>
<pre class="prettyprint lang-dart bad-style">void set foo(Foo value) { ... }</pre>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid_return_types_on_setters)"?>
<pre class="prettyprint lang-dart good-style">set foo(Foo value) { ... }</pre>

<h3 id="dont-use-the-legacy-typedef-syntax">
<a id="dont-use-the-legacy-typedef-syntax" class="anchor" href="#dont-use-the-legacy-typedef-syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T use the legacy typedef syntax.</h3>

<p>Dart has two notations for defining a named typedef for a function type. The
original syntax looks like:</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (old-typedef)"?>
<pre class="prettyprint lang-dart bad-style">typedef int Comparison&lt;T&gt;(T a, T b);</pre>

<p>That syntax has a couple of problems:</p>

<ul>
  <li>
    <p>There is no way to assign a name to a <em>generic</em> function type. In the above
example, the typedef itself is generic. If you reference <code class="highlighter-rouge">Comparison</code> in
your code, without a type argument, you implicitly get the function type
<code class="highlighter-rouge">int Function(dynamic, dynamic)</code>, <em>not</em> <code class="highlighter-rouge">int Function&lt;T&gt;(T, T)</code>. This
doesn’t come up in practice often, but it matters in certain corner cases.</p>
  </li>
  <li>
    <p>A single identifier in a parameter is interpreted as the parameter’s <em>name</em>,
not its <em>type</em>. Given:</p>

    <?code-excerpt "misc/lib/effective_dart/design_bad.dart (typedef-param)"?>
    <pre class="prettyprint lang-dart bad-style">typedef bool TestNumber(num);</pre>

    <p>Most users expect this to be a function type that takes a <code class="highlighter-rouge">num</code> and returns
<code class="highlighter-rouge">bool</code>. It is actually a function type that takes <em>any</em> object (<code class="highlighter-rouge">dynamic</code>)
and returns <code class="highlighter-rouge">bool</code>. The parameter’s <em>name</em> (which isn’t used for anything
except documentation in the typedef) is “num”. This has been a
long-standing source of errors in Dart.</p>
  </li>
</ul>

<p>The new syntax looks like this:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (new-typedef)"?>
<pre class="prettyprint lang-dart good-style">typedef Comparison&lt;T&gt; = int Function(T, T);</pre>

<p>If you want to include a parameter’s name, you can do that too:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (new-typedef-param-name)"?>
<pre class="prettyprint lang-dart good-style">typedef Comparison&lt;T&gt; = int Function(T a, T b);</pre>

<p>The new syntax can express anything the old syntax could express and more, and
lacks the error-prone misfeature where a single identifier is treated as the
parameter’s name instead of its type. The same function type syntax after the
<code class="highlighter-rouge">=</code> in the typedef is also allowed anywhere a type annotation may appear, giving
us a single consistent way to write function types anywhere in a program.</p>

<p>The old typedef syntax is still supported to avoid breaking existing code, but
it’s deprecated.</p>

<h3 id="prefer-inline-function-types-over-typedefs">
<a id="prefer-inline-function-types-over-typedefs" class="anchor" href="#prefer-inline-function-types-over-typedefs" aria-hidden="true"><span class="octicon octicon-link"></span></a>PREFER inline function types over typedefs.</h3>

<p>In Dart 1, if you wanted to use a function type for a field, variable, or
generic type argument, you had to first define a typedef for it. Dart 2 supports
a function type syntax that can be used anywhere a type annotation is allowed:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (function-type)"  replace="/(bool|void) Function\(Event\)/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">class FilteredObservable {
  final <span class="highlight">bool Function(Event)</span> _predicate;
  final List&lt;<span class="highlight">void Function(Event)</span>&gt; _observers;

  FilteredObservable(this._predicate, this._observers);

  <span class="highlight">void Function(Event)</span> notify(Event event) {
    if (!_predicate(event)) return null;

    <span class="highlight">void Function(Event)</span> last;
    for (var observer in _observers) {
      observer(event);
      last = observer;
    }

    return last;
  }
}</pre>

<p>It may still be worth defining a typedef if the function type is particularly
long or frequently used. But in most cases, users want to see what the function
type actually is right where it’s used, and the function type syntax gives them
that clarity.</p>

<h3 id="consider-using-function-type-syntax-for-parameters">
<a id="consider-using-function-type-syntax-for-parameters" class="anchor" href="#consider-using-function-type-syntax-for-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>CONSIDER using function type syntax for parameters.</h3>

<p>Dart has a special syntax when defining a parameter whose type is a function.
Sort of like in C, you surround the parameter’s name with the function’s return
type and parameter signature:</p>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (function-type-param)"?>
<pre class="prettyprint lang-dart">Iterable&lt;T&gt; where(bool predicate(T element)) =&gt; ...</pre>

<p>Before Dart 2 added function type syntax, this was the only way to give a
parameter a function type without defining a typedef. Now that Dart has a
general notation for function types, you can use it for function-typed
parameters as well:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (function-type-param)"?>
<pre class="prettyprint lang-dart good-style">Iterable&lt;T&gt; where(bool Function(T) predicate) =&gt; ...</pre>

<p>The new syntax is a little more verbose, but is consistent with other locations
where you must use the new syntax.</p>

<h3 id="do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed">
<a id="do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" class="anchor" href="#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO annotate with <code class="highlighter-rouge">Object</code> instead of <code class="highlighter-rouge">dynamic</code> to indicate any object is allowed.</h3>

<p>Some operations work with any possible object. For example, a <code class="highlighter-rouge">log()</code> method
could take any object and call <code class="highlighter-rouge">toString()</code> on it. Two types in Dart permit all
values: <code class="highlighter-rouge">Object</code> and <code class="highlighter-rouge">dynamic</code>. However, they convey different things. If you
simply want to state that you allow all objects, use <code class="highlighter-rouge">Object</code>, as you would in
Java or C#.</p>

<p>Using <code class="highlighter-rouge">dynamic</code> sends a more complex signal. It may mean that Dart’s type system
isn’t sophisticated enough to represent the set of types that are allowed, or
that the values are coming from interop or otherwise outside of the purview of
the static type system, or that you explicitly want runtime dynamism at that
point in the program.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (Object-vs-dynamic)"?>
<pre class="prettyprint lang-dart good-style">void log(Object object) {
  print(object.toString());
}

/// Returns a Boolean representation for [arg], which must
/// be a String or bool.
bool convertToBool(dynamic arg) {
  if (arg is bool) return arg;
  if (arg is String) return arg == 'true';
  throw ArgumentError('Cannot convert $arg to a bool.');
}</pre>

<h3 id="do-use-futurevoid-as-the-return-type-of-asynchronous-members-that-do-not-produce-values">
<a id="do-use-futurevoid-as-the-return-type-of-asynchronous-members-that-do-not-produce-values" class="anchor" href="#do-use-futurevoid-as-the-return-type-of-asynchronous-members-that-do-not-produce-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use <code class="highlighter-rouge">Future&lt;void&gt;</code> as the return type of asynchronous members that do not produce values.</h3>

<p>When you have a synchronous function that doesn’t return a value, you use <code class="highlighter-rouge">void</code>
as the return type. The asynchronous equivalent for a method that doesn’t
produce a value, but that the caller might need to await, is <code class="highlighter-rouge">Future&lt;void&gt;</code>.</p>

<p>You may see code that uses <code class="highlighter-rouge">Future</code> or <code class="highlighter-rouge">Future&lt;Null&gt;</code> instead because older
versions of Dart didn’t allow <code class="highlighter-rouge">void</code> as a type argument. Now that it does, you
should use it. Doing so more directly matches how you’d type a similar
synchronous function, and gives you better error-checking for callers and in the
body of the function.</p>

<p>For asynchronous functions that do not return a useful value and where no
callers need to await the asynchronous work or handle an asynchronous failure,
use a return type of <code class="highlighter-rouge">void</code>.</p>

<h3 id="avoid-using-futureort-as-a-return-type">
<a id="avoid-using-futureort-as-a-return-type" class="anchor" href="#avoid-using-futureort-as-a-return-type" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID using <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> as a return type.</h3>

<p>If a method accepts a <code class="highlighter-rouge">FutureOr&lt;int&gt;</code>, it is <a href="https://en.wikipedia.org/wiki/Robustness_principle">generous in what it
accepts</a>. Users can call the method with either an <code class="highlighter-rouge">int</code> or a
<code class="highlighter-rouge">Future&lt;int&gt;</code>, so they don’t need to wrap an <code class="highlighter-rouge">int</code> in <code class="highlighter-rouge">Future</code> that you are
going to unwrap anyway.</p>

<p>If you <em>return</em> a <code class="highlighter-rouge">FutureOr&lt;int&gt;</code>, users need to check whether get back an <code class="highlighter-rouge">int</code>
or a <code class="highlighter-rouge">Future&lt;int&gt;</code> before they can do anything useful. (Or they’ll just <code class="highlighter-rouge">await</code>
the value, effectively always treating it as a <code class="highlighter-rouge">Future</code>.) Just return a
<code class="highlighter-rouge">Future&lt;int&gt;</code>, it’s cleaner. It’s easier for users to understand that a function
is either always asynchronous or always synchronous, but a function that can be
either is hard to use correctly.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (future-or)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;int&gt; triple(FutureOr&lt;int&gt; value) async =&gt; (await value) * 3;</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (future-or)"?>
<pre class="prettyprint lang-dart bad-style">FutureOr&lt;int&gt; triple(FutureOr&lt;int&gt; value) {
  if (value is int) return value * 3;
  return (value as Future&lt;int&gt;).then((v) =&gt; v * 3);
}</pre>

<p>The more precise formulation of this guideline is to <em>only use <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> in
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">contravariant</a> positions.</em> Parameters are contravariant and return types are
covariant. In nested function types, this gets flipped—if you have a
parameter whose type is itself a function, then the callback’s return type is
now in contravariant position and the callback’s parameters are covariant. This
means it’s OK for a <em>callback’s</em> type to return <code class="highlighter-rouge">FutureOr&lt;T&gt;</code>:</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (future-or-contra)" replace="/FutureOr.S./[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">Stream&lt;S&gt; asyncMap&lt;T, S&gt;(
    Iterable&lt;T&gt; iterable, <span class="highlight">FutureOr&lt;S&gt;</span> Function(T) callback) async* {
  for (var element in iterable) {
    yield await callback(element);
  }
}</pre>

<h2 id="parameters">
<a id="parameters" class="anchor" href="#parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h2>

<p>In Dart, optional parameters can be either positional or named, but not both.</p>

<h3 id="avoid-positional-boolean-parameters">
<a id="avoid-positional-boolean-parameters" class="anchor" href="#avoid-positional-boolean-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID positional boolean parameters.</h3>

<p>Unlike other types, booleans are usually used in literal form. Things like
numbers are usually wrapped in named constants, but we usually just pass around
<code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code> directly. That can make callsites unreadable if it isn’t
clear what the boolean represents:</p>

<pre class="prettyprint lang-dart bad-style">new Task(true);
new Task(false);
new ListBox(false, true, true);
new Button(false);</pre>

<p>Instead, consider using named arguments, named constructors, or named constants
to clarify what the call is doing.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-positional-bool-param)"?>
<pre class="prettyprint lang-dart good-style">Task.oneShot();
Task.repeating();
ListBox(scroll: true, showScrollbars: true);
Button(ButtonState.enabled);</pre>

<p>Note that this doesn’t apply to setters, where the name makes it clear what the
value represents:</p>

<pre class="prettyprint lang-dart good-style">listBox.canScroll = true;
button.isEnabled = false;</pre>

<h3 id="avoid-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters">
<a id="avoid-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters" class="anchor" href="#avoid-optional-positional-parameters-if-the-user-may-want-to-omit-earlier-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID optional positional parameters if the user may want to omit earlier parameters.</h3>

<p>Optional positional parameters should have a logical progression such that
earlier parameters are passed more often than later ones. Users should almost
never need to explicitly pass a “hole” to omit an earlier positional argument to
pass later one. You’re better off using named arguments for that.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (omit-optional-positional)"?>
<pre class="prettyprint lang-dart good-style">String.fromCharCodes(Iterable&lt;int&gt; charCodes, [int start = 0, int end]);

DateTime(int year,
    [int month = 1,
    int day = 1,
    int hour = 0,
    int minute = 0,
    int second = 0,
    int millisecond = 0,
    int microsecond = 0]);

Duration(
    {int days = 0,
    int hours = 0,
    int minutes = 0,
    int seconds = 0,
    int milliseconds = 0,
    int microseconds = 0});</pre>

<h3 id="avoid-mandatory-parameters-that-accept-a-special-no-argument-value">
<a id="avoid-mandatory-parameters-that-accept-a-special-no-argument-value" class="anchor" href="#avoid-mandatory-parameters-that-accept-a-special-no-argument-value" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID mandatory parameters that accept a special “no argument” value.</h3>

<p>If the user is logically omitting a parameter, prefer letting them actually omit
it by making the parameter optional instead of forcing them to pass <code class="highlighter-rouge">null</code>, an
empty string, or some other special value that means “did not pass”.</p>

<p>Omitting the parameter is more terse and helps prevent bugs where a sentinel
value like <code class="highlighter-rouge">null</code> is accidentally passed when the user thought they were
providing a real value.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (avoid-mandatory-param)"?>
<pre class="prettyprint lang-dart good-style">var rest = string.substring(start);</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (avoid-mandatory-param)"?>
<pre class="prettyprint lang-dart bad-style">var rest = string.substring(start, null);</pre>

<h3 id="do-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range">
<a id="do-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range" class="anchor" href="#do-use-inclusive-start-and-exclusive-end-parameters-to-accept-a-range" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO use inclusive start and exclusive end parameters to accept a range.</h3>

<p>If you are defining a method or function that lets a user select a range of
elements or items from some integer-indexed sequence, take a start index, which
refers to the first item and a (likely optional) end index which is one greater
than the index of the last item.</p>

<p>This is consistent with core libraries that do the same thing.</p>

<?code-excerpt "misc/test/effective_dart_test.dart (param-range)" replace="/expect\(//g; /, \/\*\*\// \/\//g; /\);//g"?>
<pre class="prettyprint lang-dart good-style">[0, 1, 2, 3].sublist(1, 3) // [1, 2]
'abcd'.substring(1, 3) // 'bc'</pre>

<p>It’s particularly important to be consistent here because these parameters are
usually unnamed. If your API takes a length instead of an end point, the
difference won’t be visible at all at the callsite.</p>

<h2 id="equality">
<a id="equality" class="anchor" href="#equality" aria-hidden="true"><span class="octicon octicon-link"></span></a>Equality</h2>

<p>Implementing custom equality behavior for a class can be tricky. Users have deep
intuition about how equality works that your objects need to match, and
collection types like hash tables have subtle contracts that they expect
elements to follow.</p>

<h3 id="do-override-hashcode-if-you-override-">
<a id="do-override-hashcode-if-you-override-" class="anchor" href="#do-override-hashcode-if-you-override-" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO override <code class="highlighter-rouge">hashCode</code> if you override <code class="highlighter-rouge">==</code>.</h3>

<p>The default hash code implementation provides an <em>identity</em> hash—two
objects generally only have the same hash code if they are the exact same
object. Likewise, the default behavior for <code class="highlighter-rouge">==</code> is identity.</p>

<p>If you are overriding <code class="highlighter-rouge">==</code>, it implies you may have different objects that are
considered “equal” by your class. <strong>Any two objects that are equal must have the
same hash code.</strong> Otherwise, maps and other hash-based collections will fail to
recognize that the two objects are equivalent.</p>

<h3 id="do-make-your--operator-obey-the-mathematical-rules-of-equality">
<a id="do-make-your--operator-obey-the-mathematical-rules-of-equality" class="anchor" href="#do-make-your--operator-obey-the-mathematical-rules-of-equality" aria-hidden="true"><span class="octicon octicon-link"></span></a>DO make your <code class="highlighter-rouge">==</code> operator obey the mathematical rules of equality.</h3>

<p>An equivalence relation should be:</p>

<ul>
  <li>
    <p><strong>Reflexive</strong>: <code class="highlighter-rouge">a == a</code> should always return <code class="highlighter-rouge">true</code>.</p>
  </li>
  <li>
    <p><strong>Symmetric</strong>: <code class="highlighter-rouge">a == b</code> should return the same thing as <code class="highlighter-rouge">b == a</code>.</p>
  </li>
  <li>
    <p><strong>Transitive</strong>: If <code class="highlighter-rouge">a == b</code> and <code class="highlighter-rouge">b == c</code> both return <code class="highlighter-rouge">true</code>, then <code class="highlighter-rouge">a == c</code>
should too.</p>
  </li>
</ul>

<p>Users and code that uses <code class="highlighter-rouge">==</code> expect all of these laws to be followed. If your
class can’t obey these rules, then <code class="highlighter-rouge">==</code> isn’t the right name for the operation
you’re trying to express.</p>

<h3 id="avoid-defining-custom-equality-for-mutable-classes">
<a id="avoid-defining-custom-equality-for-mutable-classes" class="anchor" href="#avoid-defining-custom-equality-for-mutable-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>AVOID defining custom equality for mutable classes.</h3>

<p>When you define <code class="highlighter-rouge">==</code>, you also have to define <code class="highlighter-rouge">hashCode</code>. Both of those should
take into account the object’s fields. If those fields <em>change</em> then that
implies the object’s hash code can change.</p>

<p>Most hash-based collections don’t anticipate that—they assume an object’s
hash code will be the same forever and may behave unpredictably if that isn’t
true.</p>

<h3 id="dont-check-for-null-in-custom--operators">
<a id="dont-check-for-null-in-custom--operators" class="anchor" href="#dont-check-for-null-in-custom--operators" aria-hidden="true"><span class="octicon octicon-link"></span></a>DON’T check for <code class="highlighter-rouge">null</code> in custom <code class="highlighter-rouge">==</code> operators.</h3>

<p>The language specifies that this check is done automatically and your <code class="highlighter-rouge">==</code>
method is called only if the right-hand side is not <code class="highlighter-rouge">null</code>.</p>

<?code-excerpt "misc/lib/effective_dart/design_good.dart (eq-dont-check-for-null)" replace="/operator ==/[!$&!]/g" plaster?>
<pre class="prettyprint lang-dart good-style">class Person {
  final String name;
  // ···
  <span class="highlight">operator ==</span>(other) =&gt; other is Person &amp;&amp; name == other.name;

  int get hashCode =&gt; name.hashCode;
}</pre>

<?code-excerpt "misc/lib/effective_dart/design_bad.dart (eq-dont-check-for-null)" replace="/\w+ != null/[!$&!]/g" plaster?>
<pre class="prettyprint lang-dart bad-style">class Person {
  final String name;
  // ···
  operator ==(other) =&gt; <span class="highlight">other != null</span> &amp;&amp; ...
}</pre>


          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/usage">&lang;&nbsp;&nbsp;使用</a>
      
    </li>
    <li class="next">
      
    </li>
  </ul>
</nav>


        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-md-12 col-lg-3">
        <div class="content">
          <div class="brand">
            <img src="/assets/shared/dart/logo+text/horizontal/mono-004b4974b3112e2d9136b1c457037dfd9fe54e2e69e850d777891e5c2a57a78d.svg" alt="Dart logo" class="brand"/>
          </div>
          <h4><a href="/terms">Terms</a> | <a href="https://policies.google.com/privacy">Privacy</a></h4>
          <style>.menu .material-icons { font-size: 14px; }</style><ul class="menu">
            <li>Site&nbsp;<a href="http://creativecommons.org/licenses/by/3.0/" class="no-automatic-external">CC&nbsp;BY&nbsp;3.0</a></li>
            <li>
              <a href="https://github.com/dart-lang/site-www"
                 title="This site's source is on GitHub."
                 class="no-automatic-external"><i class="fab fa-github fa-sm"></i></a>
              &nbsp;
              <a href="https://github.com/dart-lang/site-www/issues"
                 title="File an issue about this site."
                 class="no-automatic-external"><i class="fas fa-bug fa-sm"></i></a>
              &nbsp;
              <a 
                 title="Site built on 2018/10/28 14:39 CST"
                 
                 class="no-automatic-external"><i class="material-icons">build</i></a>
            </li>
          </ul>
        </div>
      </div>
      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>技术</h4>
          <ul>
            <li><a href="https://flutter.io">Dart 移动开发 (Flutter)</a></li>
            <li><a href="https://webdev.dartlang.org">Dart web 开发</a></li>
            <li><a href="/dart-vm">Dart 服务器开发</a></li>
            <li><a href="https://dart-lang.github.io/observatory/">Observatory 工具</a></li>
            <li><a href="/guides/libraries">Dart 库</a></li>
            <li><a href="/guides/language">Dart 编程语言</a></li>
          </ul>
        </div>
      </div>

      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>资源</h4>
          <ul>
            <li><a href="https://api.dartlang.org/stable">API 参考</a></li>
            <li><a href="https://dartpad.dartlang.org/">DartPad</a></li>
            <li><a href="https://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="http://news.dartlang.org/">Dart 新闻</a></li>
            <li><a href="https://github.com/dart-lang/sdk/issues">Dart bugs 和 <br> 新需求</a></li>
          </ul>
        </div>
      </div>

      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>社区</h4>
          <ul>
            <li><a href="/community">支持和邮件列表</a></li>
            <li><a href="/community/who-uses-dart">谁在用Dart</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
            <li>G+ <a href="https://plus.google.com/communities/114566943291919232850">社区</a> &
                <a href="https://plus.google.com/b/109866369054280216564/+dartlang">公告组</a></li>
            <li><a href="https://gitter.im/dart-lang/home">Gitter聊天室</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
