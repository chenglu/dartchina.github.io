<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="en_US" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Guidelines for using language features to write maintainable code.">
  <title>Effective Dart: 使用 | Dart</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/touch-icon-iphone-a46c306c4fbfae0b28d63f512b01d7cb2ccf1e4ca9d7f3aab15ba1170beed4a0.png" rel="apple-touch-icon">
  <link href="/assets/touch-icon-ipad-d0181720760b3912858b6d40da1d5586b1e92c7c8656a485ea41005674401e6b.png" rel="apple-touch-icon" sizes="76x76">
  <link href="/assets/touch-icon-iphone-retina-3d9821a631425376ac6203dea3c23c1940ab7b5c506a25406662fab76cee2e0b.png" rel="apple-touch-icon" sizes="120x120">
  <link href="/assets/touch-icon-ipad-retina-b9715401952522f1daee2b4a4064a1bbfb5ffab78d0a47a7226dc87444d51c32.png" rel="apple-touch-icon" sizes="152x152">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Effective Dart: 使用" />
  <meta name="twitter:description" content="Guidelines for using language features to write maintainable code." />

  <!-- Open Graph -->
  <meta property="og:title" content="Effective Dart: 使用" />
  <meta property="og:description" content="Guidelines for using language features to write maintainable code." />
  <meta property="og:url" content="https://www.dartlang.org/guides/language/effective-dart/usage" />
  <meta property="og:image" content="https://www.dartlang.org/assets/shared/dart-logo-for-shares.png?2" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="/assets/main-743789fa2eea1d0b842284e7e29077de7c7f755aa88e291b7b8bf324a4a2a14b.css">
  <script src="/assets/main-3e89b739cc750412e013252d8b4ced20af281589ffe69a156e6c279177f81069.js" type="text/javascript"></script>
  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


</head>

  <body class="default">
    <header id="page-header">
  <nav id="mainnav">
  <div id="menu-toggle"><i class="icon icon-menu"></i></div>
  <a href="/" class="brand" title="Dart">
    <img src="/assets/shared/dart/logo+text/horizontal/default-363c9c133ffb7780463d3d638632b64cc8221d74d93cd1002fb1efbbe9983bc9.svg" alt="Dart">
  </a>
  <ul>
    <li class="mainnav__get-started"><a href="/guides/get-started"><span>入门</span></a></li>
    <li><a href="/guides/language">语言</a></li>
    <li><a href="/guides/libraries">库</a></li>
    <li><a href="/tools">工具</a></li>
    
    
    <li class="dropdown">
      <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dart 2</a>
      <ul class="dropdown-menu">
        

<li><a href="https://v1-dartlang-org.firebaseapp.com/guides/language/effective-dart/usage" class="dropdown-item no-automatic-external">1.24.3&nbsp;&nbsp;(archive)</a></li><li><a class="active dropdown-item">2.1.0&nbsp;&nbsp;(stable)</a></li>

        <li role="separator" class="dropdown-divider"></li>
        <li><a class="dropdown-item" href="/dart-2#migration">迁移指南</a></li>
      </ul>
    </li>
    
    <li class="searchfield">
      <form class="navbar-search" action="/search" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input type="search" name="q" id="q" autocomplete="off" placeholder="Search">
        <button type="submit"><i class="icon icon-search"></i></button>
      </form>
    </li>
  </ul>
</nav>

  
</header>

    <main id="page-content">
      <div id="sidenav" class="">
  <div class="content">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/shared/dart/logo+text/horizontal/default-363c9c133ffb7780463d3d638632b64cc8221d74d93cd1002fb1efbbe9983bc9.svg" alt="Dart">
    </a>

    <div class="sidenav__search">
      <p>
        <a href="/search">Search <i class="icon icon-search"></i></a>
      </p>
    </div>

    <ul>
      <li>
        <a class="btn btn-light" href="/guides/get-started">入门</a>
      </li>
    </ul>
    <h4 ><a href="/guides/language" title="语言">语言</a></h4>
  <ul><li >
          <a href="/guides/language/language-tour" title="概览">概览</a>
        </li>
        
        <li class="active">
          <a href="/guides/language/effective-dart" title="Effective Dart">Effective Dart</a>
          <i class="icon icon-arrow"></i>
          <ul><li >
                <a href="/guides/language/effective-dart/style" title="风格">风格</a>
              </li><li >
                <a href="/guides/language/effective-dart/documentation" title="文档">文档</a>
              </li><li class="active">
                <a href="/guides/language/effective-dart/usage" title="使用">使用</a>
              </li><li >
                <a href="/guides/language/effective-dart/design" title="设计">设计</a>
              </li>
          </ul><li >
          <a href="/samples" title="示例代码">示例代码</a>
        </li>
  </ul><h4 ><a href="/guides/libraries" title="库">库</a></h4>
  <ul><li >
          <a href="/guides/libraries/library-tour" title="概览">概览</a>
        </li>
  </ul><h4 ><a href="/guides/platforms" title="平台">平台</a></h4>
  <ul><li >
          <a href="https://flutter.io" title="移动端 (Flutter)">移动端 (Flutter)</a>
        </li><li >
          <a href="https://webdev.dartlang.org" title="web">web</a>
        </li><li >
          <a href="/dart-vm" title="服务器">服务器</a>
        </li>
  </ul><h4 ><a href="/guides/testing" title="测试">测试</a></h4>
  <ul>
  </ul><h4 >资源</h4>
  <ul><li >
          <a href="/install" title="安装">安装</a>
        </li><li >
          <a href="/codelabs" title="Codelabs">Codelabs</a>
        </li><li >
          <a href="/tutorials" title="学习指南">学习指南</a>
        </li><li >
          <a href="/articles" title="文章">文章</a>
        </li><li >
          <a href="/tools" title="工具">工具</a>
        </li><li >
          <a href="/community" title="社区支持">社区支持</a>
        </li>
  </ul>
  </div>
</div>

      
<div id="toc">
  <div class="content">
    <header class="h4 text-uppercase">
      目录
      <a title="Back to top" class="back-to-top float-right mr-3">
        <i class="fas fa-angle-up"></i>
      </a>
    </header>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#库">库</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-在-part-of-中使用字符串">要 在 part of 中使用字符串。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-导入-package-中-src-目录下的库">不要 导入 package 中 src 目录下的库。</a></li>
<li class="toc-entry toc-h3"><a href="#建议-使用相对路径在导入你自己-package-中的-lib-目录">建议 使用相对路径在导入你自己 package 中的 lib 目录。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#字符串">字符串</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-使用临近字符字的方式连接字面量字符串">要 使用临近字符字的方式连接字面量字符串。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用插值的形式来组合字符串和值">推荐 使用插值的形式来组合字符串和值。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在字符串插值中使用不必要的大括号">避免 在字符串插值中使用不必要的大括号。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#集合">集合</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-尽可能的使用集合字面量">要 尽可能的使用集合字面量。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用-length-来判断一个集合是否为空">不要 使用 .length 来判断一个集合是否为空。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-使用高阶higher-order函数来转换集合数据">考虑 使用高阶（higher-order）函数来转换集合数据。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-在-iterableforeach-中使用字面量函数">避免 在 Iterable.forEach() 中使用字面量函数。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用-listfrom-除非想修改结果的类型">不要 使用 List.from() 除非想修改结果的类型。</a></li>
<li class="toc-entry toc-h3"><a href="#要-使用-wheretype-按类型过滤集合">要 使用 whereType() 按类型过滤集合。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用-cast如果有更合适的方法">不要 使用 cast()，如果有更合适的方法。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-使用-cast-">避免 使用 cast() 。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#函数">函数</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-使用函数声明的方式为函数绑定名称">要 使用函数声明的方式为函数绑定名称。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用-lambda-表达式来替代-tear-off">不要 使用 lambda 表达式来替代 tear-off。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#参数">参数</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-使用--来分隔参数名和参数默认值">要 使用 = 来分隔参数名和参数默认值。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-显式的为参数设置-null-值">不要 显式的为参数设置 null 值。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#变量">变量</a>
<ul>
<li class="toc-entry toc-h3"><a href="#不要-显示的为参数初始化-null-值">不要 显示的为参数初始化 null 值。</a></li>
<li class="toc-entry toc-h3"><a href="#避免-保存可计算的结果">避免 保存可计算的结果。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#成员">成员</a>
<ul>
<li class="toc-entry toc-h3"><a href="#不要-为字段创建不必要的-getter-和-setter-方法">不要 为字段创建不必要的 getter 和 setter 方法。</a></li>
<li class="toc-entry toc-h3"><a href="#推荐-使用-final-关键字来创建只读属性">推荐 使用 final 关键字来创建只读属性。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-对简单成员使用--">考虑 对简单成员使用 =&gt; 。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用-this-除非遇到了变量冲突的情况">不要 使用 this. ，除非遇到了变量冲突的情况。</a></li>
<li class="toc-entry toc-h3"><a href="#要-尽可能的在定义变量的时候初始化变量值">要 尽可能的在定义变量的时候初始化变量值。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#构造函数">构造函数</a>
<ul>
<li class="toc-entry toc-h3"><a href="#要-尽可能的使用初始化形式">要 尽可能的使用初始化形式。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-在初始化形式中做类型注释">不要 在初始化形式中做类型注释。</a></li>
<li class="toc-entry toc-h3"><a href="#要-用--来替代空的构造函数体-">要 用 ; 来替代空的构造函数体 {}。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-使用-new-">不要 使用 new 。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-冗余地使用-const-">不要 冗余地使用 const 。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#错误处理">错误处理</a>
<ul>
<li class="toc-entry toc-h3"><a href="#避免-使用没有-on-语句的-catch">避免 使用没有 on 语句的 catch。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-丢弃没有使用-on-语句捕获的异常">不要 丢弃没有使用 on 语句捕获的异常。</a></li>
<li class="toc-entry toc-h3"><a href="#要-只在代表编程错误的情况下才抛出实现了-error-的异常">要 只在代表编程错误的情况下才抛出实现了 Error 的异常。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-显示的捕获-error-或者其子类">不要 显示的捕获 Error 或者其子类。</a></li>
<li class="toc-entry toc-h3"><a href="#要-使用-rethrow-来重新抛出捕获的异常">要 使用 rethrow 来重新抛出捕获的异常。</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#异步">异步</a>
<ul>
<li class="toc-entry toc-h3"><a href="#推荐-使用-asyncawait-而不是直接使用底层的特性">推荐 使用 async/await 而不是直接使用底层的特性。</a></li>
<li class="toc-entry toc-h3"><a href="#不要-在没有有用效果的情况下使用-async-">不要 在没有有用效果的情况下使用 async 。</a></li>
<li class="toc-entry toc-h3"><a href="#考虑-使用高阶函数来转换事件流stream">考虑 使用高阶函数来转换事件流（stream）</a></li>
<li class="toc-entry toc-h3"><a href="#避免-直接使用-completer--">避免 直接使用 Completer  。</a></li>
<li class="toc-entry toc-h3"><a href="#要-使用-futuret-对-futureort-参数进行测试以消除参数可能是-object-类型的歧义">要 使用 Future&lt;T&gt; 对 FutureOr&lt;T&gt; 参数进行测试，以消除参数可能是 Object 类型的歧义。</a></li>
</ul>
</li>
</ul>
  </div>
</div>


      <article>
        <div class="content">
           <div class="banner alert alert-info">
  <p class="banner__text">
    
    
    Dart 2.1 现发布，具有更高的性能和可用性。
    <a href="https://medium.com/dartlang/announcing-dart-2-1-improved-performance-usability-9f55fca6f31a">了解更多。</a>
  </p>
</div>
 
          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/documentation">&lang;&nbsp;&nbsp;文档注释</a>
      
    </li>
    <li class="next">
      
        <a href="/guides/language/effective-dart/design">设计&nbsp;&nbsp;&rang;</a>
      
    </li>
  </ul>
</nav>


          <div>
            <div id="page-github-links" class="btn-group" aria-label="Page GitHub links" role="group">
  <a href="https://github.com/dartchina/site-www-cn/tree/src_zh_CN/src_zh_CN/_guides/language/effective-dart/usage.md" class="btn no-automatic-external" title="View page source" target="_blank" rel="noopener">
    <i class="fas fa-file-alt fa-sm"></i>
  </a>
  <a href="https://github.com/dartchina/site-www-cn/issues/new?title='Effective Dart: 使用' page issue&body=
Page URL: https://www.dartlang.org/guides/language/effective-dart/usage%0D%0A
Page source: https://github.com/dartchina/site-www-cn/tree/src_zh_CN/src_zh_CN/_guides/language/effective-dart/usage.md%0D%0A
%0D%0A
<!-- ADD YOUR DESCRIPTION OF THE PAGE ISSUE HERE: -->" class="btn no-automatic-external" title="Report a issue with this page"
    target="_blank" rel="noopener">
    <i class="fas fa-bug fa-sm"></i>
  </a>
</div>

            <h1>Effective Dart: 使用</h1>
          </div>
          <?code-excerpt replace="/([A-Z]\w*)\d\b/$1/g"?>

<p>该指南在 Effective Dart 中是最为基础的部分。
每天在你写的 Dart 代码中都会应用到这些准则。
库的<em>使用者</em>可能不需要知道你在其中的一些想法，
但是<em>维护者</em>肯定是需要的。</p>

<ul id="markdown-toc">
  <li>
<a href="#%E5%BA%93" id="markdown-toc-库">库</a>    <ul>
      <li><a href="#%E8%A6%81-%E5%9C%A8-part-of-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2" id="markdown-toc-要-在-part-of-中使用字符串"><strong>要</strong> 在 <code class="highlighter-rouge">part of</code> 中使用字符串。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E5%AF%BC%E5%85%A5-package-%E4%B8%AD-src-%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%BA%93" id="markdown-toc-不要-导入-package-中-src-目录下的库"><strong>不要</strong> 导入 package 中 <code class="highlighter-rouge">src</code> 目录下的库。</a></li>
      <li><a href="#%E5%BB%BA%E8%AE%AE-%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%9C%A8%E5%AF%BC%E5%85%A5%E4%BD%A0%E8%87%AA%E5%B7%B1-package-%E4%B8%AD%E7%9A%84-lib-%E7%9B%AE%E5%BD%95" id="markdown-toc-建议-使用相对路径在导入你自己-package-中的-lib-目录"><strong>建议</strong> 使用相对路径在导入你自己 package 中的 <code class="highlighter-rouge">lib</code> 目录。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2" id="markdown-toc-字符串">字符串</a>    <ul>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%B4%E8%BF%91%E5%AD%97%E7%AC%A6%E5%AD%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2" id="markdown-toc-要-使用临近字符字的方式连接字面量字符串"><strong>要</strong> 使用临近字符字的方式连接字面量字符串。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E7%BB%84%E5%90%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%80%BC" id="markdown-toc-推荐-使用插值的形式来组合字符串和值"><strong>推荐</strong> 使用插值的形式来组合字符串和值。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7" id="markdown-toc-避免-在字符串插值中使用不必要的大括号"><strong>避免</strong> 在字符串插值中使用不必要的大括号。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E9%9B%86%E5%90%88" id="markdown-toc-集合">集合</a>    <ul>
      <li><a href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F" id="markdown-toc-要-尽可能的使用集合字面量"><strong>要</strong> 尽可能的使用集合字面量。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-length-%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" id="markdown-toc-不要-使用-length-来判断一个集合是否为空"><strong>不要</strong> 使用 <code class="highlighter-rouge">.length</code> 来判断一个集合是否为空。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6higher-order%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BD%AC%E6%8D%A2%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE" id="markdown-toc-考虑-使用高阶higher-order函数来转换集合数据"><strong>考虑</strong> 使用高阶（higher-order）函数来转换集合数据。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E5%9C%A8-iterableforeach-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E5%87%BD%E6%95%B0" id="markdown-toc-避免-在-iterableforeach-中使用字面量函数"><strong>避免</strong> 在 <code class="highlighter-rouge">Iterable.forEach()</code> 中使用字面量函数。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-listfrom-%E9%99%A4%E9%9D%9E%E6%83%B3%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C%E7%9A%84%E7%B1%BB%E5%9E%8B" id="markdown-toc-不要-使用-listfrom-除非想修改结果的类型"><strong>不要</strong> 使用 <code class="highlighter-rouge">List.from()</code> 除非想修改结果的类型。</a></li>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-wheretype-%E6%8C%89%E7%B1%BB%E5%9E%8B%E8%BF%87%E6%BB%A4%E9%9B%86%E5%90%88" id="markdown-toc-要-使用-wheretype-按类型过滤集合"><strong>要</strong> 使用 <code class="highlighter-rouge">whereType()</code> 按类型过滤集合。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-cast%E5%A6%82%E6%9E%9C%E6%9C%89%E6%9B%B4%E5%90%88%E9%80%82%E7%9A%84%E6%96%B9%E6%B3%95" id="markdown-toc-不要-使用-cast如果有更合适的方法"><strong>不要</strong> 使用 <code class="highlighter-rouge">cast()</code>，如果有更合适的方法。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%BD%BF%E7%94%A8-cast-" id="markdown-toc-避免-使用-cast-"><strong>避免</strong> 使用 <code class="highlighter-rouge">cast()</code> 。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%87%BD%E6%95%B0" id="markdown-toc-函数">函数</a>    <ul>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%BA%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E5%90%8D%E7%A7%B0" id="markdown-toc-要-使用函数声明的方式为函数绑定名称"><strong>要</strong> 使用函数声明的方式为函数绑定名称。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E6%9B%BF%E4%BB%A3-tear-off" id="markdown-toc-不要-使用-lambda-表达式来替代-tear-off"><strong>不要</strong> 使用 lambda 表达式来替代 tear-off。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%8F%82%E6%95%B0" id="markdown-toc-参数">参数</a>    <ul>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8--%E6%9D%A5%E5%88%86%E9%9A%94%E5%8F%82%E6%95%B0%E5%90%8D%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC" id="markdown-toc-要-使用--来分隔参数名和参数默认值"><strong>要</strong> 使用 <code class="highlighter-rouge">=</code> 来分隔参数名和参数默认值。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E6%98%BE%E5%BC%8F%E7%9A%84%E4%B8%BA%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE-null-%E5%80%BC" id="markdown-toc-不要-显式的为参数设置-null-值"><strong>不要</strong> 显式的为参数设置 <code class="highlighter-rouge">null</code> 值。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%8F%98%E9%87%8F" id="markdown-toc-变量">变量</a>    <ul>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E6%98%BE%E7%A4%BA%E7%9A%84%E4%B8%BA%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96-null-%E5%80%BC" id="markdown-toc-不要-显示的为参数初始化-null-值"><strong>不要</strong> 显示的为参数初始化 <code class="highlighter-rouge">null</code> 值。</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%BF%9D%E5%AD%98%E5%8F%AF%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%93%E6%9E%9C" id="markdown-toc-避免-保存可计算的结果"><strong>避免</strong> 保存可计算的结果。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E6%88%90%E5%91%98" id="markdown-toc-成员">成员</a>    <ul>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%B8%BA%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-getter-%E5%92%8C-setter-%E6%96%B9%E6%B3%95" id="markdown-toc-不要-为字段创建不必要的-getter-和-setter-方法"><strong>不要</strong> 为字段创建不必要的 getter 和 setter 方法。</a></li>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-final-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7" id="markdown-toc-推荐-使用-final-关键字来创建只读属性"><strong>推荐</strong> 使用 <code class="highlighter-rouge">final</code> 关键字来创建只读属性。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E5%AF%B9%E7%AE%80%E5%8D%95%E6%88%90%E5%91%98%E4%BD%BF%E7%94%A8--" id="markdown-toc-考虑-对简单成员使用--"><strong>考虑</strong> 对简单成员使用 <code class="highlighter-rouge">=&gt;</code> 。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-this-%E9%99%A4%E9%9D%9E%E9%81%87%E5%88%B0%E4%BA%86%E5%8F%98%E9%87%8F%E5%86%B2%E7%AA%81%E7%9A%84%E6%83%85%E5%86%B5" id="markdown-toc-不要-使用-this-除非遇到了变量冲突的情况"><strong>不要</strong> 使用 <code class="highlighter-rouge">this.</code> ，除非遇到了变量冲突的情况。</a></li>
      <li><a href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E5%9C%A8%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%E5%80%BC" id="markdown-toc-要-尽可能的在定义变量的时候初始化变量值"><strong>要</strong> 尽可能的在定义变量的时候初始化变量值。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" id="markdown-toc-构造函数">构造函数</a>    <ul>
      <li><a href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BD%A2%E5%BC%8F" id="markdown-toc-要-尽可能的使用初始化形式"><strong>要</strong> 尽可能的使用初始化形式。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BD%A2%E5%BC%8F%E4%B8%AD%E5%81%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A" id="markdown-toc-不要-在初始化形式中做类型注释"><strong>不要</strong> 在初始化形式中做类型注释。</a></li>
      <li><a href="#%E8%A6%81-%E7%94%A8--%E6%9D%A5%E6%9B%BF%E4%BB%A3%E7%A9%BA%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93-" id="markdown-toc-要-用--来替代空的构造函数体-"><strong>要</strong> 用 <code class="highlighter-rouge">;</code> 来替代空的构造函数体 <code class="highlighter-rouge">{}</code>。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-new-" id="markdown-toc-不要-使用-new-"><strong>不要</strong> 使用 <code class="highlighter-rouge">new</code> 。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E5%86%97%E4%BD%99%E5%9C%B0%E4%BD%BF%E7%94%A8-const-" id="markdown-toc-不要-冗余地使用-const-"><strong>不要</strong> 冗余地使用 <code class="highlighter-rouge">const</code> 。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" id="markdown-toc-错误处理">错误处理</a>    <ul>
      <li><a href="#%E9%81%BF%E5%85%8D-%E4%BD%BF%E7%94%A8%E6%B2%A1%E6%9C%89-on-%E8%AF%AD%E5%8F%A5%E7%9A%84-catch" id="markdown-toc-避免-使用没有-on-语句的-catch"><strong>避免</strong> 使用没有 <code class="highlighter-rouge">on</code> 语句的 catch。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E4%B8%A2%E5%BC%83%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8-on-%E8%AF%AD%E5%8F%A5%E6%8D%95%E8%8E%B7%E7%9A%84%E5%BC%82%E5%B8%B8" id="markdown-toc-不要-丢弃没有使用-on-语句捕获的异常"><strong>不要</strong> 丢弃没有使用 <code class="highlighter-rouge">on</code> 语句捕获的异常。</a></li>
      <li><a href="#%E8%A6%81-%E5%8F%AA%E5%9C%A8%E4%BB%A3%E8%A1%A8%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%8D%E6%8A%9B%E5%87%BA%E5%AE%9E%E7%8E%B0%E4%BA%86-error-%E7%9A%84%E5%BC%82%E5%B8%B8" id="markdown-toc-要-只在代表编程错误的情况下才抛出实现了-error-的异常"><strong>要</strong> 只在代表编程错误的情况下才抛出实现了 <code class="highlighter-rouge">Error</code> 的异常。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E6%98%BE%E7%A4%BA%E7%9A%84%E6%8D%95%E8%8E%B7-error-%E6%88%96%E8%80%85%E5%85%B6%E5%AD%90%E7%B1%BB" id="markdown-toc-不要-显示的捕获-error-或者其子类"><strong>不要</strong> 显示的捕获 <code class="highlighter-rouge">Error</code> 或者其子类。</a></li>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-rethrow-%E6%9D%A5%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E6%8D%95%E8%8E%B7%E7%9A%84%E5%BC%82%E5%B8%B8" id="markdown-toc-要-使用-rethrow-来重新抛出捕获的异常"><strong>要</strong> 使用 <code class="highlighter-rouge">rethrow</code> 来重新抛出捕获的异常。</a></li>
    </ul>
  </li>
  <li>
<a href="#%E5%BC%82%E6%AD%A5" id="markdown-toc-异步">异步</a>    <ul>
      <li><a href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-asyncawait-%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%BA%95%E5%B1%82%E7%9A%84%E7%89%B9%E6%80%A7" id="markdown-toc-推荐-使用-asyncawait-而不是直接使用底层的特性"><strong>推荐</strong> 使用 async/await 而不是直接使用底层的特性。</a></li>
      <li><a href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E6%B2%A1%E6%9C%89%E6%9C%89%E7%94%A8%E6%95%88%E6%9E%9C%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8-async-" id="markdown-toc-不要-在没有有用效果的情况下使用-async-"><strong>不要</strong> 在没有有用效果的情况下使用 <code class="highlighter-rouge">async</code> 。</a></li>
      <li><a href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BD%AC%E6%8D%A2%E4%BA%8B%E4%BB%B6%E6%B5%81stream" id="markdown-toc-考虑-使用高阶函数来转换事件流stream"><strong>考虑</strong> 使用高阶函数来转换事件流（stream）</a></li>
      <li><a href="#%E9%81%BF%E5%85%8D-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-completer--" id="markdown-toc-避免-直接使用-completer--"><strong>避免</strong> 直接使用 Completer  。</a></li>
      <li><a href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-futuret-%E5%AF%B9-futureort-%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%A5%E6%B6%88%E9%99%A4%E5%8F%82%E6%95%B0%E5%8F%AF%E8%83%BD%E6%98%AF-object-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AD%A7%E4%B9%89" id="markdown-toc-要-使用-futuret-对-futureort-参数进行测试以消除参数可能是-object-类型的歧义"><strong>要</strong> 使用 <code class="highlighter-rouge">Future&lt;T&gt;</code> 对 <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> 参数进行测试，以消除参数可能是 <code class="highlighter-rouge">Object</code> 类型的歧义。</a></li>
    </ul>
  </li>
</ul>

<h2 id="库">
<a id="库" class="anchor" href="#%E5%BA%93" aria-hidden="true"><span class="octicon octicon-link"></span></a>库</h2>

<p>这些准则可以帮助你在多个文件编写程序的情况下保证一致性和可维护性。
为了让准则简洁，这里使用“import”来同事代表 <code class="highlighter-rouge">import</code> 和 <code class="highlighter-rouge">export</code> 。
准则同时适用于这两者。</p>

<h3 id="要-在-part-of-中使用字符串">
<a id="要-在-part-of-中使用字符串" class="anchor" href="#%E8%A6%81-%E5%9C%A8-part-of-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 在 <code class="highlighter-rouge">part of</code> 中使用字符串。</h3>

<p>很多 Dart 开发者会避免直接使用 <code class="highlighter-rouge">part</code> 。他们发现当库仅有一个文件的时候很容易读懂代码。
如果你确实要使用 <code class="highlighter-rouge">part</code> 将库的一部分拆分为另一个文件，则 Dart 要求另一个文件指示它所属库的路径。 
由于遗留原因， Dart 允许 <code class="highlighter-rouge">part of</code> 指令使用它所属的库的<em>名称</em>。
这使得工具很难直接查找到这个文件对应主库文件，使得库和文件之间的关系模糊不清。</p>

<p>推荐的现代语法是使用 URI 字符串直接指向库文件。
首选的现代语法是使用直接指向库文件的URI字符串，URI 的使用和其他指令中一样。
如果你有一些库，<code class="highlighter-rouge">my_library.dart</code>，其中包含：</p>

<?code-excerpt "misc/lib/effective_dart/my_library.dart"?>
<pre class="prettyprint lang-dart">library my_library;

part "some/other/file.dart";</pre>

<p>从库中拆分的文件应该如下所示：</p>

<?code-excerpt "misc/lib/effective_dart/some/other/file.dart"?>
<pre class="prettyprint lang-dart good-style">part of "../../my_library.dart";</pre>

<p>而不是：</p>

<?code-excerpt "misc/lib/effective_dart/some/other/file_2.dart"?>
<pre class="prettyprint lang-dart bad-style">part of my_library;</pre>

<h3 id="不要-导入-package-中-src-目录下的库">
<a id="不要-导入-package-中-src-目录下的库" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E5%AF%BC%E5%85%A5-package-%E4%B8%AD-src-%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%BA%93" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 导入 package 中 <code class="highlighter-rouge">src</code> 目录下的库。</h3>

<p><code class="highlighter-rouge">lib</code> 下的 <code class="highlighter-rouge">src</code> 目录<a href="https://www.dartlang.org/tools/pub/package-layout">被指定</a>为 package 自己实现的私有库。
基于包维护者对版本的考虑，package 使用了这种约定。
在不破坏 package 的情况下，维护者可以自由地对 <code class="highlighter-rouge">src</code> 目录下的代码进行修改。</p>

<p>这意味着，你如果导入了其中的私有库，
按理论来讲，一个不破坏 package 的次版本就会影响到你的代码。</p>

<h3 id="建议-使用相对路径在导入你自己-package-中的-lib-目录">
<a id="建议-使用相对路径在导入你自己-package-中的-lib-目录" class="anchor" href="#%E5%BB%BA%E8%AE%AE-%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%9C%A8%E5%AF%BC%E5%85%A5%E4%BD%A0%E8%87%AA%E5%B7%B1-package-%E4%B8%AD%E7%9A%84-lib-%E7%9B%AE%E5%BD%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>建议</strong> 使用相对路径在导入你自己 package 中的 <code class="highlighter-rouge">lib</code> 目录。</h3>

<p>在同一个 package 下其中一个库引用另一个 <code class="highlighter-rouge">lib</code> 目录下的库时，
应该使用相对的 URI 或者直接使用 <code class="highlighter-rouge">package:</code>。</p>

<p>比如，下面是你的 package 目录结构：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_package
└─ lib
   ├─ src
   │  └─ utils.dart
   └─ api.dart
</code></pre></div></div>

<p>如果 <code class="highlighter-rouge">api.dart</code> 想导入 <code class="highlighter-rouge">utils.dart</code> ，应该这样使用：</p>

<pre class="prettyprint lang-dart good-style">import 'src/utils.dart';</pre>

<p>而不是:</p>

<pre class="prettyprint lang-dart bad-style">import 'package:my_package/src/utils.dart';</pre>

<p>喜欢一种方式没有什么深奥的原因——这里仅仅是因为更精简，或者是能够保持一致。</p>

<p>“让 package 的 <code class="highlighter-rouge">lib</code> 目录”独立分离非常重要。
<code class="highlighter-rouge">lib</code> 中的库可以导入 <code class="highlighter-rouge">lib</code>（或其子目录）中的其他库。
<code class="highlighter-rouge">lib</code> 之外的库可以使用相对导入的方式来访问<code class="highlighter-rouge">lib</code>之外的其他库。
例如，<code class="highlighter-rouge">test</code> 下可能有一个测试实用程序库被其它在 <code class="highlighter-rouge">test</code> 下的库导入。</p>

<p>但不能跨越导入。一个在 <code class="highlighter-rouge">lib</code> 外部的库应该永远不会引用一个在 <code class="highlighter-rouge">lib</code> 内部的库，反之亦然。
这样做，会破坏 Dart 正确判断两个库的 URL 是否引用了同一个库的能力。
遵循以下两条规则：</p>

<ul>
  <li>导入路径不应包含 <code class="highlighter-rouge">/lib/</code> 。</li>
  <li>
<code class="highlighter-rouge">lib</code> 下的库永远不应该使用 <code class="highlighter-rouge">../</code> 来跨越 <code class="highlighter-rouge">lib</code> 目录。</li>
</ul>

<h2 id="字符串">
<a id="字符串" class="anchor" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串</h2>

<p>下面是一些需要记住的，关于在 Dart 中使用字符串的最佳实践。</p>

<h3 id="要-使用临近字符字的方式连接字面量字符串">
<a id="要-使用临近字符字的方式连接字面量字符串" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E4%B8%B4%E8%BF%91%E5%AD%97%E7%AC%A6%E5%AD%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用临近字符字的方式连接字面量字符串。</h3>

<p>如果你有两个字面量字符串（不是变量，是放在引号中的字符串），你不需要使用 <code class="highlighter-rouge">+</code> 来连接它们。
应该想 C 和 C++ 一样，只需要将它们挨着在一起就可以了。
这种方式非常适合不能放到一行的长字符串的创建。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (adjacent-strings-literals)"?>
<pre class="prettyprint lang-dart good-style">raiseAlarm(
    'ERROR: Parts of the spaceship are on fire. Other '
    'parts are overrun by martians. Unclear which are which.');</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (adjacent-strings-literals)"?>
<pre class="prettyprint lang-dart bad-style">raiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' +
    'parts are overrun by martians. Unclear which are which.');</pre>

<h3 id="推荐-使用插值的形式来组合字符串和值">
<a id="推荐-使用插值的形式来组合字符串和值" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E7%BB%84%E5%90%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用插值的形式来组合字符串和值。</h3>

<p>如果你之前使用过其他语言，你一定习惯使用大量 <code class="highlighter-rouge">+</code> 将字面量字符串以及字符串变量链接构建字符串。
这种方式在 Dart 中同样有效，但是通常情况下使用插值会更清晰简短。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (string-interpolation)"?>
<pre class="prettyprint lang-dart good-style">'Hello, $name! You are ${year - birth} years old.';</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (string-interpolation)"?>
<pre class="prettyprint lang-dart bad-style">'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...';</pre>

<h3 id="避免-在字符串插值中使用不必要的大括号">
<a id="避免-在字符串插值中使用不必要的大括号" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在字符串插值中使用不必要的大括号。</h3>

<p>如果要插入是一个简单的标识符，并且后面没有紧跟随在其他字母文本，则应省略 <code class="highlighter-rouge">{}</code> 。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (string-interpolation-avoid-curly)"?>
<pre class="prettyprint lang-dart good-style">'Hi, $name!'
"Wear your wildest $decade's outfit."
'Wear your wildest ${decade}s outfit.'</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (string-interpolation-avoid-curly)"?>
<pre class="prettyprint lang-dart bad-style">'Hi, ${name}!'
"Wear your wildest ${decade}'s outfit."</pre>

<h2 id="集合">
<a id="集合" class="anchor" href="#%E9%9B%86%E5%90%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>集合</h2>

<p>Dart 集合中原生支持了四种类型：list， map， queue， 和 set。
下面是应用于集合的最佳实践。</p>

<h3 id="要-尽可能的使用集合字面量">
<a id="要-尽可能的使用集合字面量" class="anchor" href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 尽可能的使用集合字面量。</h3>

<p>有两种方式来构造一个空的可变 list ： <code class="highlighter-rouge">[]</code> 和 <code class="highlighter-rouge">List()</code> 。
同样，有三总方式来构造一个空的链表哈希 map：<code class="highlighter-rouge">{}</code>，
<code class="highlighter-rouge">Map()</code>， 和 <code class="highlighter-rouge">LinkedHashMap()</code> 。</p>

<p>如果想创建一个固定不变的 list 或者其他自定义集合类型，这种情况下你需要使用构造函数。
否则，使用字面量语法更加优雅。
核心库中暴露这些构造函数易于扩展，但是通常在 Dart 代码中并不使用构造函数。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (collection-literals)"?>
<pre class="prettyprint lang-dart good-style">var points = [];
var addresses = {};</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (collection-literals)"?>
<pre class="prettyprint lang-dart bad-style">var points = List();
var addresses = Map();</pre>

<p>如果需要的话，你甚至可以为它们提供一个类型参数。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (generic-collection-literals)"?>
<pre class="prettyprint lang-dart good-style">var points = &lt;Point&gt;[];
var addresses = &lt;String, Address&gt;{};</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (generic-collection-literals)"?>
<pre class="prettyprint lang-dart bad-style">var points = List&lt;Point&gt;();
var addresses = Map&lt;String, Address&gt;();</pre>

<p>注意，对于集合类的 <em>命名</em> 构造函数则不适用上面的规则。
<code class="highlighter-rouge">List.from()</code>、 <code class="highlighter-rouge">Map.fromIterable()</code> 都有其使用场景。 
如果需要一个固定长度的结合，使用 <code class="highlighter-rouge">List()</code> 来创建一个固定长度的 list 也是合理的。</p>

<h3 id="不要-使用-length-来判断一个集合是否为空">
<a id="不要-使用-length-来判断一个集合是否为空" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-length-%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用 <code class="highlighter-rouge">.length</code> 来判断一个集合是否为空。</h3>

<p><a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html">Iterable</a> 合约并不要求集合知道其长度，也没要求在遍历的时候其长度不能改变。
通过调用 <code class="highlighter-rouge">.length</code>  来判断集合是否包含内容是非常低效的。</p>

<p>相反，Dart 提供了更加高效率和易用的 getter 函数：<code class="highlighter-rouge">.isEmpty</code> 和<code class="highlighter-rouge">.isNotEmpty</code>。
使用这些函数并不需要对结果再次取非。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (dont-use-length)"?>
<pre class="prettyprint lang-dart good-style">if (lunchBox.isEmpty) return 'so hungry...';
if (words.isNotEmpty) return words.join(' ');</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (dont-use-length)"?>
<pre class="prettyprint lang-dart bad-style">if (lunchBox.length == 0) return 'so hungry...';
if (!words.isEmpty) return words.join(' ');</pre>

<h3 id="考虑-使用高阶higher-order函数来转换集合数据">
<a id="考虑-使用高阶higher-order函数来转换集合数据" class="anchor" href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6higher-order%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BD%AC%E6%8D%A2%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 使用高阶（higher-order）函数来转换集合数据。</h3>

<p>如果你有一个集合并且想要修改里面的内容转换为另外一个集合，
使用 <code class="highlighter-rouge">.map()</code>、 <code class="highlighter-rouge">.where()</code> 以及 <code class="highlighter-rouge">Iterable</code> 提供的其他函数会让代码更加简洁。</p>

<p>使用这些函数替代 <code class="highlighter-rouge">for</code> 循环会让代码更加可以表述你的意图，
生成一个新的集合系列并不具有副作用。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (use-higher-order-func)"?>
<pre class="prettyprint lang-dart good-style">var aquaticNames = animals
    .where((animal) =&gt; animal.isAquatic)
    .map((animal) =&gt; animal.name);</pre>

<p>与此同时，这可以非常长，
如果你串联或者嵌套调用很多高阶函数，
则使用一些命令式代码可能会更加清晰。</p>

<h3 id="避免-在-iterableforeach-中使用字面量函数">
<a id="避免-在-iterableforeach-中使用字面量函数" class="anchor" href="#%E9%81%BF%E5%85%8D-%E5%9C%A8-iterableforeach-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 在 <code class="highlighter-rouge">Iterable.forEach()</code> 中使用字面量函数。</h3>

<p><code class="highlighter-rouge">forEach()</code> 函数在 JavaScript 中被广泛使用，
这因为内置的 <code class="highlighter-rouge">for-in</code> 循环通常不能达到你想要的效果。
在Dart中，如果要对序列进行迭代，惯用的方式是使用循环。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (avoid-forEach)"?>
<pre class="prettyprint lang-dart good-style">for (var person in people) {
  ...
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (avoid-forEach)"?>
<pre class="prettyprint lang-dart bad-style">people.forEach((person) {
  ...
});</pre>

<p>例外情况是，如果要执行的操作是调用一些已存在的并且将每个元素作为参数的函数，
在这种情况下，<code class="highlighter-rouge">forEach()</code> 是很方便的。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (forEach-over-func)"?>
<pre class="prettyprint lang-dart good-style">people.forEach(print);</pre>

<h3 id="不要-使用-listfrom-除非想修改结果的类型">
<a id="不要-使用-listfrom-除非想修改结果的类型" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-listfrom-%E9%99%A4%E9%9D%9E%E6%83%B3%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C%E7%9A%84%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用 <code class="highlighter-rouge">List.from()</code> 除非想修改结果的类型。</h3>

<p>给定一个可迭代的对象，有两种常见方式来生成一个包含相同元素的 list：</p>

<?code-excerpt "misc/test/effective_dart_test.dart (list-from-1)"?>
<pre class="prettyprint lang-dart">var copy1 = iterable.toList();
var copy2 = List.from(iterable);</pre>

<p>明显的区别是前一个更短。
更<em>重要</em>的区别在于第一个保留了原始对象的类型参数：</p>

<?code-excerpt "misc/test/effective_dart_test.dart (list-from-good)"?>
<pre class="prettyprint lang-dart good-style">// Creates a List&lt;int&gt;:
var iterable = [1, 2, 3];

// Prints "List&lt;int&gt;":
print(iterable.toList().runtimeType);</pre>

<?code-excerpt "misc/test/effective_dart_test.dart (list-from-bad)"?>
<pre class="prettyprint lang-dart bad-style">// Creates a List&lt;int&gt;:
var iterable = [1, 2, 3];

// Prints "List&lt;dynamic&gt;":
print(List.from(iterable).runtimeType);</pre>

<p>如果你<em>想要</em>改变类型，那么可以调用 <code class="highlighter-rouge">List.from()</code> ：</p>

<?code-excerpt "misc/test/effective_dart_test.dart (list-from-3)"?>
<pre class="prettyprint lang-dart good-style">var numbers = [1, 2.3, 4]; // List&lt;num&gt;.
numbers.removeAt(1); // Now it only contains integers.
var ints = List&lt;int&gt;.from(numbers);</pre>

<p>但是如果你的目的只是复制可迭代对象并且保留元素原始类型，
或者并不在乎类型，那么请使用 <code class="highlighter-rouge">toList()</code> 。</p>

<h3 id="要-使用-wheretype-按类型过滤集合">
<a id="要-使用-wheretype-按类型过滤集合" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-wheretype-%E6%8C%89%E7%B1%BB%E5%9E%8B%E8%BF%87%E6%BB%A4%E9%9B%86%E5%90%88" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用 <code class="highlighter-rouge">whereType()</code> 按类型过滤集合。</h3>

<aside class="alert alert-warning">
  <p><strong>在使用 <code class="highlighter-rouge">whereType()</code> 前，确认它是否已经被实现。</strong>
  我们期望 <code class="highlighter-rouge">whereType()</code> 会在后续的 Dart 2 中添加。
  更多详情，参考
  <a href="https://github.com/dart-lang/sdk/issues/32463#issuecomment-402975456">SDK issue #32463.</a></p>
</aside>

<p>假设你有一个 list 里面包含了多种类型的对象，
但是你指向从它里面获取整型类型的数据。
那么你可以像下面这样使用 <code class="highlighter-rouge">where()</code> ：</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (where-type)"?>
<pre class="prettyprint lang-dart bad-style">var objects = [1, "a", 2, "b", 3];
var ints = objects.where((e) =&gt; e is int);</pre>

<p>这个很罗嗦，但是更糟糕的是，它返回的可迭代对象类型可能并不是你想要的。
在上面的例子中，虽然你想得到一个 <code class="highlighter-rouge">Iterable&lt;int&gt;</code>，然而它返回了一个 <code class="highlighter-rouge">Iterable&lt;Object&gt;</code>，
这是因为，这是你过滤后得到的类型。</p>

<p>有时候你会看到通过添加 <code class="highlighter-rouge">cast()</code> 来“修正”上面的错误：</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (where-type-2)"?>
<pre class="prettyprint lang-dart bad-style">var objects = [1, "a", 2, "b", 3];
var ints = objects.where((e) =&gt; e is int).cast&lt;int&gt;();</pre>

<p>代码冗长，并导致创建了两个包装器，获取元素对象要间接通过两层，并进行两次多余的运行时检查。
幸运的是，对于这个用例，核心库提供了 <code class="highlighter-rouge">whereType()</code>]<a href="https://api.dartlang.org/stable/dart-core/Iterable/whereType.html">where-type</a> 方法：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (where-type)"?>
<pre class="prettyprint lang-dart good-style">var objects = [1, "a", 2, "b", 3];
var ints = objects.whereType&lt;int&gt;();</pre>

<p>使用 <code class="highlighter-rouge">whereType()</code> 简洁，
生成所需的 <a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html">Iterable</a>（可迭代）类型，
并且没有不必要的层级包装。</p>

<h3 id="不要-使用-cast如果有更合适的方法">
<a id="不要-使用-cast如果有更合适的方法" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-cast%E5%A6%82%E6%9E%9C%E6%9C%89%E6%9B%B4%E5%90%88%E9%80%82%E7%9A%84%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用 <code class="highlighter-rouge">cast()</code>，如果有更合适的方法。</h3>

<p>通常，当处理可迭代对象或 stream 时，
你可以对其执行多次转换。
最后，生成所希望的具有特定类型参数的对象。
尝试查看是否有已有的转换方法来改变类型，而不是去掉用 <code class="highlighter-rouge">cast()</code> 。
而不是调用cast（），看看是否有一个现有的转换可以改变类型。</p>

<p>如果你已经使用了 <code class="highlighter-rouge">toList()</code> ，那么请使用 <a href="https://api.dartlang.org/stable/dart-core/List/List.from.html"><code class="highlighter-rouge">List&lt;T&gt;.from()</code></a> 替换，
这里的 <code class="highlighter-rouge">T</code> 是你想要的返回值的类型。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-list)"?>
<pre class="prettyprint lang-dart good-style">var stuff = &lt;dynamic&gt;[1, 2];
var ints = List&lt;int&gt;.from(stuff);</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-list)"?>
<pre class="prettyprint lang-dart bad-style">var stuff = &lt;dynamic&gt;[1, 2];
var ints = stuff.toList().cast&lt;int&gt;();</pre>

<p>如果你正在调用 <code class="highlighter-rouge">map()</code> ，给它一个显式的类型参数，
这样它就能产生一个所需类型的可迭代对象。
类型推断通常根据传递给 <code class="highlighter-rouge">map()</code> 的函数选择出正确的类型，
但有的时候需要明确指明。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-map)" replace="/\(n as int\)/n/g"?>
<pre class="prettyprint lang-dart good-style">var stuff = &lt;dynamic&gt;[1, 2];
var reciprocals = stuff.map&lt;double&gt;((n) =&gt; 1 / n);</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-map)" replace="/\(n as int\)/n/g"?>
<pre class="prettyprint lang-dart bad-style">var stuff = &lt;dynamic&gt;[1, 2];
var reciprocals = stuff.map((n) =&gt; 1 / n).cast&lt;double&gt;();</pre>

<h3 id="避免-使用-cast-">
<a id="避免-使用-cast-" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%BD%BF%E7%94%A8-cast-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 使用 <code class="highlighter-rouge">cast()</code> 。</h3>

<p>这是对先前规则的一个宽松的定义。
有些时候，并没有合适的方式来修改对象类型，即便如此，
也应该尽可能的避免使用 <code class="highlighter-rouge">cast()</code> 来“改变”集合中元素的类型。</p>

<p>推荐使用下面的方式来替代：</p>

<ul>
  <li>
    <p><strong>用恰当的类型创建集合。</strong> 修改集合被首次创建时的代码，
为集合提供有一个恰当的类型。</p>
  </li>
  <li>
    <p><strong>在访问元素时进行 cast 操作。</strong> 如果要立即对集合进行迭代，
在迭代内部 cast 每个元素。</p>
  </li>
  <li>
    <p><strong>逼不得已进行 cast，请使用 <code class="highlighter-rouge">List.from()</code> 。</strong> 如果最终你会使用到集合中的大部分元素，
并且不需要对象还原到原始的对象类型，使用 <code class="highlighter-rouge">List.from()</code> 来转换它。</p>

    <p><code class="highlighter-rouge">cast()</code> 方法返回一个惰性集合（lazy collection），<em>每个操作</em>都会对元素进行检查。
如果只对少数元素执行少量操作，那么这种惰性方式就非常合适。
但在许多情况下，惰性验证和包裹（wrapping）所产生的开销已经超过了它们所带来的好处。</p>
  </li>
</ul>

<p>下面是 <strong>用恰当的类型创建集合</strong> 的示例：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-at-create)"?>
<pre class="prettyprint lang-dart good-style">List&lt;int&gt; singletonList(int value) {
  var list = &lt;int&gt;[];
  list.add(value);
  return list;
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-at-create)"?>
<pre class="prettyprint lang-dart bad-style">List&lt;int&gt; singletonList(int value) {
  var list = []; // List&lt;dynamic&gt;.
  list.add(value);
  return list.cast&lt;int&gt;();
}</pre>

<p>下面是 <strong>在访问元素时进行 cast 操作</strong> 的示例：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-iterate)" replace="/\(n as int\)/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">void printEvens(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  for (var n in objects) {
    if (<span class="highlight">(n as int)</span>.isEven) print(n);
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-iterate)"?>
<pre class="prettyprint lang-dart bad-style">void printEvens(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  for (var n in objects.cast&lt;int&gt;()) {
    if (n.isEven) print(n);
  }
}</pre>

<p>下面是 <strong>使用 <code class="highlighter-rouge">List.from()</code> 进行 cast 操作</strong> 的示例：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cast-from)"?>
<pre class="prettyprint lang-dart good-style">int median(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  var ints = List&lt;int&gt;.from(objects);
  ints.sort();
  return ints[ints.length ~/ 2];
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cast-from)"?>
<pre class="prettyprint lang-dart bad-style">int median(List&lt;Object&gt; objects) {
  // We happen to know the list only contains ints.
  var ints = objects.cast&lt;int&gt;();
  ints.sort();
  return ints[ints.length ~/ 2];
}</pre>

<p>当然，这些替代方案并不总能解决问题，显然，这时候就应该选择 <code class="highlighter-rouge">cast()</code> 方式了。
但是考虑到这种方式的风险和缺点——如果使用不当，可能会导致执行缓慢和运行失败。</p>

<h2 id="函数">
<a id="函数" class="anchor" href="#%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数</h2>

<p>在 Dart 中，就连函数也是对象。以下是一些涉及函数的最佳实践。</p>

<h3 id="要-使用函数声明的方式为函数绑定名称">
<a id="要-使用函数声明的方式为函数绑定名称" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%BA%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E5%90%8D%E7%A7%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用函数声明的方式为函数绑定名称。</h3>

<p>现代语言已经意识到本地嵌套函数和闭包的益处。
在一个函数中定义另一个函数非常常见。
在许多情况下，这些函数被立即执行并返回结果，而且不需要名字。
这种情况下非常适合使用函数表达式来实现。</p>

<p>但是，如果你确实需要给方法一个名字，请使用方法定义而不是把
lambda 赋值给一个变量。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (func-decl)"?>
<pre class="prettyprint lang-dart good-style">void main() {
  localFunction() {
    ...
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (func-decl)"?>
<pre class="prettyprint lang-dart bad-style">void main() {
  var localFunction = () {
    ...
  };
}</pre>

<h3 id="不要-使用-lambda-表达式来替代-tear-off">
<a id="不要-使用-lambda-表达式来替代-tear-off" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E6%9B%BF%E4%BB%A3-tear-off" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用 lambda 表达式来替代 tear-off。</h3>

<p>如果你在一个对象上调用函数并省略了括号， 
Dart 称之为”tear-off”—一个和函数使用同样参数的闭包，
当你调用闭包的时候执行其中的函数。</p>

<p>如果你有一个方法，这个方法调用了参数相同的另一个方法。
那么，你不需要人为将这个方法包装到一个 lambda 表达式中。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (use-tear-off)"?>
<pre class="prettyprint lang-dart good-style">names.forEach(print);</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (use-tear-off)"?>
<pre class="prettyprint lang-dart bad-style">names.forEach((name) {
  print(name);
});</pre>

<h2 id="参数">
<a id="参数" class="anchor" href="#%E5%8F%82%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数</h2>

<h3 id="要-使用--来分隔参数名和参数默认值">
<a id="要-使用--来分隔参数名和参数默认值" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8--%E6%9D%A5%E5%88%86%E9%9A%94%E5%8F%82%E6%95%B0%E5%90%8D%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用 <code class="highlighter-rouge">=</code> 来分隔参数名和参数默认值。</h3>

<p>由于遗留原因，Dart 同时支持 <code class="highlighter-rouge">:</code> 和 <code class="highlighter-rouge">=</code> 作为参数名和默认值的分隔符。
为了与可选的位置参数保持一致，请使用 <code class="highlighter-rouge">=</code> 。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (default-separator)"?>
<pre class="prettyprint lang-dart good-style">void insert(Object item, {int at = 0}) { ... }</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (default-separator)"?>
<pre class="prettyprint lang-dart bad-style">void insert(Object item, {int at: 0}) { ... }</pre>

<h3 id="不要-显式的为参数设置-null-值">
<a id="不要-显式的为参数设置-null-值" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E6%98%BE%E5%BC%8F%E7%9A%84%E4%B8%BA%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE-null-%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 显式的为参数设置 <code class="highlighter-rouge">null</code> 值。</h3>

<p>如果你创建了一个可选参数，那么就不要为其赋默认值，
Dart 默认使用 <code class="highlighter-rouge">null</code> 作为默认值，所以这里不需要为其 <code class="highlighter-rouge">null</code> 赋值语句。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (default-value-null)"?>
<pre class="prettyprint lang-dart good-style">void error([String message]) {
  stderr.write(message ?? '\n');
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (default-value-null)"?>
<pre class="prettyprint lang-dart bad-style">void error([String message = null]) {
  stderr.write(message ?? '\n');
}</pre>

<h2 id="变量">
<a id="变量" class="anchor" href="#%E5%8F%98%E9%87%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量</h2>

<p>下面是关于如何在 Dart 中使用变量的的最佳实践。</p>

<h3 id="不要-显示的为参数初始化-null-值">
<a id="不要-显示的为参数初始化-null-值" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E6%98%BE%E7%A4%BA%E7%9A%84%E4%B8%BA%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96-null-%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 显示的为参数初始化 <code class="highlighter-rouge">null</code> 值。</h3>

<p>在Dart中，未自动显式初始化的变量或字段将初始化为 <code class="highlighter-rouge">null</code> 。
语言保证了赋值的可靠性。在 Dart 中没有“未初始化内存”的概念。
所以使用 <code class="highlighter-rouge">= null</code> 是多余的。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (no-null-init)"?>
<pre class="prettyprint lang-dart good-style">int _nextId;

class LazyId {
  int _id;

  int get id {
    if (_nextId == null) _nextId = 0;
    if (_id == null) _id = _nextId++;

    return _id;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (no-null-init)"?>
<pre class="prettyprint lang-dart bad-style">int _nextId = null;

class LazyId {
  int _id = null;

  int get id {
    if (_nextId == null) _nextId = 0;
    if (_id == null) _id = _nextId++;

    return _id;
  }
}</pre>

<h3 id="避免-保存可计算的结果">
<a id="避免-保存可计算的结果" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%BF%9D%E5%AD%98%E5%8F%AF%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%93%E6%9E%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 保存可计算的结果。</h3>

<p>在设计类的时候，你常常希望暴露底层状态的多个表现属性。
常常你会发现在类的构造函数中计算这些属性，然后保存起来：</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cacl-vs-store1)"?>
<pre class="prettyprint lang-dart bad-style">class Circle {
  num radius;
  num area;
  num circumference;

  Circle(num radius)
      : radius = radius,
        area = pi * radius * radius,
        circumference = pi * 2.0 * radius;
}</pre>

<p>上面的代码有两个不妥之处。首先，这样浪费了内存。
严格来说面积和周长是<em>缓存</em>数据。
他们保存的结果可以通过已知的数据计算出来。
他们减少了 CPU 消耗却增加了内存消耗。
我们还没有权衡，到底存不存在性能问题？</p>

<p>更坏的情况是，上面的代码是 <em>错的</em> 。上面的缓存是<em>无效的</em>—
你如何知道什么时候缓存失效了需要重新计算？
在这里，我们永远不会从新计算，即使 <code class="highlighter-rouge">radius</code> 是可变的。
你可以给 <code class="highlighter-rouge">radius</code> 设置一个不同的值，但是 <code class="highlighter-rouge">area</code> 和 <code class="highlighter-rouge">circumference</code> 还是之前的值。</p>

<p>为了正确处理缓存失效，我们需要这样做：</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (cacl-vs-store2)"?>
<pre class="prettyprint lang-dart bad-style">class Circle {
  num _radius;
  num get radius =&gt; _radius;
  set radius(num value) {
    _radius = value;
    _recalculate();
  }

  num _area;
  num get area =&gt; _area;

  num _circumference;
  num get circumference =&gt; _circumference;

  Circle(this._radius) {
    _recalculate();
  }

  void _recalculate() {
    _area = pi * _radius * _radius;
    _circumference = pi * 2.0 * _radius;
  }
}</pre>

<p>这需要编写、维护、调试以及阅读更多的代码。
如果你一开始这样写代码：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (cacl-vs-store)"?>
<pre class="prettyprint lang-dart good-style">class Circle {
  num radius;

  Circle(this.radius);

  num get area =&gt; pi * radius * radius;
  num get circumference =&gt; pi * 2.0 * radius;
}</pre>

<p>上面的代码更加简洁、使用更少的内存、减少出错的可能性。
它尽可能少的保存了表示圆所需要的数据。
这里没有字段需要同步，因为这里只有一个有效数据源。</p>

<p>在某些情况下，当计算结果比较费时的时候可能需要缓存，
但是只应该在你只有你有这样的性能问题的时候再去处理，
处理时要仔细，并留下挂关于优化的注释。</p>

<h2 id="成员">
<a id="成员" class="anchor" href="#%E6%88%90%E5%91%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员</h2>

<p>在 Dart 中，对象成员可以是函数（方法）或数据（实例变量）。
下面是关于对象成员的最佳实践。</p>

<h3 id="不要-为字段创建不必要的-getter-和-setter-方法">
<a id="不要-为字段创建不必要的-getter-和-setter-方法" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%B8%BA%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-getter-%E5%92%8C-setter-%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 为字段创建不必要的 getter 和 setter 方法。</h3>

<p>在 Java 和 C# 中，通常情况下会将所有的字段隐藏到 getter 和 setter 方法中（在 C# 中被称为属性），
即使实现中仅仅是指向这些字段。在这种方式下，即使你在这些成员上做多少的事情，你也不需要直接访问它们。
这是因为，在 Java 中，调用 getter 方法和直接访问字段是不同的。
在 C# 中，访问属性与访问字段不是二进制兼容的。</p>

<p>Dart 不存在这个限制。字段和 getter/setter 是完全无法区分的。
你可以在类中公开一个字段，然后将其包装在 getter 和 setter 中，
而不会影响任何使用该字段的代码。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (dont-wrap-field)"?>
<pre class="prettyprint lang-dart good-style">class Box {
  var contents;
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (dont-wrap-field)"?>
<pre class="prettyprint lang-dart bad-style">class Box {
  var _contents;
  get contents =&gt; _contents;
  set contents(value) {
    _contents = value;
  }
}</pre>

<h3 id="推荐-使用-final-关键字来创建只读属性">
<a id="推荐-使用-final-关键字来创建只读属性" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-final-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用 <code class="highlighter-rouge">final</code> 关键字来创建只读属性。</h3>

<p>如果你有一个变量，对于外部代买来说只能读取不能修改，
最简单的做法就是使用 <code class="highlighter-rouge">final</code> 关键字来标记这个变量。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (final)"?>
<pre class="prettyprint lang-dart good-style">class Box {
  final contents = [];
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (final)"?>
<pre class="prettyprint lang-dart bad-style">class Box {
  var _contents;
  get contents =&gt; _contents;
}</pre>

<p>当然，如果你需要构造一个内部可以赋值，外部可以访问的字段，
你可以需要这种“私有成员变量，公开访问函数”的模式，
但是，如非必要，请不要使用这种模式。</p>

<h3 id="考虑-对简单成员使用--">
<a id="考虑-对简单成员使用--" class="anchor" href="#%E8%80%83%E8%99%91-%E5%AF%B9%E7%AE%80%E5%8D%95%E6%88%90%E5%91%98%E4%BD%BF%E7%94%A8--" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 对简单成员使用 <code class="highlighter-rouge">=&gt;</code> 。</h3>

<p>除了使用 <code class="highlighter-rouge">=&gt;</code> 可以用作函数表达式以外，
Dart 还允许使用它来定义成员。
这种风格非常适合，仅进行计算并返回结果的简单成员。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (use-arrow)"?>
<pre class="prettyprint lang-dart good-style">double get area =&gt; (right - left) * (bottom - top);

bool isReady(num time) =&gt; minTime == null || minTime &lt;= time;

String capitalize(String name) =&gt;
    '${name[0].toUpperCase()}${name.substring(1)}';</pre>

<p><em>编写</em>代码的人似乎很喜欢 <code class="highlighter-rouge">=&gt;</code> 语法，但是它很容易被滥用，最后导致代码不容易被<em>阅读</em>。
如果你有很多行声明或包含深层的嵌套表达式（级联和条件运算符就是常见的罪魁祸首），
你以及其他人有谁会愿意读这样的代码！
你应该换做使用代码块和一些语句来实现。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (arrow-long)"?>
<pre class="prettyprint lang-dart good-style">Treasure openChest(Chest chest, Point where) {
  if (_opened.containsKey(chest)) return null;

  var treasure = Treasure(where);
  treasure.addAll(chest.contents);
  _opened[chest] = treasure;
  return treasure;
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (arrow-long)"?>
<pre class="prettyprint lang-dart bad-style">Treasure openChest(Chest chest, Point where) =&gt;
    _opened.containsKey(chest) ? null : _opened[chest] = Treasure(where)
      ..addAll(chest.contents);</pre>

<p>您还可以对不返回值的成员使用 <code class="highlighter-rouge">=&gt;</code> 。 
这里有个惯例，就是当 setter 和 getter 都比较简单的时候使用 <code class="highlighter-rouge">=&gt;</code> 。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (arrow-setter)"?>
<pre class="prettyprint lang-dart good-style">num get x =&gt; center.x;
set x(num value) =&gt; center = Point(value, center.y);</pre>

<p>对非 setter，void 返回值的成员，使用 <code class="highlighter-rouge">=&gt;</code> 是一个不错的注意，
<code class="highlighter-rouge">=&gt;</code> 语法暗示会“返回一个值”，如果你在 void 返回值的成员上使用，会让读代码的人误解成员的行为。</p>

<h3 id="不要-使用-this-除非遇到了变量冲突的情况">
<a id="不要-使用-this-除非遇到了变量冲突的情况" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-this-%E9%99%A4%E9%9D%9E%E9%81%87%E5%88%B0%E4%BA%86%E5%8F%98%E9%87%8F%E5%86%B2%E7%AA%81%E7%9A%84%E6%83%85%E5%86%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用 <code class="highlighter-rouge">this.</code> ，除非遇到了变量冲突的情况。</h3>

<p>JavaScript 需要使用 <code class="highlighter-rouge">this.</code> 来引用对象的成员变量，
但是 Dart—和 C++, Java, 以及C#—没有这种限制。</p>

<p>只有当局部变量和成员变量名字一样的时候，你才需要使用 <code class="highlighter-rouge">this.</code> 来访问成员变量。</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (this-dot)"?>
<pre class="prettyprint lang-dart bad-style">class Box {
  var value;

  void clear() {
    this.update(null);
  }

  void update(value) {
    this.value = value;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (this-dot)"?>
<pre class="prettyprint lang-dart good-style">class Box {
  var value;

  void clear() {
    update(null);
  }

  void update(value) {
    this.value = value;
  }
}</pre>

<p>注意，构造函数初始化列表中的字段有永远不会与构造函数参数列表参数产生冲突。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (param-dont-shadow-field-ctr-init)"?>
<pre class="prettyprint lang-dart good-style">class Box extends BaseBox {
  var value;

  Box(value)
      : value = value,
        super(value);
}</pre>

<p>这看起来很令人惊讶，但是实际结果是你想要的。
幸运的是，由于初始化规则的特殊性，上面的代码很少见到。</p>

<h3 id="要-尽可能的在定义变量的时候初始化变量值">
<a id="要-尽可能的在定义变量的时候初始化变量值" class="anchor" href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E5%9C%A8%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 尽可能的在定义变量的时候初始化变量值。</h3>

<p>如果一个字段不依赖于构造函数中的参数，
则应该在定义的时候就初始化字段值。
这样可以减少需要的代码并可以确保在有多个构造函数的时候你不会忘记初始化该字段。</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (field-init-at-decl)"?>
<pre class="prettyprint lang-dart bad-style">class Folder {
  final String name;
  final List&lt;Document&gt; contents;

  Folder(this.name) : contents = [];
  Folder.temp() : name = 'temporary'; // Oops! Forgot contents.
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (field-init-at-decl)"?>
<pre class="prettyprint lang-dart good-style">class Folder {
  final String name;
  final List&lt;Document&gt; contents = [];

  Folder(this.name);
  Folder.temp() : name = 'temporary';
}</pre>

<p>当然，对于变量取值依赖构造函数参数的情况以及不同的构造函数取值也不一样的情况，
则不适合本条规则。</p>

<h2 id="构造函数">
<a id="构造函数" class="anchor" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造函数</h2>

<p>下面对于类的构造函数的最佳实践。</p>

<h3 id="要-尽可能的使用初始化形式">
<a id="要-尽可能的使用初始化形式" class="anchor" href="#%E8%A6%81-%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BD%A2%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 尽可能的使用初始化形式。</h3>

<p>许多字段直接使用构造函数参数来初始化，如：</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (field-init-as-param)"?>
<pre class="prettyprint lang-dart bad-style">class Point {
  num x, y;
  Point(num x, num y) {
    this.x = x;
    this.y = y;
  }
}</pre>

<p>为了初始化一个字段，我们需要取_四_次 <code class="highlighter-rouge">x</code> 。使用下面的方式会更好：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (field-init-as-param)"?>
<pre class="prettyprint lang-dart good-style">class Point {
  num x, y;
  Point(this.x, this.y);
}</pre>

<p>这里的位于构造函数参数之前的 <code class="highlighter-rouge">this.</code> 语法被称之为初始化形式（initializing formal）。
有些情况下这无法使用这种形式。特别是，这种形式下在初始化列表中无法看到变量。 
但是如果能使用该方式，就应该尽量使用。</p>

<h3 id="不要-在初始化形式中做类型注释">
<a id="不要-在初始化形式中做类型注释" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BD%A2%E5%BC%8F%E4%B8%AD%E5%81%9A%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 在初始化形式中做类型注释。</h3>

<p>如果构造函数参数使用 <code class="highlighter-rouge">this.</code> 的方式来初始化字段，
这时参数的类型被认为和字段类型相同。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (dont-type-init-formals)"?>
<pre class="prettyprint lang-dart good-style">class Point {
  int x, y;
  Point(this.x, this.y);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (dont-type-init-formals)"?>
<pre class="prettyprint lang-dart bad-style">class Point {
  int x, y;
  Point(int this.x, int this.y);
}</pre>

<h3 id="要-用--来替代空的构造函数体-">
<a id="要-用--来替代空的构造函数体-" class="anchor" href="#%E8%A6%81-%E7%94%A8--%E6%9D%A5%E6%9B%BF%E4%BB%A3%E7%A9%BA%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 用 <code class="highlighter-rouge">;</code> 来替代空的构造函数体 <code class="highlighter-rouge">{}</code>。</h3>

<p>在 Dart 中，没有具体函数体的构造函数可以使用分号结尾。
（事实上，这是不可变构造函数的要求。）</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (semicolon-for-empty-body)"?>
<pre class="prettyprint lang-dart good-style">class Point {
  int x, y;
  Point(this.x, this.y);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (semicolon-for-empty-body)"?>
<pre class="prettyprint lang-dart bad-style">class Point {
  int x, y;
  Point(this.x, this.y) {}
}</pre>

<h3 id="不要-使用-new-">
<a id="不要-使用-new-" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%BD%BF%E7%94%A8-new-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 使用 <code class="highlighter-rouge">new</code> 。</h3>

<p>Dart 2 <code class="highlighter-rouge">new</code> 关键字成为可选项。
即使在Dart 1中，其含义也从未明确过，
以为在工厂构造函数中，调用 <code class="highlighter-rouge">new</code> 可能并不意味着一定会返回一个新对象。</p>

<p>为了减少代码迁移时的痛苦， Dart 语言仍允许使用 <code class="highlighter-rouge">new</code> 关键字，
但请考在你的代码中弃用和删除 <code class="highlighter-rouge">new</code> 。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (no-new)"?>
<pre class="prettyprint lang-dart good-style">Widget build(BuildContext context) {
  return Row(
    children: [
      RaisedButton(
        child: Text('Increment'),
      ),
      Text('Click!'),
    ],
  );
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (no-new)" replace="/new/[!$&!]/g"?>
<pre class="prettyprint lang-dart bad-style">Widget build(BuildContext context) {
  return <span class="highlight">new</span> Row(
    children: [
      <span class="highlight">new</span> RaisedButton(
        child: <span class="highlight">new</span> Text('Increment'),
      ),
      <span class="highlight">new</span> Text('Click!'),
    ],
  );
}</pre>

<h3 id="不要-冗余地使用-const-">
<a id="不要-冗余地使用-const-" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E5%86%97%E4%BD%99%E5%9C%B0%E4%BD%BF%E7%94%A8-const-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 冗余地使用 <code class="highlighter-rouge">const</code> 。</h3>

<p>在表达式一定是常量的上下文中，<code class="highlighter-rouge">const</code> 关键字是隐式的，不需要写，也不应该。
这里包括：</p>

<ul>
  <li>一个字面量常量集合。</li>
  <li>调用一个常量构造函数。</li>
  <li>元数据注解。</li>
  <li>一个常量声明的初始化方法。</li>
  <li>switch case 表达式—— <code class="highlighter-rouge">case</code> 和 <code class="highlighter-rouge">:</code> 中间的部分，不是 case 执行体。</li>
</ul>

<p>（默认值并不包含在这个列表中，因为在 Dart 将来的版本中可能会在支持非常量的默认值。）</p>

<p>基本上，任何地方用 <code class="highlighter-rouge">new</code> 替代 <code class="highlighter-rouge">const</code> 的写法都是错的，
因为 Dart 2 中允许省略 <code class="highlighter-rouge">const</code> 。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (no-const)"?>
<pre class="prettyprint lang-dart good-style">const primaryColors = [
  Color("red", [255, 0, 0]),
  Color("green", [0, 255, 0]),
  Color("blue", [0, 0, 255]),
];</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (no-const)" replace="/ (const)/ [!$1!]/g"?>
<pre class="prettyprint lang-dart bad-style">const primaryColors = <span class="highlight">const</span> [
  <span class="highlight">const</span> Color("red", <span class="highlight">const</span> [255, 0, 0]),
  <span class="highlight">const</span> Color("green", <span class="highlight">const</span> [0, 255, 0]),
  <span class="highlight">const</span> Color("blue", <span class="highlight">const</span> [0, 0, 255]),
];</pre>

<h2 id="错误处理">
<a id="错误处理" class="anchor" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" aria-hidden="true"><span class="octicon octicon-link"></span></a>错误处理</h2>

<p>Dart 使用异常来表示程序执行错误。
下面是关于如何捕获和抛出异常的最佳实践。</p>

<h3 id="避免-使用没有-on-语句的-catch">
<a id="避免-使用没有-on-语句的-catch" class="anchor" href="#%E9%81%BF%E5%85%8D-%E4%BD%BF%E7%94%A8%E6%B2%A1%E6%9C%89-on-%E8%AF%AD%E5%8F%A5%E7%9A%84-catch" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 使用没有 <code class="highlighter-rouge">on</code> 语句的 catch。</h3>

<p>没有 <code class="highlighter-rouge">on</code> 限定的 catch 语句会捕获 try 代码块中抛出的<em>任何</em>异常。
<a href="https://blog.codinghorror.com/new-programming-jargon/">Pokémon exception handling</a> 可能并不是你想要的。
你的代码是否正确的处理 <a href="https://api.dartlang.org/stable/dart-core/StackOverflowError-class.html">StackOverflowError</a> 或者 <a href="https://api.dartlang.org/stable/dart-core/OutOfMemoryError-class.html">OutOfMemoryError</a> 异常？
如果你使用错误的参数调用函数，你是期望调试器定位出你的错误使用情况还是，
把这个有用的 <a href="https://api.dartlang.org/stable/dart-core/ArgumentError-class.html">ArgumentError</a> 给吞噬了？
由于你捕获了 <a href="https://api.dartlang.org/stable/dart-core/AssertionError-class.html">AssertionError</a> 异常，
导致所有 try 块内的 <code class="highlighter-rouge">assert()</code> 语句都失效了，这是你需要的结果吗？</p>

<p>答案和可能是 “no”，在这种情况下，您应该过滤掉捕获的类型。
在大多数情况下，您应该有一个 <code class="highlighter-rouge">on</code> 子句，
这样它能够捕获程序在运行时你所关注的限定类型的异常并进行恰当处理。</p>

<h3 id="不要-丢弃没有使用-on-语句捕获的异常">
<a id="不要-丢弃没有使用-on-语句捕获的异常" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E4%B8%A2%E5%BC%83%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8-on-%E8%AF%AD%E5%8F%A5%E6%8D%95%E8%8E%B7%E7%9A%84%E5%BC%82%E5%B8%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 丢弃没有使用 <code class="highlighter-rouge">on</code> 语句捕获的异常。</h3>

<p>如果你真的期望捕获一段代码内的 <em>所有</em> 异常，
请<em>在捕获异常的地方做些事情</em>。 记录下来并显示给用户，
或者重新抛出（rethrow）异常信息，记得不要默默的丢弃该异常信息。</p>

<h3 id="要-只在代表编程错误的情况下才抛出实现了-error-的异常">
<a id="要-只在代表编程错误的情况下才抛出实现了-error-的异常" class="anchor" href="#%E8%A6%81-%E5%8F%AA%E5%9C%A8%E4%BB%A3%E8%A1%A8%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%8D%E6%8A%9B%E5%87%BA%E5%AE%9E%E7%8E%B0%E4%BA%86-error-%E7%9A%84%E5%BC%82%E5%B8%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 只在代表编程错误的情况下才抛出实现了 <code class="highlighter-rouge">Error</code> 的异常。</h3>

<p><a href="https://api.dartlang.org/stable/Error-class.html">Error</a> 类是所有 <em>编码</em> 错误的基类。当一个该类型或者其子类型，
例如 <a href="https://api.dartlang.org/stable/dart-core/ArgumentError-class.html">ArgumentError</a> 对象被抛出了，这意味着是你代码中的一个 <em>bug</em>。
当你的 API 想要告诉调用者使用错误的时候可以抛出一个 Error 来表明你的意图。</p>

<p>同样的，如果一个异常表示为运行时异常而不是代码 bug， 则抛出 Error 则会误导调用者。
应该抛出核心定义的 Exception 类或者其他类型。</p>

<h3 id="不要-显示的捕获-error-或者其子类">
<a id="不要-显示的捕获-error-或者其子类" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E6%98%BE%E7%A4%BA%E7%9A%84%E6%8D%95%E8%8E%B7-error-%E6%88%96%E8%80%85%E5%85%B6%E5%AD%90%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 显示的捕获 <code class="highlighter-rouge">Error</code> 或者其子类。</h3>

<p>本条衔接上一天内容。既然 Error 表示代码中的 bug，
应该展开整个调用堆栈，暂停程序并打印堆栈跟踪，以便找到错误并修复。</p>

<p>捕获这类错误打破了处理流程并且代码中有 bug。
不要在这里使用错误处理代码，而是需要到导致该错误出现的地方修复你的代码。</p>

<h3 id="要-使用-rethrow-来重新抛出捕获的异常">
<a id="要-使用-rethrow-来重新抛出捕获的异常" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-rethrow-%E6%9D%A5%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E6%8D%95%E8%8E%B7%E7%9A%84%E5%BC%82%E5%B8%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用 <code class="highlighter-rouge">rethrow</code> 来重新抛出捕获的异常。</h3>

<p>如果你想重新抛出一个异常，推荐使用 <code class="highlighter-rouge">rethrow</code> 语句。
<code class="highlighter-rouge">rethrow</code> 保留了原来的异常堆栈信息。 
而 <code class="highlighter-rouge">throw</code> 会把异常堆栈信息重置为最后抛出的位置。</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (rethrow)"?>
<pre class="prettyprint lang-dart bad-style">try {
  somethingRisky();
} catch (e) {
  if (!canHandle(e)) throw e;
  handle(e);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (rethrow)" replace="/rethrow/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">try {
  somethingRisky();
} catch (e) {
  if (!canHandle(e)) <span class="highlight">rethrow</span>;
  handle(e);
}</pre>

<h2 id="异步">
<a id="异步" class="anchor" href="#%E5%BC%82%E6%AD%A5" aria-hidden="true"><span class="octicon octicon-link"></span></a>异步</h2>

<p>Dart 具有几个语言特性来支持异步编程。
下面是针对异步编程的最佳实践。</p>

<h3 id="推荐-使用-asyncawait-而不是直接使用底层的特性">
<a id="推荐-使用-asyncawait-而不是直接使用底层的特性" class="anchor" href="#%E6%8E%A8%E8%8D%90-%E4%BD%BF%E7%94%A8-asyncawait-%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%BA%95%E5%B1%82%E7%9A%84%E7%89%B9%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>推荐</strong> 使用 async/await 而不是直接使用底层的特性。</h3>

<p>显式的异步代码是非常难以阅读和调试的，
即使使用很好的抽象（比如 future）也是如此。
这就是为何 Dart 提供了 <code class="highlighter-rouge">async</code>/<code class="highlighter-rouge">await</code>。
这样可以显著的提高代码的可读性并且让你可以在异步代码中使用语言提供的所有流程控制语句。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (async-await)" replace="/async|await/[!$&!]/g"?>
<pre class="prettyprint lang-dart good-style">Future&lt;int&gt; countActivePlayers(String teamName) <span class="highlight">async</span> {
  try {
    var team = <span class="highlight">await</span> downloadTeam(teamName);
    if (team == null) return 0;

    var players = <span class="highlight">await</span> team.roster;
    return players.where((player) =&gt; player.isActive).length;
  } catch (e) {
    log.error(e);
    return 0;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (async-await)"?>
<pre class="prettyprint lang-dart bad-style">Future&lt;int&gt; countActivePlayers(String teamName) {
  return downloadTeam(teamName).then((team) {
    if (team == null) return Future.value(0);

    return team.roster.then((players) {
      return players.where((player) =&gt; player.isActive).length;
    });
  }).catchError((e) {
    log.error(e);
    return 0;
  });
}</pre>

<h3 id="不要-在没有有用效果的情况下使用-async-">
<a id="不要-在没有有用效果的情况下使用-async-" class="anchor" href="#%E4%B8%8D%E8%A6%81-%E5%9C%A8%E6%B2%A1%E6%9C%89%E6%9C%89%E7%94%A8%E6%95%88%E6%9E%9C%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8-async-" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>不要</strong> 在没有有用效果的情况下使用 <code class="highlighter-rouge">async</code> 。</h3>

<p>当成为习惯之后，你可能会在所有和异步相关的函数使用 <code class="highlighter-rouge">async</code>。但是在有些情况下，
如果可以忽略 <code class="highlighter-rouge">async</code>  而不改变方法的行为，则应该这么做：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (unnecessary-async)"?>
<pre class="prettyprint lang-dart good-style">Future afterTwoThings(Future first, Future second) {
  return Future.wait([first, second]);
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (unnecessary-async)"?>
<pre class="prettyprint lang-dart bad-style">Future afterTwoThings(Future first, Future second) async {
  return Future.wait([first, second]);
}</pre>

<p>下面这些情况 <code class="highlighter-rouge">async</code> 是有用的：</p>

<ul>
  <li>
    <p>你使用了 <code class="highlighter-rouge">await</code>。 (这是一个很明显的例子。)</p>
  </li>
  <li>
    <p>你在异步的抛出一个异常。 <code class="highlighter-rouge">async</code> 然后 <code class="highlighter-rouge">throw</code> 比 <code class="highlighter-rouge">return new Future.error(...)</code> 要简短很多。</p>
  </li>
  <li>
    <p>你在返回一个值，但是你希望他显式的使用 Future。<code class="highlighter-rouge">async</code> 比 <code class="highlighter-rouge">new Future.value(...)</code> 要简短很多。</p>
  </li>
  <li>
    <p>你不希望在事件循环发生事件之前执行任何代码。</p>
  </li>
</ul>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (async)"?>
<pre class="prettyprint lang-dart good-style">Future usesAwait(Future later) async {
  print(await later);
}

Future asyncError() async {
  throw 'Error!';
}

Future asyncValue() async =&gt; 'value';</pre>

<h3 id="考虑-使用高阶函数来转换事件流stream">
<a id="考虑-使用高阶函数来转换事件流stream" class="anchor" href="#%E8%80%83%E8%99%91-%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BD%AC%E6%8D%A2%E4%BA%8B%E4%BB%B6%E6%B5%81stream" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>考虑</strong> 使用高阶函数来转换事件流（stream）</h3>

<p>This parallels the above suggestion on iterables. Streams support many of the
same methods and also handle things like transmitting errors, closing, etc.
correctly.</p>

<h3 id="避免-直接使用-completer--">
<a id="避免-直接使用-completer--" class="anchor" href="#%E9%81%BF%E5%85%8D-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-completer--" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>避免</strong> 直接使用 Completer  。</h3>

<p>很多异步编程的新手想要编写生成一个 future 的代码。
而 Future 的构造函数看起来并不满足他们的要求，
然后他们就发现 Completer 类并使用它：</p>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (avoid-completer)"?>
<pre class="prettyprint lang-dart bad-style">Future&lt;bool&gt; fileContainsBear(String path) {
  var completer = Completer&lt;bool&gt;();

  File(path).readAsString().then((contents) {
    completer.complete(contents.contains('bear'));
  });

  return completer.future;
}</pre>

<p>Completer 是用于两种底层代码的：
新的异步原子操作和集成没有使用 Future 的异步代码。
大部分的代码都应该使用 async/await 或者 <a href="https://api.dartlang.org/stable/dart-async/Future/then.html"><code class="highlighter-rouge">Future.then()</code></a>，
这样代码更加清晰并且异常处理更加容易。</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (avoid-completer)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;bool&gt; fileContainsBear(String path) {
  return File(path).readAsString().then((contents) {
    return contents.contains('bear');
  });
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (avoid-completer-alt)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;bool&gt; fileContainsBear(String path) async {
  var contents = await File(path).readAsString();
  return contents.contains('bear');
}</pre>

<h3 id="要-使用-futuret-对-futureort-参数进行测试以消除参数可能是-object-类型的歧义">
<a id="要-使用-futuret-对-futureort-参数进行测试以消除参数可能是-object-类型的歧义" class="anchor" href="#%E8%A6%81-%E4%BD%BF%E7%94%A8-futuret-%E5%AF%B9-futureort-%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%A5%E6%B6%88%E9%99%A4%E5%8F%82%E6%95%B0%E5%8F%AF%E8%83%BD%E6%98%AF-object-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AD%A7%E4%B9%89" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>要</strong> 使用 <code class="highlighter-rouge">Future&lt;T&gt;</code> 对 <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> 参数进行测试，以消除参数可能是 <code class="highlighter-rouge">Object</code> 类型的歧义。</h3>

<p>在使用 <code class="highlighter-rouge">FutureOr&lt;T&gt;</code> 执行任何有用的操作之前，
通常需要做 <code class="highlighter-rouge">is</code> 检查，来确定你拥有的是 <code class="highlighter-rouge">Future&lt;T&gt;</code> 还是一个空的 <code class="highlighter-rouge">T</code>。
如果类型参数是某个特定类型，如 <code class="highlighter-rouge">FutureOr &lt;int&gt;</code>，
使用 <code class="highlighter-rouge">is int</code> 或 <code class="highlighter-rouge">is Future&lt;int&gt;</code> 那种测试都可以。
两者都有效，因为这两种类型是不相交的。</p>

<p>但是，如果值的类型是 <code class="highlighter-rouge">Object</code> 或者可能使用 <code class="highlighter-rouge">Object</code> 实例化的类型参数，这时要分两种情况。
<code class="highlighter-rouge">Future&lt;Object&gt;</code> 本身继承 <code class="highlighter-rouge">Object</code> ，使用 <code class="highlighter-rouge">is Object</code> 或 <code class="highlighter-rouge">is T</code> ，
其中 <code class="highlighter-rouge">T</code> 表示参数的类型，该参数可能是 <code class="highlighter-rouge">Object</code> 的实例，
在这种情况下，即使是 future 对象也会返回 true 。
相反，下面是确切测试 <code class="highlighter-rouge">Future</code> 的例子：</p>

<?code-excerpt "misc/lib/effective_dart/usage_good.dart (test-future-or)"?>
<pre class="prettyprint lang-dart good-style">Future&lt;T&gt; logValue&lt;T&gt;(FutureOr&lt;T&gt; value) async {
  if (value is Future&lt;T&gt;) {
    var result = await value;
    print(result);
    return result;
  } else {
    print(value);
    return value as T;
  }
}</pre>

<?code-excerpt "misc/lib/effective_dart/usage_bad.dart (test-future-or)"?>
<pre class="prettyprint lang-dart bad-style">Future&lt;T&gt; logValue&lt;T&gt;(FutureOr&lt;T&gt; value) async {
  if (value is T) {
    print(value);
    return value;
  } else {
    var result = await value;
    print(result);
    return result;
  }
}</pre>

<p>在错误的示例中，如果给它传一个 <code class="highlighter-rouge">Future&lt;Object&gt;</code> ，
它会错误地将其视为一个空的同步对象值。</p>


          
<nav id="subnav">
  <ul>
    <li class="previous">
      
        <a href="/guides/language/effective-dart/documentation">&lang;&nbsp;&nbsp;文档注释</a>
      
    </li>
    <li class="next">
      
        <a href="/guides/language/effective-dart/design">设计&nbsp;&nbsp;&rang;</a>
      
    </li>
  </ul>
</nav>


        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-md-12 col-lg-3">
        <div class="content">
          <div class="brand">
            <img src="/assets/shared/dart/logo+text/horizontal/mono-004b4974b3112e2d9136b1c457037dfd9fe54e2e69e850d777891e5c2a57a78d.svg" alt="Dart logo" class="brand"/>
          </div>
          <h4><a href="/terms">Terms</a> | <a href="https://policies.google.com/privacy">Privacy</a></h4>
          <style>.menu .material-icons { font-size: 14px; }</style><ul class="menu">
            <li>Site&nbsp;<a href="http://creativecommons.org/licenses/by/3.0/" class="no-automatic-external">CC&nbsp;BY&nbsp;3.0</a></li>
            <li>
              <a href="https://github.com/dartchina/site-www-cn"
                 title="This site's source is on GitHub."
                 class="no-automatic-external"><i class="fab fa-github fa-sm"></i></a>
              &nbsp;
              <a href="https://github.com/dartchina/site-www-cn/issues"
                 title="File an issue about this site."
                 class="no-automatic-external"><i class="fas fa-bug fa-sm"></i></a>
              &nbsp;
              <a 
                 title="Site built on 2018/11/23 20:37 CST"
                 
                 class="no-automatic-external"><i class="material-icons">build</i></a>
            </li>
          </ul>
        </div>
      </div>
      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>技术</h4>
          <ul>
            <li><a href="https://flutter.io">Dart 移动开发 (Flutter)</a></li>
            <li><a href="https://webdev.dartlang.org">Dart web 开发</a></li>
            <li><a href="/dart-vm">Dart 服务器开发</a></li>
            <li><a href="https://dart-lang.github.io/observatory/">Observatory 工具</a></li>
            <li><a href="/guides/libraries">Dart 库</a></li>
            <li><a href="/guides/language">Dart 编程语言</a></li>
          </ul>
        </div>
      </div>

      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>资源</h4>
          <ul>
            <li><a href="https://api.dartlang.org/stable">API 参考</a></li>
            <li><a href="https://dartpad.dartlang.org/">DartPad</a></li>
            <li><a href="https://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="http://news.dartlang.org/">Dart 新闻</a></li>
            <li><a href="https://github.com/dart-lang/sdk/issues">Dart bugs 和 <br> 新需求</a></li>
          </ul>
        </div>
      </div>

      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>社区</h4>
          <ul>
            <li><a href="/community">支持和邮件列表</a></li>
            <li><a href="/community/who-uses-dart">谁在用Dart</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
            <li>G+ <a href="https://plus.google.com/communities/114566943291919232850">社区</a> &
                <a href="https://plus.google.com/b/109866369054280216564/+dartlang">公告组</a></li>
            <li><a href="https://gitter.im/dart-lang/home">Gitter聊天室</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
