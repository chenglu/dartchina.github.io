<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="en_US" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="学习如何使 Dart 的命令行应用调用 C/C++ 函数。">
  <title>为独立 Dart VM 提供原生扩展 | Dart</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/touch-icon-iphone-a46c306c4fbfae0b28d63f512b01d7cb2ccf1e4ca9d7f3aab15ba1170beed4a0.png" rel="apple-touch-icon">
  <link href="/assets/touch-icon-ipad-d0181720760b3912858b6d40da1d5586b1e92c7c8656a485ea41005674401e6b.png" rel="apple-touch-icon" sizes="76x76">
  <link href="/assets/touch-icon-iphone-retina-3d9821a631425376ac6203dea3c23c1940ab7b5c506a25406662fab76cee2e0b.png" rel="apple-touch-icon" sizes="120x120">
  <link href="/assets/touch-icon-ipad-retina-b9715401952522f1daee2b4a4064a1bbfb5ffab78d0a47a7226dc87444d51c32.png" rel="apple-touch-icon" sizes="152x152">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="为独立 Dart VM 提供原生扩展" />
  <meta name="twitter:description" content="学习如何使 Dart 的命令行应用调用 C/C++ 函数。" />

  <!-- Open Graph -->
  <meta property="og:title" content="为独立 Dart VM 提供原生扩展" />
  <meta property="og:description" content="学习如何使 Dart 的命令行应用调用 C/C++ 函数。" />
  <meta property="og:url" content="https://www.dartlang.org/articles/dart-vm/native-extensions" />
  <meta property="og:image" content="https://www.dartlang.org/assets/shared/dart-logo-for-shares.png?2" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="/assets/main-743789fa2eea1d0b842284e7e29077de7c7f755aa88e291b7b8bf324a4a2a14b.css">
  <script src="/assets/main-3e89b739cc750412e013252d8b4ced20af281589ffe69a156e6c279177f81069.js" type="text/javascript"></script>
  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


</head>

  <body class="default">
    <header id="page-header">
  <nav id="mainnav">
  <div id="menu-toggle"><i class="icon icon-menu"></i></div>
  <a href="/" class="brand" title="Dart">
    <img src="/assets/shared/dart/logo+text/horizontal/default-363c9c133ffb7780463d3d638632b64cc8221d74d93cd1002fb1efbbe9983bc9.svg" alt="Dart">
  </a>
  <ul>
    <li class="mainnav__get-started"><a href="/guides/get-started"><span>入门</span></a></li>
    <li><a href="/guides/language">语言</a></li>
    <li><a href="/guides/libraries">库</a></li>
    <li><a href="/tools">工具</a></li>
    
    
    <li class="dropdown">
      <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dart 2</a>
      <ul class="dropdown-menu">
        

<li><a href="https://v1-dartlang-org.firebaseapp.com/articles/dart-vm/native-extensions" class="dropdown-item no-automatic-external">1.24.3&nbsp;&nbsp;(archive)</a></li><li><a class="active dropdown-item">2.1.0&nbsp;&nbsp;(stable)</a></li>

        <li role="separator" class="dropdown-divider"></li>
        <li><a class="dropdown-item" href="/dart-2#migration">迁移指南</a></li>
      </ul>
    </li>
    
    <li class="searchfield">
      <form class="navbar-search" action="/search" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input type="search" name="q" id="q" autocomplete="off" placeholder="Search">
        <button type="submit"><i class="icon icon-search"></i></button>
      </form>
    </li>
  </ul>
</nav>

  
</header>

    <main id="page-content">
      <div id="sidenav" class="">
  <div class="content">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/shared/dart/logo+text/horizontal/default-363c9c133ffb7780463d3d638632b64cc8221d74d93cd1002fb1efbbe9983bc9.svg" alt="Dart">
    </a>

    <div class="sidenav__search">
      <p>
        <a href="/search">Search <i class="icon icon-search"></i></a>
      </p>
    </div>

    <ul>
      <li>
        <a class="btn btn-light" href="/guides/get-started">入门</a>
      </li>
    </ul>
    <h4 ><a href="/guides/language" title="语言">语言</a></h4>
  <ul><li >
          <a href="/guides/language/language-tour" title="概览">概览</a>
        </li>
        
        <li >
          <a href="/guides/language/effective-dart" title="Effective Dart">Effective Dart</a>
          <i class="icon icon-arrow"></i>
          <ul><li >
                <a href="/guides/language/effective-dart/style" title="风格">风格</a>
              </li><li >
                <a href="/guides/language/effective-dart/documentation" title="文档">文档</a>
              </li><li >
                <a href="/guides/language/effective-dart/usage" title="使用">使用</a>
              </li><li >
                <a href="/guides/language/effective-dart/design" title="设计">设计</a>
              </li>
          </ul><li >
          <a href="/samples" title="示例代码">示例代码</a>
        </li>
  </ul><h4 ><a href="/guides/libraries" title="库">库</a></h4>
  <ul><li >
          <a href="/guides/libraries/library-tour" title="概览">概览</a>
        </li>
  </ul><h4 ><a href="/guides/platforms" title="平台">平台</a></h4>
  <ul><li >
          <a href="https://flutterchina.club" title="移动端 (Flutter中文网)">移动端 (Flutter中文网)</a>
        </li><li >
          <a href="https://webdev.dartlang.org" title="Web">Web</a>
        </li><li >
          <a href="/dart-vm" title="服务器">服务器</a>
        </li>
  </ul><h4 ><a href="/guides/testing" title="测试">测试</a></h4>
  <ul>
  </ul><h4 >资源</h4>
  <ul><li >
          <a href="/install" title="安装">安装</a>
        </li><li >
          <a href="/codelabs" title="Codelabs">Codelabs</a>
        </li><li >
          <a href="/tutorials" title="学习指南">学习指南</a>
        </li><li class="active">
          <a href="/articles" title="文章">文章</a>
        </li><li >
          <a href="/tools" title="工具">工具</a>
        </li><li >
          <a href="/community" title="社区支持">社区支持</a>
        </li>
  </ul>
  </div>
</div>

      
<div id="toc">
  <div class="content">
    <header class="h4 text-uppercase">
      目录
      <a title="Back to top" class="back-to-top float-right mr-3">
        <i class="fas fa-angle-up"></i>
      </a>
    </header>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#本地扩展解析">本地扩展解析</a></li>
<li class="toc-entry toc-h2"><a href="#示例代码">示例代码</a></li>
<li class="toc-entry toc-h2"><a href="#示例中的同步扩展">示例中的同步扩展</a></li>
<li class="toc-entry toc-h2"><a href="#在本地代码中使用-dart-内嵌-api">在本地代码中使用 Dart 内嵌 API</a></li>
<li class="toc-entry toc-h2"><a href="#dart-handle">Dart handle</a></li>
<li class="toc-entry toc-h2"><a href="#the-native-code-sample_extensioncc">The native code: sample_extension.cc</a></li>
<li class="toc-entry toc-h2"><a href="#the-asynchronous-native-extension">The asynchronous native extension</a>
<ul>
<li class="toc-entry toc-h3"><a href="#wrapping-the-c-function">Wrapping the C function</a></li>
<li class="toc-entry toc-h3"><a href="#setting-up-the-native-port">Setting up the native port</a></li>
<li class="toc-entry toc-h3"><a href="#calling-the-native-port-from-dart">Calling the native port from Dart</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#conclusion-and-further-resources">Conclusion and further resources</a></li>
<li class="toc-entry toc-h2"><a href="#appendix-compiling-and-linking-extensions">Appendix: Compiling and linking extensions</a>
<ul>
<li class="toc-entry toc-h3"><a href="#building-on-linux">Building on Linux</a></li>
<li class="toc-entry toc-h3"><a href="#building-on-mac">Building on Mac</a></li>
<li class="toc-entry toc-h3"><a href="#building-on-windows">Building on Windows</a></li>
</ul>
</li>
</ul>
  </div>
</div>


      <article>
        <div class="content">
           <div class="banner alert alert-info">
  <p class="banner__text">
    
    
    Dart 2.1 现发布，具有更高的性能和可用性。
    <a href="https://medium.com/dartlang/announcing-dart-2-1-improved-performance-usability-9f55fca6f31a">了解更多。</a>
  </p>
</div>
 
          

          <div>
            <div id="page-github-links" class="btn-group" aria-label="Page GitHub links" role="group">
  <a href="https://github.com/dartchina/site-www-cn/tree/src_zh_CN/src_zh_CN/_articles/dart-vm/native-extensions.md" class="btn no-automatic-external" title="View page source" target="_blank" rel="noopener">
    <i class="fas fa-file-alt fa-sm"></i>
  </a>
  <a href="https://github.com/dartchina/site-www-cn/issues/new?title='为独立 Dart VM 提供原生扩展' page issue&body=
Page URL: https://www.dartlang.org/articles/dart-vm/native-extensions%0D%0A
Page source: https://github.com/dartchina/site-www-cn/tree/src_zh_CN/src_zh_CN/_articles/dart-vm/native-extensions.md%0D%0A
%0D%0A
<!-- ADD YOUR DESCRIPTION OF THE PAGE ISSUE HERE: -->" class="btn no-automatic-external" title="Report a issue with this page"
    target="_blank" rel="noopener">
    <i class="fas fa-bug fa-sm"></i>
  </a>
</div>

            <h1>为独立 Dart VM 提供原生扩展</h1>
          </div>
          
<p><em>作者：William Hesse <br>
2012年5月</em></p>

<p>在独立 Dart VM（命令行应用程序）上运行的 Dart 程序可以通过本地扩展调用共享库中的 C 或 C++ 函数。
本文将讲解如何在 Windows，macOS，以及 Linux 上编写和构建这样的本地扩展。</p>

<p>你可以提供两种类型的本地扩展：异步扩展或同步扩展。_异步扩展_在一个单独的线程中执行一个本地函数，由
Dart VM 调度。_同步扩展_直接使用 Dart 虚拟机库的 C API （ Dart 内嵌 API ） 并在 Dart 的独占
线程中执行。通过向 Dart 端口（ Dart port ）发送消息来调用异步函数，在应答端口（ reply port ）接受响应。</p>

<h2 id="本地扩展解析">
<a id="本地扩展解析" class="anchor" href="#%E6%9C%AC%E5%9C%B0%E6%89%A9%E5%B1%95%E8%A7%A3%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>本地扩展解析</h2>

<p>一个 Dart 本地扩展包含两部分： Dart 库和本地库。 Dart 库的类及顶层函数的定义方式不变，
但在这些函数中，使用本地代码中实现的函数需要使用 <strong>native</strong> 关键字声明。本地库是使用
C 或 C++ 编写的共享库，库中包含了这些函数（使用 <strong>native</strong> 关键字声明的函数）的实现。</p>

<p>Dart 库使用 <code class="highlighter-rouge">import</code> 语句和 <strong>dart-ext</strong>: URI 的方案指定本机库。截至 1.20 ，
URI 必须是绝对路径，如 <code class="highlighter-rouge">dart-ext:/path/to/extension</code> ，或者只使用扩展名，
如 <code class="highlighter-rouge">dart-ext:extension</code> 。 VM 修改 URI 将平台特定的前缀和后缀添加到扩展名。例如，在
Linux 上 <code class="highlighter-rouge">extension</code> 会变成 <code class="highlighter-rouge">libextension.so</code> 。如果 URI 是绝对路径，那么文件不存
在的情况下会导入失败。如果 URI 只是扩展的名称，那么 VM 会首先查找与导入 Dart 库相邻的文
件。如果没有找到，那么 VM 会将扩展的文件名传递给平台的特殊调用，以加载动态库
（例如，Linux 上的 <code class="highlighter-rouge">dlopen</code> ），此时该库的加载将遵循它所在平台的搜索过程。</p>

<h2 id="示例代码">
<a id="示例代码" class="anchor" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例代码</h2>

<p>文中介绍的扩展示例的代码位于 Dart 仓库的
<a href="https://github.com/dart-lang/sdk/tree/master/samples/sample_extension">samples/sample_extension</a>
目录中。</p>

<p>扩展示例调用 C 标准库的 rand() 和 srand() 函数，将伪随机数返回到 Dart 程序。由于本地的异步扩展
和同步扩展共享了大部分本地代码，所以示例使用了单个本地源文件（以及生成单个共享库）实现了这两个扩展。
这两个扩展的 Dart 部分分别在两个库文件中实现。另外两个 Dart 文件提供了异步和同步扩展的使用和测试示例。</p>

<p>本文中扩展的共享库（本地代码）称为 sample_extension 。 它是一个 C++ 文件，
<a href="https://github.com/dart-lang/sdk/blob/master/samples/sample_extension/sample_extension.cc">sample_extension.cc</a>，
其中包括 6 个被 Dart 调用的函数。</p>

<dl>
  <dt>sample_extension_Init():</dt>
  <dd>在扩展被加载时被调用。</dd>
  <dt>ResolveName():</dt>
  <dd>第一次调用给定名称的本地函数时，将本地函数的 Dart 名称解析为 C 函数指针。</dd>
  <dt>SystemRand() and SystemSrand():</dt>
  <dd>同步扩展的实现。这些本地方法由 Dart 直接调用，它们调用 C 标准库的 rand() 和 srand() 函数。</dd>
  <dt>wrappedRandomArray() and randomArrayServicePort():</dt>
  <dd>异步扩展的实现。 randomArrayServicePort() 函数创建一个本地端口，并将这个端口和
wrappedRandomArray() 函数关联在一起。当 Dart 向本地端口发送一个消息， Dart VM 就会调度
wrappedRandomArray() 函数在一个单独的线程中执行。</dd>
</dl>

<p>共享库中的一些代码用来设置和初始化，对于所有的扩展这些代码几乎是相同的。函数
sample_extension_Init() 和 ResolveName() 在所有的扩展中几乎相同，同样在所有的异步扩展中都
必须有一个类似于 randomArrayServicePort() 的函数。</p>

<h2 id="示例中的同步扩展">
<a id="示例中的同步扩展" class="anchor" href="#%E7%A4%BA%E4%BE%8B%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%89%A9%E5%B1%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例中的同步扩展</h2>

<p>因为异步扩展非常像是在同步扩展的基础上增加了一些函数，所以这里我们首先说明同步扩展。
首先，我们将展示扩展的 Dart 部分以及加载扩展时发生的函数调用序列。然后我们将解释如何使用 Dart 中嵌入的
API ，解释本地代码，以及描述扩展被调用时会发生了什么。</p>

<p>这是同步扩展的 Dart 部分，文件名
<b>sample_synchronous_extension.dart</b>：</p>

<pre class="prettyprint lang-dart">library sample_synchronous_extension;

import 'dart-ext:sample_extension';

// The simplest way to call native code: top-level functions.
int systemRand() native "SystemRand";
bool systemSrand(int seed) native "SystemSrand";</pre>

<p>本地扩展的代码存在两个不同的执行时间。首先，它会在本地扩展加载的时候执行。后面，它会在
本地扩展实现被调用时执行。</p>

<p>下面是加载时的事件序列，当一个 Dart 应用导入 sample_synchronous_extension.dart 时开始执行：</p>

<ol>
  <li>Dart 库 sample_synchronous_extension.dart 被加载，Dart VM 处理
  <b><code>import 'dart-ext:sample_extension'</code></b> 代码。</li>
  <li>Dart VM 从 Dart 库的目录中加载共享库 ‘sample_extension’ 。</li>
  <li>共享库中的 sample_extension_Init() 函数被调用。它将共享库函数 ResolveName() 注册为
  sample_extension.dart 库中所有本地函数的名称解析器。通过解析器可以查找 Dart 中对应的同步
  扩展的本地函数。</li>
</ol>

<aside class="alert alert-info">
<strong>提示：</strong>
共享库的文件名取决于平台。
在 Windows 上，VM 加载 sample_extension.dll ，
在 Linux 上加载 libsample_extension.so ，
在 Mac 上加载 libsample_extension.dylib 。
我们将在本文末尾的附录中展示如何构建和链接这些共享库。
</aside>

<h2 id="在本地代码中使用-dart-内嵌-api">
<a id="在本地代码中使用-dart-内嵌-api" class="anchor" href="#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8-dart-%E5%86%85%E5%B5%8C-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>在本地代码中使用 Dart 内嵌 API</h2>

<p>如扩展示例所示，本地共享库包含初始化函数，名称解析函数以及在扩展中由 Dart 部分声明并在本地实现的函数。
初始化函数注册本地名称解析函数，用作查找该库的本地函数名称。
当 Dart 库中以 <strong><code>native "<em>function_name</em>"</code></strong> 声明的函数被调用时，
本地库使用字符串 “<em>function_name</em>“，以及 “<em>function_name</em>” 函数的参数个数作为参数
调用名称解析函数。然后，名称解析函数会返回一个函数指针，这个函数指针指向对应 “<em>function_name</em>” 
函数的本地函数实现。所有 Dart 的原生扩展中的初始化函数以及名称解析函数看上去几乎是一样的。</p>

<p>本地库中的函数使用 Dart 内嵌 API 与 VM 进行通信，因此本地代码要包含 <b>dart_api.h</b> 头文件，
它位于 SDK 中的 dart-sdk/include/dart_api.h 或者在仓库
<a href="https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h">runtime/include/dart_api.h</a>。
Dart 内嵌 API 作为接口内嵌在包含 Dart VM 的浏览器或者运行命令行程序的独立 VM 中。API 由大约
100 个函数接口和许多数据类型和数据结构定义组成。它们在 dart_api.h 中声明，并备有注释。它们的使用示例在单元测试文件
<a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/dart_api_impl_test.cc">runtime/vm/dart_api_impl_test.cc</a>。</p>

<p>由 Dart 调用的本地函数必须是 <strong>Dart_NativeFunction</strong> 类型，类型在 dart_api.h 中定义为：</p>

<pre class="prettyprint lang-cpp">typedef void (*Dart_NativeFunction)(Dart_NativeArguments arguments);</pre>

<p>可以看到 Dart_NativeFunction 是一个函数指针，函数指针指向只接受一个 Dart_NativeArguments 
参数对象，且无返回值的函数。接受的参数对象是一个 Dart 对象，通过 API 访问该参数对象，可以得到
参数个数，以及指定索引的参数 Dart_Handle 。本地函数向 Dart 应用返回一个 Dart 对象作为返回值。
该返回值被 Dart_SetReturnValue() 函数保存到参数对象里。</p>

<h2 id="dart-handle">
<a id="dart-handle" class="anchor" href="#dart-handle" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dart handle</h2>

<p>扩展的本地函数实现广泛的使用 Dart_Handles 。调用 Dart 内嵌 API 会返回一个 Dart_Handle 并且
常常将 Dart_Handle 作为函数参数。Dart_Handle 是一个间接不透明指针，指向一个在 Dart 堆上的对象，
Dart_Handles 属于值拷贝（浅拷贝）。在垃圾收集阶段会移动堆上的 Dart 对象，但即使是在垃圾收集阶段
这些句柄仍保持有效，因此本地代码必须使用句柄来存储堆上对象的引用。由于这些句柄的存储和持有需要占用
资源，所以必须要在不使用它们的时候对它们进行释放。在释放句柄之前，VM 的垃圾收集器无法收集它指向的对
象，即使这些对象已经不存在其他的引用。</p>

<p>Dart 内嵌 API 会自动创建一个作用域来管理本地函数中句柄的生命周期。本地函数进入时会创建本地句柄的
作用域，并在该函数退出时将作用域删除。如果函数正常返回，或以 PropagateError 退出，则作用域删除。
Dart 内嵌 API 返回的大多数句柄和内存指针都在当前本地作用域内分配，并在函数返回后失效。如果扩展应用
想要长时间保持指向 Dart 对象的指针，可以使用 <em>持久句柄</em>（参见 Dart_NewPersistentHandle() 和 
Dart_NewWeakPersistentHandle() ），这样可以使句柄在本地作用域结束后仍然有效。</p>

<p>调用 Dart 内嵌 API 可能会在 Dart_Handle 返回值中返回错误。这些错误或者是异常应该作为返回值传递
给函数的调用者。</p>

<p>本地扩展中的大多数函数—类型为 Dart_NativeFunction 的函数—没有返回值，必须以另一种
方式将错误传递给错误处理程序。函数中调用 Dart_PropagateError 来传递错误并控制程序流程到错误处理的
位置。该示例使用一个名为 HandleError() 的辅助函数使上述实现更加便捷。Dart_PropagateError() 函数
没有返回。</p>

<h2 id="the-native-code-sample_extensioncc">
<a id="the-native-code-sample_extensioncc" class="anchor" href="#the-native-code-sample_extensioncc" aria-hidden="true"><span class="octicon octicon-link"></span></a>The native code: sample_extension.cc</h2>

<p>Now we’ll show the native code for the sample extension, starting with the
initialization function, then the native function implementations, and ending
with the name resolution function. The two native functions implementing the
asynchronous extension are shown later.</p>

<pre class="prettyprint lang-cpp">#include &lt;string.h&gt;
#include "dart_api.h"
// Forward declaration of ResolveName function.
Dart_NativeFunction ResolveName(Dart_Handle name, int argc, bool* auto_setup_scope);

// The name of the initialization function is the extension name followed
// by _Init.
DART_EXPORT Dart_Handle sample_extension_Init(Dart_Handle parent_library) {
  if (Dart_IsError(parent_library)) return parent_library;

  Dart_Handle result_code =
      Dart_SetNativeResolver(parent_library, ResolveName, NULL);
  if (Dart_IsError(result_code)) return result_code;

  return Dart_Null();
}

Dart_Handle HandleError(Dart_Handle handle) {
 if (Dart_IsError(handle)) Dart_PropagateError(handle);
 return handle;
}

// Native functions get their arguments in a Dart_NativeArguments structure
// and return their results with Dart_SetReturnValue.
void SystemRand(Dart_NativeArguments arguments) {
  Dart_Handle result = HandleError(Dart_NewInteger(rand()));
  Dart_SetReturnValue(arguments, result);
}

void SystemSrand(Dart_NativeArguments arguments) {
  bool success = false;
  Dart_Handle seed_object =
      HandleError(Dart_GetNativeArgument(arguments, 0));
  if (Dart_IsInteger(seed_object)) {
    bool fits;
    HandleError(Dart_IntegerFitsIntoInt64(seed_object, &amp;fits));
    if (fits) {
      int64_t seed;
      HandleError(Dart_IntegerToInt64(seed_object, &amp;seed));
      srand(static_cast&lt;unsigned&gt;(seed));
      success = true;
    }
  }
  Dart_SetReturnValue(arguments, HandleError(Dart_NewBoolean(success)));
}

Dart_NativeFunction ResolveName(Dart_Handle name, int argc, bool* auto_setup_scope) {
  // If we fail, we return NULL, and Dart throws an exception.
  if (!Dart_IsString(name)) return NULL;
  Dart_NativeFunction result = NULL;
  const char* cname;
  HandleError(Dart_StringToCString(name, &amp;cname));

  if (strcmp("SystemRand", cname) == 0) result = SystemRand;
  if (strcmp("SystemSrand", cname) == 0) result = SystemSrand;
  return result;
}</pre>

<p>Here is the sequence of events that happens at runtime, when the function
systemRand() (defined in sample_synchronous_extension.dart) is called for the
first time.</p>

<ol>
  <li>The function ResolveName() in the shared library is called with a Dart string containing “SystemRand” and the integer 0, representing the number of arguments in the call. The string “SystemRand” is the string literal following the <b>native</b> keyword in the declaration of systemRand().</li>
  <li>ResolveName() returns a pointer to the native function SystemRand() in the shared library.</li>
  <li>The arguments to the systemRand() call in Dart are packaged into a Dart_NativeArguments object, and SystemRand() is called with this object as its only argument.</li>
  <li>SystemRand() does its computations, puts its return value into the Dart_NativeArguments object, and returns.</li>
  <li>The Dart VM extracts the return value from the Dart_NativeArguments object, returning it as the result of the Dart call to systemRand().</li>
</ol>

<p>On later calls to systemRand(), the result of the function lookup has been cached, so ResolveName() is not called again.</p>

<h2 id="the-asynchronous-native-extension">
<a id="the-asynchronous-native-extension" class="anchor" href="#the-asynchronous-native-extension" aria-hidden="true"><span class="octicon octicon-link"></span></a>The asynchronous native extension</h2>

<p>As we saw above, a synchronous extension uses the Dart Embedding API to work
with Dart heap objects, and it runs on the main Dart thread for the current
isolate. An asynchronous extension, on the other hand, does not use most of the
Dart Embedding API, and it runs on a separate thread so as not to block the main
Dart thread.</p>

<p>In many ways, asynchronous extensions are simpler to program than synchronous
extensions.  They use the native ports functions in the Dart Embedding API to
schedule C functions on independent threads. To Dart code that uses the
extension, it appears simply as a Dart SendPort.  The messages posted to this
port are automatically translated into a C structure called a Dart_CObject,
containing C data types such as int, double, and char*. This C structure is then
passed to a C function, which is run in an independent thread drawn from a pool
of threads managed by the VM. The C function can respond by a Dart_CObject to a
reply port. The Dart_CObject is translated back into a tree of Dart objects, and
appears as a reply on the Dart async call’s reply port. This automatic
conversion of Dart objects into a Dart_CObject C structure replaces the use of
the Dart Embedding API to fetch fields from objects and to convert Dart objects
into C value types.</p>

<p>To create an asynchronous native extension, we do three things:</p>

<ol>
  <li>Wrap the C function we wish to call with a wrapper that converts the
  Dart_CObject input argument to the desired input parameters, converts the
  result of the function to a Dart_CObject, and posts it back to Dart.</li>
  <li>Write a native function that creates a native port and attaches it to the
  wrapped function.  This native function is a synchronous native method, and
  it’s in a native extension that looks just like the synchronous extension
  above. We have just added the wrapped function from step 1 to the extension,
  as well.</li>
  <li>Write a Dart class that fetches the native port and caches it. In that class,
  provide a function that forwards its arguments to the native port as a
  message, and calls a callback argument when it receives a reply to that
  message.</li>
</ol>

<h3 id="wrapping-the-c-function">
<a id="wrapping-the-c-function" class="anchor" href="#wrapping-the-c-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wrapping the C function</h3>

<p>Here is an example of a C function (actually, a C++ function, due to the use of
reinterpret_cast) that creates an array of random bytes,
given a seed and a length.  It returns the data in a newly allocated array,
which will be freed by the wrapper:</p>

<pre class="prettyprint lang-cpp">uint8_t* random_array(int seed, int length) {
  if (length &lt;= 0 || length &gt; 10000000) return NULL;

  uint8_t* values = reinterpret_cast&lt;uint8_t*&gt;(malloc(length));
  if (NULL == values) return NULL;

  srand(seed);
  for (int i = 0; i &lt; length; ++i) {
    values[i] = rand() % 256;
  }
  return values;
}</pre>

<p>To call this from Dart, we put it in a wrapper that unpacks the Dart_CObject
containing seed and length, and that packs the result values into a
Dart_CObject.  A Dart_CObject can hold an integer (of various sizes), a double,
a string, or an array of Dart_CObjects. It is implemented in
<a href="https://github.com/dart-lang/sdk/blob/master/runtime/include/dart_api.h">dart_api.h</a>
as a struct
containing a union. Look in dart_api.h to see the fields and tags used to access
the union’s members. After the Dart_CObject is posted, it and all its resources
can be freed, since they have been copied into Dart objects on the Dart heap.</p>

<pre class="prettyprint lang-cpp">void wrappedRandomArray(Dart_Port dest_port_id,
                        Dart_Port reply_port_id,
                        Dart_CObject* message) {
  if (message-&gt;type == Dart_CObject::kArray &amp;&amp;
      2 == message-&gt;value.as_array.length) {
    // Use .as_array and .as_int32 to access the data in the Dart_CObject.
    Dart_CObject* param0 = message-&gt;value.as_array.values[0];
    Dart_CObject* param1 = message-&gt;value.as_array.values[1];
    if (param0-&gt;type == Dart_CObject::kInt32 &amp;&amp;
        param1-&gt;type == Dart_CObject::kInt32) {
      int length = param0-&gt;value.as_int32;
      int seed = param1-&gt;value.as_int32;

      uint8_t* values = randomArray(seed, length);

      if (values != NULL) {
        Dart_CObject result;
        result.type = Dart_CObject::kUint8Array;
        result.value.as_byte_array.values = values;
        result.value.as_byte_array.length = length;
        Dart_PostCObject(reply_port_id, &amp;result);
        free(values);
        // It is OK that result is destroyed when function exits.
        // Dart_PostCObject has copied its data.
        return;
      }
    }
  }
  Dart_CObject result;
  result.type = Dart_CObject::kNull;
  Dart_PostCObject(reply_port_id, &amp;result);
}</pre>

<p>Dart_PostCObject() is the only Dart Embedding API function that should be called
from the wrapper or the C function. Most of the API is illegal to call here,
because there is no current isolate. No errors or exceptions can be thrown, so
any error must be encoded in the reply message, to be decoded and thrown by the
Dart part of the extension.</p>

<h3 id="setting-up-the-native-port">
<a id="setting-up-the-native-port" class="anchor" href="#setting-up-the-native-port" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting up the native port</h3>

<p>Now we set up the mechanism that calls this wrapped C function from Dart code,
by sending a message. We create a native port that calls this function, and
return a send port connected to that port. The Dart library gets the port from
this function, and forwards calls to the port.</p>

<pre class="prettyprint lang-cpp">void randomArrayServicePort(Dart_NativeArguments arguments) {
  Dart_SetReturnValue(arguments, Dart_Null());
  Dart_Port service_port =
      Dart_NewNativePort("RandomArrayService", wrappedRandomArray, true);
  if (service_port != kIllegalPort) {
    Dart_Handle send_port = Dart_NewSendPort(service_port);
    Dart_SetReturnValue(arguments, send_port);
  }
}</pre>

<h3 id="calling-the-native-port-from-dart">
<a id="calling-the-native-port-from-dart" class="anchor" href="#calling-the-native-port-from-dart" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calling the native port from Dart</h3>

<p>On the Dart side, we need a class that stores this send port, sending messages
to it when a Dart asynchronous function with a callback is called. The Dart
class gets the port the first time the function is called, caching it in the
usual way. Here is the Dart library for the asynchronous extension:</p>

<pre class="prettyprint lang-dart">library sample_asynchronous_extension;

import 'dart-ext:sample_extension';

// A class caches the native port used to call an asynchronous extension.
class RandomArray {
  static SendPort _port;

  void randomArray(int seed, int length, void callback(List result)) {
    var args = new List(2);
    args[0] = seed;
    args[1] = length;
    _servicePort.call(args).then((result) {
      if (result != null) {
        callback(result);
      } else {
        throw new Exception("Random array creation failed");
      }
    });
  }

  SendPort get _servicePort {
    if (_port == null) {
      _port = _newServicePort();
    }
    return _port;
  }

  SendPort _newServicePort() native "RandomArray_ServicePort";
}</pre>

<h2 id="conclusion-and-further-resources">
<a id="conclusion-and-further-resources" class="anchor" href="#conclusion-and-further-resources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion and further resources</h2>

<p>You’ve seen both synchronous and asynchronous native extensions. We hope that
you’ll use these tools to provide access to existing C and C++ libraries,
thereby adding useful new capabilities to the standalone Dart VM.  We recommend
using asynchronous extensions rather than synchronous extensions, because
asynchronous extensions don’t block the main Dart thread and can be simpler to
implement. The built-in Dart I/O libraries are built around asynchronous calls
to achieve high, non-blocking throughput. Extensions should have the same
performance goals.</p>

<h2 id="appendix-compiling-and-linking-extensions">
<a id="appendix-compiling-and-linking-extensions" class="anchor" href="#appendix-compiling-and-linking-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix: Compiling and linking extensions</h2>

<p>Building a shared library can be tricky, and the tools to do it are platform
dependent. Building Dart native extensions is especially tricky because they are
dynamically loaded, and they link to Dart Embedding API functions in the Dart
library embedded in the executable that dynamically loads them.</p>

<p>As with all shared libraries, the compilation step must generate position-
independent code. The linker step must specify that unresolved functions will be
resolved in the executable when the library is loaded. We will show commands
that do this on the Linux, Windows, and Mac platforms. If you download the dart
source repository, the sample code also includes a platform-independent build
system, called gyp, and a build file sample_extension.gypi that builds the
sample extension.</p>

<h3 id="building-on-linux">
<a id="building-on-linux" class="anchor" href="#building-on-linux" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building on Linux</h3>

<p>On Linux, you can compile the code in the samples/sample_extension directory like this:</p>

<pre>g++ -fPIC -m32 -I{path to SDK include directory} -DDART_SHARED_LIB -c sample_extension.cc</pre>

<p>To create the shared library from the object file:</p>

<pre>gcc -shared -m32 -Wl,-soname,libsample_extension.so -o
libsample_extension.so sample_extension.o</pre>

<p>Remove the -m32 to build a 64-bit library that runs with the 64-bit Dart standalone VM.</p>

<h3 id="building-on-mac">
<a id="building-on-mac" class="anchor" href="#building-on-mac" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building on Mac</h3>

<ol>
  <li>Using Xcode (tested with Xcode 3.2.6), create a new project with the same name as the native extension, of type Framework &amp; Library/BSD C Library, type dynamic.</li>
  <li>Add the source files of your extension to the source section of the project.</li>
  <li>Make the following changes in Project/Edit Project Settings, choosing the Build tab and All Configurations in the dialog box:
    <ol>
      <li>In section Linking, line Other Linker Flags, add -undefined dynamic_lookup.</li>
      <li>In section Search Paths, line Header Search Paths, add the path to dart_api.h in the SDK download or the Dart repository checkout.</li>
      <li>In section Preprocessing, line Preprocessor Macros, add DART_SHARED_LIB=1</li>
    </ol>
  </li>
  <li>Choose the correct architecture (i386 or x86_64), and build by choosing Build/Build.</li>
</ol>

<p>The resulting lib[extension_name].dylib will be in the <b>build/</b> subdirectory of your project location, so copy it to the desired location (probably the location of the Dart library part of the extension).</p>

<h3 id="building-on-windows">
<a id="building-on-windows" class="anchor" href="#building-on-windows" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building on Windows</h3>

<p>The Windows DLL compilation is complicated by the fact that we need to link with
library file, dart.lib, that does not contain code itself, but specifies that
calls to the Dart Embedding API will be resolved by linking to the Dart
executable, dart.exe, when the DLL is dynamically loaded. This library file is
generated when building dart and is included in the Dart SDK.</p>

<ol>
  <li>Create a new project of type Win32/Win32 project in Visual Studio 2008 or 2010. Give the project the same name as the native extension. On the next screen of the wizard, change the application type to DLL and select “Empty project”, then choose finish.</li>
  <li>Add the C/C++ files for the native extension to the source files folder in the project.  Make sure to include the [extension name]_dllmain_win.cc file.</li>
  <li>Change the following settings in the project’s properties:
    <ol>
      <li>Configuration properties / Linker / Input / Additional dependencies: Add dart-sdk\bin\dart.lib, from the downloaded Dart SDK.</li>
      <li>Configuration properties / C/C++ / General / Additional Include Directories: Add the path to the directory containing dart_api.h, which is dart-sdk/include in the downloaded Dart SDK.</li>
      <li>Configuration properties / C/C++ / Preprocessor / Preprocessor Definitions: Add DART_SHARED_LIB. This is just to export the <extension name="">_init function from the DLL, since it has been declared as DART_EXPORT.</extension>
</li>
    </ol>
  </li>
  <li>Build the project, and copy the DLL to the correct directory, relative to the Dart library part of the extension.  Make sure to build a 32-bit DLL for use with the 32-bit SDK download, and a 64-bit DLL for use with the 64-bit download.</li>
</ol>

          

        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-md-12 col-lg-3">
        <div class="content">
          <div class="brand">
            <img src="/assets/shared/dart/logo+text/horizontal/mono-004b4974b3112e2d9136b1c457037dfd9fe54e2e69e850d777891e5c2a57a78d.svg" alt="Dart logo" class="brand"/>
          </div>
          <h4><a href="/terms">Terms</a> | <a href="https://policies.google.com/privacy">Privacy</a></h4>
          <style>.menu .material-icons { font-size: 14px; }</style><ul class="menu">
            <li>Site&nbsp;<a href="http://creativecommons.org/licenses/by/3.0/" class="no-automatic-external">CC&nbsp;BY&nbsp;3.0</a></li>
            <li>
              <a href="https://github.com/dartchina/site-www-cn"
                 title="This site's source is on GitHub."
                 class="no-automatic-external"><i class="fab fa-github fa-sm"></i></a>
              &nbsp;
              <a href="https://github.com/dartchina/site-www-cn/issues"
                 title="File an issue about this site."
                 class="no-automatic-external"><i class="fas fa-bug fa-sm"></i></a>
              &nbsp;
              <a 
                 title="Site built on 2018/12/18 13:42 CST"
                 
                 class="no-automatic-external"><i class="material-icons">build</i></a>
            </li>
          </ul>
        </div>
      </div>
      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>技术</h4>
          <ul>
            <li><a href="https://flutterchina.club">Dart 移动开发 (Flutter)</a></li>
            <li><a href="https://webdev.dartlang.org">Dart web 开发</a></li>
            <li><a href="/dart-vm">Dart 服务器开发</a></li>
            <li><a href="https://dart-lang.github.io/observatory/">Observatory 工具</a></li>
            <li><a href="/guides/libraries">Dart 库</a></li>
            <li><a href="/guides/language">Dart 编程语言</a></li>
          </ul>
        </div>
      </div>

      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>资源</h4>
          <ul>
            <li><a href="https://api.dartlang.org/stable">API 参考</a></li>
            <li><a href="https://dartpad.dartlang.org/">DartPad</a></li>
            <li><a href="https://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="http://news.dartlang.org/">Dart 新闻</a></li>
            <li><a href="https://github.com/dart-lang/sdk/issues">Dart bugs 和 <br> 新需求</a></li>
          </ul>
        </div>
      </div>

      <div class="col-md-4 col-lg-3">
        <div class="content">
          <h4>社区</h4>
          <ul>
            <li><a href="/community">支持和邮件列表</a></li>
            <li><a href="/community/who-uses-dart">谁在用Dart</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
            <li>G+ <a href="https://plus.google.com/communities/114566943291919232850">社区</a> &
                <a href="https://plus.google.com/b/109866369054280216564/+dartlang">公告组</a></li>
            <li><a href="https://gitter.im/dart-lang/home">Gitter聊天室</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
